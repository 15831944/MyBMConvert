#pragma once

// Copyright (c) 1998-2014 by Tech Soft 3D, Inc.
//
// The information contained herein is confidential and proprietary to Tech Soft 3D, Inc.,
// and considered a trade secret as defined under civil and criminal statutes.
// Tech Soft 3D, Inc. shall pursue its civil and criminal remedies in the event of
// unauthorized use or misappropriation of its trade secrets.  Use of this information
// by anyone other than authorized employees of Tech Soft 3D, Inc. is granted only under
// a written non-disclosure agreement, expressly prescribing the scope and manner of such use.

char const * const dx11_cs_edgepat_length =
	"#define THREAD_GROUP_X 256\n"
	"cbuffer Constants : register(b0)\n"
	"{\n"
	"	row_major float4x4		xform;\n"
	"	float					U_SCALE;\n"
	"	float					V_SCALE;\n"
	"};\n"
	"ByteAddressBuffer   BufferIn  : register(t0);\n"
	"RWByteAddressBuffer BufferOut : register(u0);\n"
	"float3 getpoint(int i)\n"
	"{\n"
	"	float3 p;\n"
	"	p.x = asfloat(BufferIn.Load(i*12));\n"
	"	p.y = asfloat(BufferIn.Load(i*12 + 4));\n"
	"	p.z = asfloat(BufferIn.Load(i*12 + 8));\n"
	"	return p;\n"
	"}\n"
	"[numthreads(THREAD_GROUP_X, 1, 1)]\n"
	"void main_compute(int dtid : SV_DispatchThreadID)\n"
	"{\n"
	"	float3 p0 = getpoint(2 * dtid);\n"
	"	float3 p1 = getpoint(2 * dtid + 1);\n"
	"	float4 t0 = mul(float4(p0, 1.0), xform);\n"
	"	float4 t1 = mul(float4(p1, 1.0), xform);\n"
	"	float2 tt0 = t0.xy / t0.w;\n"
	"	float2 tt1 = t1.xy / t1.w;\n"
	"	float len = length(tt1 - tt0) * U_SCALE;\n"
	"	BufferOut.Store((2*dtid+1)*12, asuint(len));\n"
	"	BufferOut.Store((2*dtid+1)*12 + 4, asuint(V_SCALE));\n"
	"}\n"
; 


char const * const dx11_cs_linepat_clip =
	"#define THREAD_GROUP_X 256\n"
	"cbuffer Constants : register(b0)\n"
	"{\n"
	"	float4 leftPlane;\n"
	"	float4 rightPlane;\n"
	"	float4 bottomPlane;\n"
	"	float4 topPlane;\n"
	"	float4 nearPlane;\n"
	"	float4 farPlane;\n"
	"};\n"
	"ByteAddressBuffer   BufferIn  : register(t0);\n"
	"RWByteAddressBuffer BufferOut : register(u0);\n"
	"float3 getpoint(int i)\n"
	"{\n"
	"	float3 p;\n"
	"	p.x = asfloat(BufferIn.Load(i*12));\n"
	"	p.y = asfloat(BufferIn.Load(i*12 + 4));\n"
	"	p.z = asfloat(BufferIn.Load(i*12 + 8));\n"
	"	return p;\n"
	"}\n"
	"void storepoint(int i, float3 p)\n"
	"{\n"
	"	BufferOut.Store(i*12 + 0, asuint(p.x));\n"
	"	BufferOut.Store(i*12 + 4, asuint(p.y));\n"
	"	BufferOut.Store(i*12 + 8, asuint(p.z));\n"
	"}\n"
	"void clipLinePlane(inout float3 p0, inout float3 p1, const float4 plane)\n"
	"{\n"
	"	float3 N = plane.xyz;\n"
	"	float  w = plane.w;\n"
	"	float denom = dot(N, p1 - p0);\n"
	"	if (abs(denom) < 0.0001)\n"
	"		return;\n"
	"	float d0 = dot(N, p0) + w;\n"
	"	float d1 = dot(N, p1) + w;\n"
	"	if (d0 > 0 && d1 > 0)\n"
	"		return;\n"
	"	if (d0 < 0 && d1 < 0)\n"
	"	{\n"
	"		p1 = p0;\n"
	"		return;	\n"
	"	}\n"
	"	float t = -(dot(N, p0) + w) / denom;\n"
	"	float3 p = p0 + t * (p1 - p0);\n"
	"	if (d0 < 0)\n"
	"		p0 = p;\n"
	"	else\n"
	"		p1 = p;\n"
	"}\n"
	"[numthreads(THREAD_GROUP_X, 1, 1)]\n"
	"void main_compute(\n"
	"	int gid  : SV_GroupID,\n"
	"	int gtid : SV_GroupThreadID,\n"
	"	int dtid : SV_DispatchThreadID)\n"
	"{\n"
	"	float3 p0 = getpoint(2*dtid);\n"
	"	float3 p1 = getpoint(2*dtid+1);\n"
	"	clipLinePlane(p0, p1, leftPlane);\n"
	"	clipLinePlane(p0, p1, rightPlane);\n"
	"	clipLinePlane(p0, p1, bottomPlane);\n"
	"	clipLinePlane(p0, p1, topPlane);\n"
	"	clipLinePlane(p0, p1, nearPlane);\n"
	"	clipLinePlane(p0, p1, farPlane);\n"
	"	storepoint(2*dtid, p0);\n"
	"	storepoint(2*dtid+1, p1);\n"
	"}\n"
; 


char const * const dx11_cs_linepat_length =
	"#define THREAD_GROUP_X 256\n"
	"groupshared float temp[THREAD_GROUP_X * 2];\n"
	"cbuffer Constants : register(b0)\n"
	"{\n"
	"	row_major float4x4		xform;\n"
	"	float					U_SCALE;\n"
	"	float					V_SCALE;\n"
	"};\n"
	"ByteAddressBuffer   BufferIn  : register(t0);\n"
	"RWByteAddressBuffer BufferOut : register(u0);\n"
	"float3 getpoint(int i)\n"
	"{\n"
	"	float3 p;\n"
	"	p.x = asfloat(BufferIn.Load(i*12));\n"
	"	p.y = asfloat(BufferIn.Load(i*12 + 4));\n"
	"	p.z = asfloat(BufferIn.Load(i*12 + 8));\n"
	"	return p;\n"
	"}\n"
	"[numthreads(THREAD_GROUP_X, 1, 1)]\n"
	"void main_compute(\n"
	"	int gid  : SV_GroupID,\n"
	"	int gtid : SV_GroupThreadID,\n"
	"	int dtid : SV_DispatchThreadID)\n"
	"{\n"
	"	float3 p0 = getpoint(2 * dtid);\n"
	"	float3 p1 = getpoint(2 * dtid + 1);\n"
	"	float4 t0 = mul(float4(p0, 1.0), xform);\n"
	"	float4 t1 = mul(float4(p1, 1.0), xform);\n"
	"	float2 tt0 = t0.xy / t0.w;\n"
	"	float2 tt1 = t1.xy / t1.w;\n"
	"	float len = length(tt1 - tt0) * U_SCALE;\n"
	"	int pout = 0;\n"
	"	int pin  = 1;	\n"
	"	temp[pout*THREAD_GROUP_X + gtid] = len;\n"
	"	for (uint offset = 1; offset < THREAD_GROUP_X; offset *= 2)\n"
	"	{\n"
	"		pout = 1 - pout;\n"
	"		pin  = 1 - pin;\n"
	"		GroupMemoryBarrierWithGroupSync();\n"
	"		temp[pout*THREAD_GROUP_X + gtid] = temp[pin*THREAD_GROUP_X + gtid];\n"
	"		if (gtid >= offset)\n"
	"			temp[pout*THREAD_GROUP_X + gtid] += temp[pin*THREAD_GROUP_X + gtid - offset];\n"
	"	}\n"
	"	GroupMemoryBarrierWithGroupSync();\n"
	"	len = temp[pout*THREAD_GROUP_X + gtid];\n"
	"	BufferOut.Store((2*dtid+1)*12, asuint(len));\n"
	"	BufferOut.Store((2*dtid+1)*12 + 4, asuint(V_SCALE));\n"
	"	BufferOut.Store((2*dtid+2)*12, asuint(len));\n"
	"	BufferOut.Store((2*dtid+2)*12 + 4, asuint(V_SCALE));\n"
	"	if (gtid == (THREAD_GROUP_X - 1))\n"
	"		BufferOut.Store(gid*12 + 8, asuint(len));\n"
	"}\n"
; 


char const * const dx11_cs_linepat_sum =
	"#define THREAD_GROUP_X 256\n"
	"RWByteAddressBuffer BufferInOut : register(u0);\n"
	"[numthreads(THREAD_GROUP_X, 1, 1)]\n"
	"void main_sum(\n"
	"	uint3 gid  : SV_GroupID,\n"
	"	uint3 gtid : SV_GroupThreadID,\n"
	"	uint3 dtid : SV_DispatchThreadID)\n"
	"{\n"
	"	float sums = 0.0;\n"
	"	for (uint i = 1; i <= gid.x; i++)\n"
	"		sums += asfloat(BufferInOut.Load((gid.x-i)*12 + 8));\n"
	"	float x = asfloat(BufferInOut.Load((2*dtid.x+1)*12));\n"
	"	float sum = x + sums;\n"
	"	BufferInOut.Store((2*dtid.x+1)*12, asuint(sum));\n"
	"	BufferInOut.Store((2*dtid.x+2)*12, asuint(sum));\n"
	"}\n"
; 


char const * const dx11_depth_blit_pixel =
	"#ifdef MSAA\n"
	"uniform Texture2DMS<float4, 4> DepthTexture : register(t0);\n"
	"#else\n"
	"uniform Texture2D DepthTexture : register(t0);\n"
	"#endif\n"
	"cbuffer Constants : register (b0)\n"
	"{\n"
	"	row_major float4x4 Matrix;\n"
	"	uint Width;\n"
	"	uint Height;\n"
	"};\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : SV_POSITION;\n"
	"	float2 screen_uv : TEXCOORD0;\n"
	"};\n"
	"void main(Iterator input, \n"
	"	out float FinalDepth : SV_Depth)\n"
	"{  \n"
	"#ifdef MSAA			\n"
	"	uint sample_index = 0;\n"
	"	FinalDepth = DepthTexture.Load(int2(input.screen_uv * int2(Width, Height)), sample_index);\n"
	"#else\n"
	"	FinalDepth = DepthTexture.Load(int3(input.screen_uv * int2(Width, Height), 0));\n"
	"#endif\n"
	"}\n"
; 


char const * const dx11_depth_blit_vertex =
	"cbuffer Constants : register (b0)\n"
	"{\n"
	"	row_major float4x4 Matrix;\n"
	"	uint Width;\n"
	"	uint Height;\n"
	"};\n"
	"struct Vertex\n"
	"{\n"
	"	float2 position : SV_POSITION;\n"
	"	float2 texCoord : TEXCOORD0;\n"
	"};\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : SV_POSITION;\n"
	"	float2 screen_uv : TEXCOORD0;\n"
	"};\n"
	"Iterator main( const Vertex vertex )\n"
	"{\n"
	"	Iterator result;\n"
	"	float4 position = mul(float4(vertex.position, 0.0, 1.0), Matrix);\n"
	"	result.position = position;\n"
	"	result.screen_uv = vertex.texCoord;	\n"
	"	return result;\n"
	"} \n"
; 


char const * const dx11_geometry =
	"[maxvertexcount(GS_OUTPUT_MAX_VERTICES)]\n"
	"void main(\n"
	"	in GS_INPUT_PRIMITIVE_TYPE vertex_output points[GS_INPUT_VERTICES_COUNT]\n"
	"	, inout STREAM stream\n"
	"	, in uint PrimitiveIndex : SV_PrimitiveID)\n"
	"{\n"
	"#ifdef GS_ELLIPTICAL_ARC\n"
	"	elliptical_arc(points, stream);\n"
	"#endif\n"
	"#ifdef SPRITE_MARKER\n"
	"	point_splats(points, stream, PrimitiveIndex);\n"
	"#endif\n"
	"#ifdef HAS_DEFINED_MATERIAL_GS\n"
	"	material_geometry_shader(points, stream, PrimitiveIndex);\n"
	"#endif\n"
	"}\n"
; 


char const * const dx11_header =
	"#define reg(a) :register(a)\n"
	"#define DRIVER_SPECIFIC_FLIP 1\n"
	"#define BAD_VARIABLE_INDEX\n"
	"#define DX11\n"
	"#define GLSL_VERSION 0\n"
	"#define semantic(a) : a\n"
	"#define flat nointerpolation\n"
	"#define LOWP\n"
	"#define MEDP\n"
	"#define HIGHP\n"
	"#define HSampler2D int\n"
	"#define HSampler3D int \n"
	"#define HSamplerCUBE int\n"
	"#define TextureCUBE TextureCube\n"
	"#define tex2D(id, uv)					float4(0,0,0,0)\n"
	"#define tex2Dgrad(id, uv, xd, yd)		float4(0,0,0,0)\n"
	"#define texCUBE(id, uv)					float4(0,0,0,0)\n"
	"#define tex3D(id, uv)					float4(0,0,0,0)\n"
	"#define STATIC_ARRAY_BEGIN(name,type,size) static const type name[size] = {\n"
	"#define STATIC_ARRAY_END }\n"
	"#define POSITION		SV_POSITION\n"
	"#define OUT_COLOR1		COLOR1\n"
	"#define OUT_TEXCOORD0	TEXCOORD0	\n"
	"#define OUT_TEXCOORD1	TEXCOORD1	\n"
	"#define OUT_TEXCOORD2	TEXCOORD2	\n"
	"#define OUT_TEXCOORD3	TEXCOORD3	\n"
	"#define OUT_TEXCOORD4	TEXCOORD4	\n"
	"#define OUT_TEXCOORD5	TEXCOORD5	\n"
	"#define OUT_TEXCOORD6	TEXCOORD6	\n"
	"#define OUT_TEXCOORD7	TEXCOORD7	\n"
	"#define OUT_FOG			FOG			\n"
	"#define equal(a, b) ((a) == (b))\n"
	"#define notEqual(a, b) ((a) != (b))\n"
	"#define greaterThan(a, b) ((a) > (b))\n"
	"#define lessThan(a, b) ((a) < (b))\n"
	"#define FINAL_COLOR0	COLOR0\n"
	"#define FINAL_COLOR1	COLOR1\n"
	"#define FINAL_COLOR2	COLOR2\n"
	"#define BEGIN_CBUFFER(a) cbuffer a {\n"
	"#define END_CBUFFER }\n"
	"#define H3D_BRANCH_HINT [branch]\n"
	"#define H3D_LOOP_HINT [loop]\n"
	"#define AppendVertex(stream,v)		stream.Append(v)\n"
	"#define RestartPrimitive(stream)	stream.RestartStrip()\n"
	"#define STREAM						GS_OUTPUT_PRIMITIVE_TYPE<pixel_input>\n"
; 


char const * const dx11_oit_pixel =
	"#define COLOR0			SV_Target\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : SV_Position;\n"
	"};\n"
	"struct OIT_Link\n"
	"{\n"
	"	uint rgba;\n"
	"	uint depth_and_coverage;\n"
	"	uint next;\n"
	"};\n"
	"uniform uint Width : register(c0);\n"
	"StructuredBuffer<OIT_Link> Links : register(t0);\n"
	"Buffer<uint> Heads : register(t1);\n"
	"#define END_INDEX 0xFFFFFFFF\n"
	"void main( Iterator iterator\n"
	"		  , in uint sample_index : SV_SampleIndex\n"
	"		  , out float4 color : COLOR0 \n"
	"		  )\n"
	"{\n"
	"	uint2 xy = iterator.position.xy;\n"
	"	uint pixel_index = xy.x + Width * xy.y;\n"
	"	uint head = Heads[pixel_index];\n"
	"	if (head == END_INDEX)\n"
	"	{\n"
	"		color = 0;\n"
	"		return;\n"
	"	}\n"
	"#define MAX_LAYERS 16\n"
	"	uint layer_depth[MAX_LAYERS];\n"
	"	uint layer_color[MAX_LAYERS];\n"
	"	uint layer_count = 0;\n"
	"	uint sample_bit = 1 << sample_index;\n"
	"	while (head != END_INDEX)\n"
	"	{\n"
	"		OIT_Link link = Links[head];		\n"
	"		uint coverage = link.depth_and_coverage;// & 0x000000FF;\n"
	"		float d = link.depth_and_coverage >> 8;\n"
	"		if ((coverage & sample_bit) != 0)\n"
	"		{\n"
	"			layer_depth[layer_count] = d;\n"
	"			layer_color[layer_count] = link.rgba;\n"
	"			++layer_count;\n"
	"		}\n"
	"		[flatten]head = (layer_count >= MAX_LAYERS) ? END_INDEX : link.next;\n"
	"	}\n"
	"	for (uint i = 1; i < layer_count; ++i)\n"
	"	{\n"
	"		uint d = layer_depth[i];\n"
	"		uint c = layer_color[i];\n"
	"		int j = i;\n"
	"		while (j > 0 && layer_depth[j-1] > d)\n"
	"		{\n"
	"			layer_depth[j] = layer_depth[j-1];\n"
	"			layer_color[j] = layer_color[j-1];\n"
	"			j--;\n"
	"		}\n"
	"		layer_depth[j] = d;\n"
	"		layer_color[j] = c;\n"
	"	}\n"
	"	color = 0;\n"
	"	for ( int i = layer_count-1; i >= 0; --i )\n"
	"	{\n"
	"		uint rgba = layer_color[i];\n"
	"		float4 c = float4((rgba & 0xff000000u) >> 24, (rgba & 0x00ff0000u) >> 16, (rgba & 0x0000ff00u) >> 8, (rgba & 0x000000ffu) >> 0) / 255;\n"
	"		color *= (1-c.a);\n"
	"		c.rgb *= c.a;\n"
	"		color += c;\n"
	"	}\n"
	"} \n"
; 


char const * const dx11_oit_vertex =
	"struct Vertex\n"
	"{\n"
	"	float3 position : POSITION;\n"
	"};\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : SV_Position;\n"
	"};\n"
	"static const float ConstantDepth = 0.0;\n"
	"Iterator main( const Vertex vertex )\n"
	"{\n"
	"	Iterator result;\n"
	"	float4 position = float4(vertex.position.xy,ConstantDepth,1);\n"
	"	result.position = position;\n"
	"	return result;\n"
	"} \n"
; 


char const * const dx11_pixel =
	"#define COLOR0			SV_Target\n"
	"#define COLOR1			SV_Target1\n"
	"#define COLOR2			SV_Target2\n"
	"uniform int AlphaTest;\n"
	"#ifdef SELECTION_BITMAP\n"
	"#define Mask 1023\n"
	"#define Shift 10\n"
	"uint table(uint index)\n"
	"{\n"
	"	uint2 coords = uint2(index & Mask, index >> Shift); \n"
	"	return SelectionTableTextureObject0[coords];\n"
	"}\n"
	"void decode(uint hi, uint lo, out uint word, out uint bit)\n"
	"{\n"
	"	uint geom_shift		= table(hi * 6 + 0);	\n"
	"	uint geom_mask		= table(hi * 6 + 1);	\n"
	"	uint subgeom_shift	= table(hi * 6 + 2);	\n"
	"	uint subgeom_mask	= table(hi * 6 + 3);	\n"
	"	uint face_mask		= table(hi * 6 + 4);	\n"
	"	uint index			= table(hi * 6 + 5);	// Where in the texture to find the geometry table for this path\n"
	"	uint geom = geom_mask & (lo >> geom_shift);\n"
	"	uint subgeom = subgeom_mask & (lo >> subgeom_shift);\n"
	"	uint face = face_mask & lo;\n"
	"	index += geom * (1+subgeom_mask);\n"
	"	index += subgeom;\n"
	"	uint start = table(index);\n"
	"	face = face + start;\n"
	"	bit = 1 << (face & 31);						// Convert index to word/bit-within-word address\n"
	"	word = face >> 5;\n"
	"}\n"
	"bool hi_is_selected(uint hi, uint lo) \n"
	"{\n"
	"	uint word, bit;\n"
	"	decode(hi, lo, word, bit);\n"
	"	uint2 coords = uint2(word&Mask, word>>Shift);\n"
	"	uint bits = SelectionBitmapTextureObject0[coords];\n"
	"	return 0 != (bits & bit);\n"
	"}\n"
	"#endif // SELECTION_BITMAP\n"
	"#ifdef OIT\n"
	"struct OIT_Link\n"
	"{\n"
	"	uint rgba;	\n"
	"	uint depth_and_coverage;\n"
	"	uint next;\n"
	"};\n"
	"uniform uint Width;\n"
	"uniform uint MaxFragments;\n"
	"RWStructuredBuffer<OIT_Link> Links : register(u0);\n"
	"RWByteAddressBuffer Heads : register(u1);\n"
	"[earlydepthstencil]\n"
	"#endif // OIT\n"
	"void main (\n"
	"	pixel_input input\n"
	"#ifdef OIT\n"
	"	, in float4 Pos	: SV_Position\n"
	"	, in uint Coverage : SV_Coverage\n"
	"#else\n"
	"	, out float4 FinalColor : COLOR0\n"
	"	#if defined(DEPTH_WRITING) && defined(DEPTH_WRITING_SINGLE_PASS)\n"
	"		, out float4 FinalDepth : FINAL_DEPTH\n"
	"	#endif // DEPTH_WRITING_SINGLE_PASS && DEPTH_WRITING \n"
	"#endif // ndef OIT\n"
	"#if (SHADER_MODEL >= 4) && !defined(HAS_GEOMETRY_SHADER)\n"
	"	, in uint PrimitiveIndex : SV_PrimitiveID\n"
	"#endif\n"
	"#if (SHADER_MODEL >= 3)\n"
	"	, in bool Face : SV_IsFrontFace\n"
	"#endif // SHADER_MODEL >= 3\n"
	"#ifdef CREATE_SELECTION_MAP\n"
	"	, out float4 FinalColor1 : COLOR1\n"
	"#endif\n"
	"#ifdef WRITING_SSAA_LINE_TARGET\n"
	"	, out float4 FinalLineColor : FINAL_LINE_COLOR\n"
	"#endif\n"
	")\n"
	"{  \n"
	"	float4 color;\n"
	"#ifdef HAS_GEOMETRY_SHADER\n"
	"	uint PrimitiveIndex = input.PrimitiveIndex;\n"
	"#endif\n"
	"#if (SHADER_MODEL >= 3)\n"
	"	float face = (Face) ? 1.0 : -1.0;\n"
	"#endif\n"
	"pixel_common(input\n"
	"		, color\n"
	"#if (SHADER_MODEL >= 3)\n"
	"		, face\n"
	"#endif // SHADER_MODEL >= 3\n"
	"#if (SHADER_MODEL >= 4)\n"
	"		, PrimitiveIndex\n"
	"#endif\n"
	"#if defined(DEPTH_WRITING) && defined(DEPTH_WRITING_SINGLE_PASS)\n"
	"		, FinalDepth\n"
	"#endif // DEPTH_WRITING_SINGLE_PASS && DEPTH_WRITING \n"
	"#ifdef SELECTION_HAS_LO\n"
	"		, FinalColor1\n"
	"#endif\n"
	"#ifdef WRITING_SSAA_LINE_TARGET\n"
	"		, FinalLineColor\n"
	"#endif\n"
	"	);\n"
	"	if (AlphaTest) {\n"
	"		clip(color.a < 1.0 / 255.0 ? -1 : 1);\n"
	"	}\n"
	"#ifdef OIT\n"
	"#ifndef SKIP_OIT_COLLECTION\n"
	"	uint4 rgba = round(255.0 * saturate(color));\n"
	"	OIT_Link link;\n"
	"	link.rgba = (rgba.x << 24) | (rgba.y << 16) | (rgba.z << 8) | rgba.w;\n"
	"	link.depth_and_coverage = ((uint)(Pos.z * (0x00FFFFFF - 1)) << 8) | Coverage;\n"
	"	uint head = Links.IncrementCounter();\n"
	"	uint pixel_address = 4 * (uint(Pos.x) + uint(Pos.y) * Width);\n"
	"	Heads.InterlockedExchange(pixel_address, head, link.next);\n"
	"	Links[head] = link;\n"
	"#endif\n"
	"#else\n"
	"	FinalColor = color;\n"
	"#endif\n"
	"}\n"
; 


char const * const dx11_post_header =
	"#define htex2d(id, uv) id##Texture.Sample(id, uv)\n"
	"#define htex2dlod(id, uv) id##Texture.SampleLevel(id, uv.xy, uv.w)\n"
	"#define sampler2D SamplerState\n"
	"#ifdef DEPTH_PACKING_RGBA\n"
	"float unpack_rgba(const float4 value)\n"
	"{\n"
	"#define RADIX 255.0\n"
	"	const float4 shift = float4(1.0, 1.0/RADIX, 1.0/(RADIX*RADIX),  1.0/(RADIX*RADIX*RADIX)); \n"
	"#ifdef FULL_ENCODE\n"
	"	float mantissa = dot(value.xyz, shift.xyz);\n"
	"	float exponent = value.w * RADIX - 128;\n"
	"	return ldexp(mantissa, exponent);\n"
	"#else\n"
	"	return dot(value, shift);\n"
	"#endif\n"
	"#undef RADIX\n"
	"}\n"
	"#else\n"
	"#define unpack_rgba(x) x.r\n"
	"#endif\n"
; 


char const * const dx11_post_pixel =
	"#define COLOR0			SV_Target\n"
	"#define DEPTH			SV_Depth\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : POSITION;\n"
	"	float2 uv : TEXCOORD0;\n"
	"#ifdef TEXCOORD_INPUT_2\n"
	"	float2 world_uv : TEXCOORD1;\n"
	"#endif // REFLECTION_BUMPMAP\n"
	"};\n"
	"void main( Iterator iterator\n"
	"		  , out float4 color : COLOR0 \n"
	"#ifdef DEPTH_OUTPUT\n"
	"		  , out float depth : DEPTH \n"
	"#endif\n"
	"		  )\n"
	"{\n"
	"	post_pixel(\n"
	"		iterator.uv\n"
	"#ifdef TEXCOORD_INPUT_2\n"
	"		,iterator.world_uv\n"
	"#endif\n"
	"		,color\n"
	"#ifdef DEPTH_OUTPUT\n"
	"		,depth\n"
	"#endif\n"
	"	);\n"
	"} \n"
; 


char const * const dx11_post_vertex =
	"struct Vertex\n"
	"{\n"
	"	float3 position : POSITION;\n"
	"};\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : POSITION;\n"
	"	float4 screen_uv : TEXCOORD0;\n"
	"};\n"
	"float ConstantDepth;\n"
	"float2 TexelOffset;\n"
	"Iterator main( const Vertex vertex )\n"
	"{\n"
	"	Iterator result;\n"
	"	float4 position = float4(vertex.position.xy,ConstantDepth,1);\n"
	"	result.position = position;\n"
	"	result.screen_uv = position * 0.5 + 0.5;\n"
	"	result.screen_uv.xy += TexelOffset;\n"
	"	result.screen_uv.y = 1 - result.screen_uv.y;\n"
	"	return result;\n"
	"} \n"
; 


char const * const dx11_post_vertex_3d =
	"struct Vertex\n"
	"{\n"
	"	float3 position : POSITION;\n"
	"};\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : POSITION;\n"
	"	float2 uv : TEXCOORD0;\n"
	"	float4 vpos : TEXCOORD1;\n"
	"};\n"
	"float ConstantDepth;\n"
	"float4x4 ModelToProjection;\n"
	"Iterator main( const Vertex vertex )\n"
	"{\n"
	"	Iterator result;\n"
	"	float4 position = mul(float4(vertex.position.xy,0,1), ModelToProjection);\n"
	"	result.position = float4(position.xy, ConstantDepth * position.w, position.w);\n"
	"	result.uv = vertex.position.xy * 0.5 + 0.5;\n"
	"	result.uv.y = 1 - result.uv.y;\n"
	"	result.vpos = position;\n"
	"	return result;\n"
	"} \n"
; 


char const * const dx11_selection_bitmap_compute =
	"Texture2D<uint> Table : register(t0);\n"
	"Texture2D<float4> HiTexels : register(t1);\n"
	"Texture2D<float4> LoTexels : register(t2);\n"
	"cbuffer Constants : register(c0)\n"
	"{\n"
	"	uint2 TopLeft;\n"
	"	uint2 Size;\n"
	"	uint Mask;\n"
	"	uint Shift;\n"
	"	uint Types;\n"
	"};\n"
	"RWTexture2D<uint> Bitmap : register(u0);\n"
	"uint unpack( float4 a )\n"
	"{\n"
	"	uint4 u = 255 * a;\n"
	"	return (u.x<<24) + (u.y<<16) + (u.z<<8) + u.w;\n"
	"}\n"
	"uint table(uint index)\n"
	"{\n"
	"	uint2 coords = uint2(index & Mask, index >> Shift); \n"
	"	return Table[coords];\n"
	"}\n"
	"void decode(uint hi, uint lo, out uint word, out uint bit)\n"
	"{\n"
	"	uint geom_shift		= table(hi * 6 + 0);	\n"
	"	uint geom_mask		= table(hi * 6 + 1);	\n"
	"	uint subgeom_shift	= table(hi * 6 + 2);	\n"
	"	uint subgeom_mask	= table(hi * 6 + 3);	\n"
	"	uint prim_mask		= table(hi * 6 + 4);	\n"
	"	uint index			= table(hi * 6 + 5);	// Where in the texture to find the geometry table for this path\n"
	"	uint geom = geom_mask & (lo >> geom_shift);\n"
	"	uint subgeom = subgeom_mask & (lo >> subgeom_shift);\n"
	"	uint prim = prim_mask & lo;\n"
	"	index += geom * (1+subgeom_mask);\n"
	"	index += subgeom;\n"
	"	uint start = table(index);\n"
	"	prim += start;\n"
	"	bit = 1 << (prim & 31);				// Convert index to word/bit-within-word address\n"
	"	word = prim >> 5;\n"
	"}\n"
	"void make_selection(uint2 coords, bool add)\n"
	"{\n"
	"	bool valid = !any(coords >= Size);\n"
	"	coords += TopLeft;\n"
	"	uint hi = unpack( HiTexels[coords] );\n"
	"	uint lo = unpack( LoTexels[coords] );\n"
	"	uint word, bit;\n"
	"	decode(hi, lo, word, bit);\n"
	"	uint type = lo >> 30;\n"
	"	valid = valid && ((Types & (1<<type)) != 0);\n"
	"	valid = valid && (hi != 0);\n"
	"	bit *= valid;\n"
	"	coords = uint2(word & Mask, word >> Shift);\n"
	"	[flatten]\n"
	"	if ( add )\n"
	"		InterlockedOr( Bitmap[coords], bit);\n"
	"	else\n"
	"		InterlockedAnd( Bitmap[coords], ~bit);\n"
	"}\n"
	"[numthreads(16, 8, 1)]\n"
	"void main_add(uint3 Thread : SV_DispatchThreadID)\n"
	"{\n"
	"	make_selection(Thread.xy, true);\n"
	"}\n"
	"[numthreads(16, 8, 1)]\n"
	"void main_remove(uint3 Thread : SV_DispatchThreadID)\n"
	"{\n"
	"	make_selection(Thread.xy, false);\n"
	"}\n"
	"void direct_selection(bool add)\n"
	"{\n"
	"	uint word, bit;\n"
	"	decode(TopLeft.x, TopLeft.y, word, bit);\n"
	"	uint2 coords = uint2(word & Mask, word >> Shift);\n"
	"	[flatten]\n"
	"	if ( add )\n"
	"		InterlockedOr( Bitmap[coords], bit);\n"
	"	else\n"
	"		InterlockedAnd( Bitmap[coords], ~bit);\n"
	"}\n"
	"[numthreads(1, 1, 1)]\n"
	"void main_direct_add(uint3 Thread : SV_DispatchThreadID)\n"
	"{\n"
	"	direct_selection(true);\n"
	"}\n"
	"[numthreads(1, 1, 1)]\n"
	"void main_direct_remove(uint3 Thread : SV_DispatchThreadID)\n"
	"{\n"
	"	direct_selection(false);\n"
	"}\n"
; 


char const * const dx11_vertex =
	"#ifdef SPRITE_MARKER\n"
	"#ifndef HAS_GEOMETRY_SHADER\n"
	"#define USE_VS_INSTANCING 1\n"
	"#endif\n"
	"#endif\n"
	"#ifdef USE_VS_INSTANCING\n"
	"StructuredBuffer<float3> Positions  : register(t0);\n"
	"#ifdef HAS_VERTEX_NORMALS\n"
	"StructuredBuffer<float3> Normals  : register(t1);\n"
	"#endif\n"
	"#ifdef HAS_VERTEX_COLORS\n"
	"StructuredBuffer<int> Colors  : register(t2);\n"
	"#endif\n"
	"#endif // USE_VS_INSTANCING\n"
	"vertex_output main(const vertex_input vertex \n"
	"#ifdef USE_VS_INSTANCING\n"
	"	,uint vertex_id : SV_VertexID\n"
	"#endif\n"
	"	)\n"
	"{\n"
	"#ifdef USE_VS_INSTANCING\n"
	"	vertex_input copy = vertex;\n"
	"	uint marker_index = vertex_id / 4;\n"
	"	copy.position = Positions[marker_index];\n"
	"#ifdef HAS_VERTEX_NORMALS\n"
	"	copy.normal = Normals[marker_index];\n"
	"#endif\n"
	"#ifdef HAS_VERTEX_COLORS\n"
	"	int rgba = Colors[marker_index];\n"
	"	float4 color = float4((rgba & 0xff000000u) >> 24, (rgba & 0x00ff0000u) >> 16, (rgba & 0x0000ff00u) >> 8, (rgba & 0x000000ffu) >> 0) / 255;\n"
	"	copy.color = color.abgr;\n"
	"#endif\n"
	"	vertex_output vresult = vertex_common(copy);	\n"
	"	float2 RealMarkerSize = MarkerSize;\n"
	"#ifndef WORLD_SPACE_MARKER\n"
	"	RealMarkerSize *= vresult.position.w;\n"
	"#endif\n"
	"	uint index_in_quad = vertex_id % 4;\n"
	"#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"	vresult.marker_uv.x = index_in_quad % 2 ? 0.0 : 1.0;\n"
	"	vresult.marker_uv.y = index_in_quad & 2 ? 1.0 : 0.0;\n"
	"#endif\n"
	"	float2 offset;\n"
	"	offset.x = index_in_quad % 2 ? -1.0 : 1.0;\n"
	"	offset.y = index_in_quad & 2 ? -1.0 : 1.0;\n"
	"	vresult.position.xy += offset * RealMarkerSize;\n"
	"#else // USE_VS_INSTANCING\n"
	"	vertex_output vresult = vertex_common(vertex);\n"
	"#endif\n"
	"	return vresult;\n"
	"} \n"
; 


char const * const dx9_header =
	"#define reg(a) : register(a)\n"
	"#define DRIVER_SPECIFIC_FLIP 1\n"
	"#define BAD_VARIABLE_INDEX\n"
	"#define DX9\n"
	"#define GLSL_VERSION 0\n"
	"#define BRANCH [branch]\n"
	"#define semantic(a) : a\n"
	"#define flat\n"
	"#define LOWP\n"
	"#define MEDP\n"
	"#define HIGHP\n"
	"#define HSampler2D sampler\n"
	"#define HSampler3D sampler\n"
	"#define HSamplerCUBE sampler\n"
	"#define STATIC_ARRAY_BEGIN(name,type,size) static const type name[size] = {\n"
	"#define STATIC_ARRAY_END }\n"
	"#define OUT_COLOR1		COLOR1\n"
	"#define OUT_COLOR2		COLOR2 // requires SM3\n"
	"#define OUT_TEXCOORD0	TEXCOORD0	\n"
	"#define OUT_TEXCOORD1	TEXCOORD1	\n"
	"#define OUT_TEXCOORD2	TEXCOORD2	\n"
	"#define OUT_TEXCOORD3	TEXCOORD3	\n"
	"#define OUT_TEXCOORD4	TEXCOORD4	\n"
	"#define OUT_TEXCOORD5	TEXCOORD5	\n"
	"#define OUT_TEXCOORD6	TEXCOORD6	\n"
	"#define OUT_TEXCOORD7	TEXCOORD7	\n"
	"#define OUT_FOG			FOG			\n"
	"#define equal(a, b) ((a) == (b))\n"
	"#define notEqual(a, b) ((a) != (b))\n"
	"#define greaterThan(a, b) ((a) > (b))\n"
	"#define lessThan(a, b) ((a) < (b))\n"
	"#define FINAL_COLOR0	COLOR0\n"
	"#define FINAL_COLOR1	COLOR1\n"
	"#define FINAL_COLOR2	COLOR2\n"
	"#define BEGIN_CBUFFER(a)\n"
	"#define END_CBUFFER\n"
	"#define H3D_BRANCH_HINT [branch]\n"
	"#define H3D_LOOP_HINT [loop]\n"
; 


char const * const dx9_pixel =
	"#ifdef SELECTION_BITMAP\n"
	"bool hi_is_selected(float4 selection_key)\n"
	"{\n"
	"	float index = selection_key.g*65536*255 + selection_key.b*256*255 + selection_key.a*255;\n"
	"	float4 selection = tex2D(SelectionBitmapSampler0, float2((index + 0.5)/ BitfieldSize, 0.0));\n"
	"	return selection.r != 0;\n"
	"}\n"
	"#endif\n"
	"void main (\n"
	"	pixel_input input\n"
	"	, out float4 FinalColor : COLOR0\n"
	"#if (SHADER_MODEL >= 3)\n"
	"	, in float Face : VFACE\n"
	"#endif // SHADER_MODEL >= 3\n"
	"#if defined(DEPTH_WRITING) && defined(DEPTH_WRITING_SINGLE_PASS)\n"
	"	, out float4 FinalDepth : FINAL_DEPTH\n"
	"#endif // DEPTH_WRITING_SINGLE_PASS && DEPTH_WRITING \n"
	"#ifdef SELECTION_HAS_LO\n"
	"	, out float4 FinalColor1 : COLOR1\n"
	"#endif\n"
	"#ifdef WRITING_SSAA_LINE_TARGET\n"
	"	, out float4 FinalLineColor : FINAL_LINE_COLOR\n"
	"#endif\n"
	")\n"
	"{  \n"
	"	pixel_common(input\n"
	"		, FinalColor\n"
	"#if (SHADER_MODEL >= 3)\n"
	"		, Face\n"
	"#endif // SHADER_MODEL >= 3\n"
	"#if defined(DEPTH_WRITING) && defined(DEPTH_WRITING_SINGLE_PASS)\n"
	"		, FinalDepth\n"
	"#endif // DEPTH_WRITING_SINGLE_PASS && DEPTH_WRITING \n"
	"#ifdef SELECTION_HAS_LO\n"
	"		, FinalColor1\n"
	"#endif\n"
	"#ifdef WRITING_SSAA_LINE_TARGET\n"
	"		, FinalLineColor\n"
	"#endif\n"
	"	);\n"
	"}\n"
; 


char const * const dx9_post_header =
	"#define Texture2D float\n"
	"#define htex2d(id, uv) tex2D(id, uv)\n"
	"#define htex2dlod(id, uv) tex2Dlod(id, uv)\n"
	"#ifdef DEPTH_PACKING_RGBA\n"
	"float unpack_rgba(const float4 value)\n"
	"{\n"
	"#define RADIX 255.0\n"
	"	const float4 shift = float4(1.0, 1.0/RADIX, 1.0/(RADIX*RADIX),  1.0/(RADIX*RADIX*RADIX)); \n"
	"#ifdef FULL_ENCODE\n"
	"	float mantissa = dot(value.xyz, shift.xyz);\n"
	"	float exponent = value.w * RADIX - 128;\n"
	"	return ldexp(mantissa, exponent);\n"
	"#else\n"
	"	return dot(value, shift);\n"
	"#endif\n"
	"#undef RADIX\n"
	"}\n"
	"#else\n"
	"#define unpack_rgba(x) x.r\n"
	"#endif\n"
; 


char const * const dx9_post_pixel =
	"struct Iterator\n"
	"{\n"
	"	float4 position : POSITION;\n"
	"	float4 uv : TEXCOORD0;\n"
	"#ifdef TEXCOORD_INPUT_2\n"
	"	float2 world_uv : TEXCOORD1;\n"
	"#endif // REFLECTION_BUMPMAP\n"
	"};\n"
	"void main( Iterator iterator\n"
	"		  , out float4 color : COLOR0 \n"
	"#ifdef DEPTH_OUTPUT\n"
	"		  , out float depth : DEPTH \n"
	"#endif\n"
	"		  )\n"
	"{\n"
	"	post_pixel(\n"
	"		iterator.uv.xy\n"
	"#ifdef TEXCOORD_INPUT_2\n"
	"		,iterator.world_uv\n"
	"#endif\n"
	"		,color\n"
	"#ifdef DEPTH_OUTPUT\n"
	"		,depth\n"
	"#endif\n"
	"	);\n"
	"} \n"
; 


char const * const dx9_post_vertex =
	"struct Vertex\n"
	"{\n"
	"	float3 position : POSITION;\n"
	"};\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : POSITION;\n"
	"	float4 screen_uv : TEXCOORD0;\n"
	"};\n"
	"float ConstantDepth;\n"
	"float2 TexelOffset;\n"
	"Iterator main( const Vertex vertex )\n"
	"{\n"
	"	Iterator result;\n"
	"	float4 position = float4(vertex.position.xy,ConstantDepth,1);\n"
	"	result.position = position;\n"
	"	result.screen_uv = position * 0.5 + 0.5;\n"
	"	result.screen_uv.xy += TexelOffset;\n"
	"	result.screen_uv.y = 1 - result.screen_uv.y;\n"
	"	return result;\n"
	"} \n"
; 


char const * const dx9_post_vertex_3d =
	"struct Vertex\n"
	"{\n"
	"	float3 position : POSITION;\n"
	"};\n"
	"struct Iterator\n"
	"{\n"
	"	float4 position : POSITION;\n"
	"	float2 uv : TEXCOORD0;\n"
	"	float4 vpos : TEXCOORD1;\n"
	"};\n"
	"float ConstantDepth;\n"
	"float4x4 ModelToProjection;\n"
	"Iterator main( const Vertex vertex )\n"
	"{\n"
	"	Iterator result;\n"
	"	float4 position = mul(float4(vertex.position.xy,0,1), ModelToProjection);\n"
	"	result.position = float4(position.xy, ConstantDepth * position.w, position.w);\n"
	"	result.uv = vertex.position.xy * 0.5 + 0.5;\n"
	"	result.uv.y = 1 - result.uv.y;\n"
	"	result.vpos = position;\n"
	"	return result;\n"
	"} \n"
; 


char const * const dx9_vertex =
	"vertex_output main( const vertex_input vertex )\n"
	"{\n"
	"	vertex_output vresult = vertex_common(vertex);\n"
	"	return vresult;\n"
	"} \n"
; 


char const * const h3d_common =
	"#define H3D_ROUND	1.0\n"
	"#define H3D_SQUARE	2.0\n"
	"#define H3D_MITER	3.0\n"
	"#define WIDE_LINE_SCALE 1.0\n"
	"#define WIDE_LINE_SAMPLER_SCALE 1.15\n"
	"#if !defined(OPENGL2)  && defined(FLAT_SHADING)\n"
	"	#define FLAT flat\n"
	"#else\n"
	"	#define FLAT\n"
	"#endif\n"
	"#define COND(a,b) a < b ? a : 0\n"
	"#ifdef OPENGL2\n"
	"#define rgb_to_gray(rgb) (rgb.r*0.3125 + rgb.g*0.5 + rgb.b*0.1875)\n"
	"#else\n"
	"float rgb_to_gray( float3 rgb )\n"
	"{\n"
	"	return dot( rgb, float3(0.3125, 0.5, 0.1875) );\n"
	"}\n"
	"#endif\n"
	"float4 pack_rgba(float value)\n"
	"{\n"
	"#define RADIX 255.0\n"
	"	const float4 shift = float4(1.0, RADIX, RADIX*RADIX,  RADIX*RADIX*RADIX); \n"
	"	const float4 mask = float4(1.0/RADIX, 1.0/RADIX, 1.0/RADIX, 0.0);\n"
	"	if ( value == 1.0 )\n"
	"		return float4(1.0, 0.0, 0.0, 0.0);\n"
	"	float4 rgba;\n"
	"#ifdef FULL_ENCODE\n"
	"	float exponent;\n"
	"	float mantissa = frexp(value, exponent);\n"
	"	rgba.w = (exponent + 128) / RADIX;\n"
	"	rgba.xyz = frac(mantissa * shift.xyz);\n"
	"	rgba.xy -= mask.x * rgba.yz;\n"
	"#else\n"
	"	rgba = frac(value * shift);\n"
	"	rgba.xyz -= mask.x * rgba.yzw;\n"
	"#endif\n"
	"	return rgba;\n"
	"}\n"
	"float unpack_rgba(const float4 value)\n"
	"{\n"
	"	const float4 shift = float4(1.0, 1.0/RADIX, 1.0/(RADIX*RADIX),  1.0/(RADIX*RADIX*RADIX)); \n"
	"#ifdef FULL_ENCODE\n"
	"	float mantissa = dot(value.xyz, shift.xyz);\n"
	"	float exponent = value.w * RADIX - 128;\n"
	"	return ldexp(mantissa, exponent);\n"
	"#else\n"
	"	return dot(value, shift);\n"
	"#endif\n"
	"#undef RADIX\n"
	"}\n"
	"struct reflection_plane_t\n"
	"{\n"
	"	MEDP float4 plane;\n"
	"	MEDP float scale; // Convert depth to attenuation\n"
	"	MEDP float bias;\n"
	"};\n"
	"#ifdef LIGHTING\n"
	"#ifndef H3D_LIGHTING_MODEL\n"
	"	#ifdef GOOCH\n"
	"		#define BLACK_SHADOWS\n"
	"		#define H3D_LIGHTING_MODEL H3D_LIGHTING_MODEL_NAME(gooch)\n"
	"	#else\n"
	"		#define H3D_LIGHTING_MODEL H3D_LIGHTING_MODEL_NAME(blinn_phong)\n"
	"	#endif\n"
	"#endif\n"
	"struct distant_light_t\n"
	"{\n"
	"	MEDP float3 direction;\n"
	"	MEDP float4 diffuse;\n"
	"	MEDP float3 specular;\n"
	"	MEDP float3 halfway;\n"
	"};\n"
	"struct point_light_t\n"
	"{\n"
	"	MEDP float3 position;\n"
	"	MEDP float4 diffuse;\n"
	"	MEDP float3 specular;\n"
	"};\n"
	"struct spot_light_t\n"
	"{\n"
	"	MEDP float3 position;\n"
	"	MEDP float3 direction;\n"
	"	MEDP float2 angles;\n"
	"	MEDP float4 diffuse;\n"
	"	MEDP float3 specular;\n"
	"};\n"
	"uniform distant_light_t DistantLights[DISTANT_LIGHT_COUNT+1];\n"
	"uniform point_light_t PointLights[POINT_LIGHT_COUNT+1];\n"
	"uniform spot_light_t SpotLights[SPOT_LIGHT_COUNT+1];\n"
	"uniform MEDP float3 EyeCameraPosition;\n"
	"H3D_DECLARE_LIGHTING_MODEL(phong)\n"
	"{\n"
	"	float3 R = reflect(-L, N);\n"
	"	float NdotL = dot(N, L);\n"
	"	float VdotR = dot(V, R);\n"
	"	out_diffuse = diffuse.rgb * saturate(NdotL);\n"
	"	out_specular = specular * pow(saturate(VdotR), color.specular.a);\n"
	"}\n"
	"H3D_DECLARE_LIGHTING_MODEL(blinn_phong)\n"
	"{\n"
	"	float NdotL = dot(N, L);\n"
	"	float NdotH = dot(N, H);\n"
	"	out_diffuse = diffuse.rgb * saturate(NdotL);\n"
	"	out_specular = specular * pow(saturate(NdotH), color.specular.a);\n"
	"}\n"
	"H3D_DECLARE_LIGHTING_MODEL(blinn_phong_fresnel)\n"
	"{\n"
	"	H3D_LIGHTING_MODEL_NAME(blinn_phong)(N, T, B, V, H, L, diffuse, specular, color, out_diffuse, out_specular);\n"
	"	out_specular *= h3d_schlick_fresnel_rgb(color.specular.rgb, dot(N, V), 4.0);\n"
	"}\n"
	"H3D_DECLARE_LIGHTING_MODEL(gooch)\n"
	"{\n"
	"	float NdotL = dot(N, L);\n"
	"	float NdotH = dot(N, H);\n"
	"	float d = NdotL * diffuse.a;\n"
	"	out_diffuse = float3(d, d, d);\n"
	"	out_specular = specular * pow(saturate(NdotH), color.specular.a);\n"
	"}\n"
	"H3D_DECLARE_LIGHTING_MODEL(cook_torrance)\n"
	"{\n"
	"	float NdotV = dot(N, V);\n"
	"	float NdotL = dot(N, L);\n"
	"	float NdotH = dot(N, H);\n"
	"	float VdotH = dot(V, H);\n"
	"	float t = 2.0*NdotH/VdotH;\n"
	"	float G = min(1.0, max(0.0, min(t*NdotV, t*NdotL)));\n"
	"	float Ro = color.specular.a;\n"
	"	float Ro2 = saturate(0.001 + 0.999 * Ro*Ro);\n"
	"	float NdotH2 = NdotH*NdotH;\n"
	"	float NdotH2_Ro2 = NdotH2 * Ro2;\n"
	"	float R = exp( (NdotH2-1.0) / (NdotH2_Ro2) ) / (4.0*NdotH2_Ro2*NdotH2);\n"
	"	float3 F = h3d_schlick_fresnel_rgb(color.specular.rgb, NdotV, 4.0);\n"
	"	float3 Rs = R * F * G / (NdotV * NdotL);\n"
	"	out_diffuse = saturate(NdotL) * diffuse.rgb;\n"
	"	out_specular = saturate(NdotL) * Rs * specular;\n"
	"}\n"
	"H3D_DECLARE_LIGHTING_MODEL(heidrich_seidel)\n"
	"{\n"
	"	float NdotL = dot(N, L);\n"
	"	float NdotH = dot(N, H);\n"
	"	float VdotT = dot(V, T);\n"
	"	float LdotT = dot(L, T);\n"
	"	float sinVT = sqrt(1.0 - VdotT*VdotT);\n"
	"	float sinLT = sqrt(1.0 - LdotT*LdotT);;\n"
	"	out_diffuse = diffuse.rgb * saturate(NdotL);\n"
	"	float var = sinVT*sinLT - VdotT*LdotT;\n"
	"	if (var > 0.0)\n"
	"		out_specular = specular * pow(var, color.specular.a);\n"
	"	else\n"
	"		out_specular = float3(0.0, 0.0, 0.0);\n"
	"}\n"
	"void distant_light(HSurface surface, HColor color, distant_light_t light, float3 eye_vector, out float3 out_diffuse, out float3 out_specular)\n"
	"{\n"
	"	H3D_LIGHTING_MODEL(surface.normal, surface.tangent, surface.bitangent, eye_vector, light.halfway, light.direction, light.diffuse, light.specular.rgb, color, out_diffuse, out_specular);\n"
	"}\n"
	"void point_light(HSurface surface, HColor color, point_light_t light, float3 eye_vector, out float3 out_diffuse, out float3 out_specular)\n"
	"{\n"
	"	float3 light_vector = normalize(light.position - surface.position);\n"
	"	float3 halfway = normalize(light_vector + eye_vector);\n"
	"	H3D_LIGHTING_MODEL(surface.normal, surface.tangent, surface.bitangent, eye_vector, halfway, light_vector, light.diffuse, light.specular.rgb, color, out_diffuse, out_specular);\n"
	"}\n"
	"void spot_light(HSurface surface, HColor color, spot_light_t light, float3 eye_vector, out float3 out_diffuse, out float3 out_specular)\n"
	"{\n"
	"	float3 light_vector = normalize(light.position - surface.position);\n"
	"	float3 halfway = normalize(light_vector + eye_vector);\n"
	"	H3D_LIGHTING_MODEL(surface.normal, surface.tangent, surface.bitangent, eye_vector, halfway, light_vector, light.diffuse, light.specular.rgb, color, out_diffuse, out_specular);\n"
	"	float cone_dot = saturate( dot(light_vector, -light.direction) );\n"
	"	float cone_attenuation = saturate( cone_dot * light.angles.x + light.angles.y );\n"
	"	out_diffuse *= cone_attenuation;\n"
	"	out_specular *= cone_attenuation;\n"
	" }\n"
	"void direct_lighting( const HColor color,\n"
	"					  const HSurface surface,\n"
	"					  inout HLighting lighting )\n"
	"{\n"
	"	float3 d, s;\n"
	"	float3 eye_vector = normalize(float3(EyeCameraPosition)-surface.position);\n"
	"#if (DISTANT_LIGHT_COUNT > 0)\n"
	"	for (int i = 0; i < DISTANT_LIGHT_COUNT; i++)\n"
	"	{\n"
	"		distant_light_t dl;\n"
	"		dl.direction = DistantLights[i].direction;\n"
	"		dl.diffuse = DistantLights[i].diffuse;\n"
	"		dl.specular = DistantLights[i].specular;\n"
	"		dl.halfway = DistantLights[i].halfway;\n"
	"		distant_light(surface, color, dl, eye_vector, d, s);\n"
	"		lighting.diffuse += d; \n"
	"		lighting.specular += s;\n"
	"	}\n"
	"#endif\n"
	"#if (POINT_LIGHT_COUNT > 0)\n"
	"	for( int i = 0; i < POINT_LIGHT_COUNT; i++)\n"
	"	{\n"
	"		point_light( surface, color, PointLights[i], eye_vector, d, s);\n"
	"		lighting.diffuse += d;\n"
	"		lighting.specular += s;\n"
	"	}\n"
	"#endif // POINT_LIGHT_COUNT > 0\n"
	"#if (SPOT_LIGHT_COUNT > 0)\n"
	"	for( int i = 0; i < SPOT_LIGHT_COUNT; i++)\n"
	"	{\n"
	"		spot_light( surface, color, SpotLights[i], eye_vector, d, s);\n"
	"		lighting.diffuse += d;\n"
	"		lighting.specular += s;\n"
	"	}\n"
	"#endif // SPOT_LIGHT_COUNT > 0\n"
	"}\n"
	"#endif // LIGHTING\n"
; 


char const * const h3d_geometry =
	"void export_pin(pixel_input vertex);\n"
	"void copy_vout_to_pin(vertex_output vertex, inout pixel_input pixel)\n"
	"{\n"
	"	pixel.position = vertex.position;\n"
	"	pixel.material_color_and_specular_intensity = vertex.material_color_and_specular_intensity;\n"
	"	#ifdef EYE_POSITION_COORD\n"
	"		pixel.eye_position = vertex.eye_position;\n"
	"	#endif\n"
	"	#ifdef PER_PIXEL_LIGHTING\n"
	"		#ifndef SPHERE_MARKER\n"
	"			pixel.eye_normal = vertex.eye_normal;\n"
	"		#endif\n"
	"	#else\n"
	"		#ifdef HAS_LIGHTING\n"
	"			pixel.diffuse_light_and_ambient_blend = vertex.diffuse_light_and_ambient_blend;\n"
	"		#endif // HAS_LIGHTING\n"
	"	#endif // PER_PIXEL_LIGHTING\n"
	"	#ifdef TANGENT_COORD	\n"
	"		pixel.eye_tangent = vertex.eye_tangent;\n"
	"	#endif\n"
	"	#ifdef HAS_ATMOSPHERIC_ATTENUATION\n"
	"		pixel.fog = vertex.fog;\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_FINDICES\n"
	"		pixel.findex = vertex.findex;\n"
	"	#endif\n"
	"	#if defined(WIDE_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"		pixel.wide_line_offset = vertex.wide_line_offset;\n"
	"	#endif\n"
	"	#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined(HAS_DEFINED_MATERIAL_GS) || defined(HAS_TEXTURE3D)\n"
	"		pixel.uvst0 = vertex.uvst0;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		pixel.uv0 = vertex.uv0;\n"
	"	#endif\n"
	"	#ifndef SHARED_DIFFUSE_COORDS\n"
	"		#if (TEXTURE_COUNT > 1)\n"
	"			pixel.uv1 = vertex.uv1;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 2) \n"
	"			pixel.uv2 = vertex.uv2;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 3) \n"
	"			pixel.uv3 = vertex.uv3;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 4) \n"
	"			pixel.uv4 = vertex.uv4;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 5) \n"
	"			pixel.uv5 = vertex.uv5;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 6) \n"
	"			pixel.uv6 = vertex.uv6;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 7) \n"
	"			pixel.uv7 = vertex.uv7;\n"
	"		#endif\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		pixel.buv0 = vertex.buv0;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 1)\n"
	"		pixel.buv1 = vertex.buv1;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 2) \n"
	"		pixel.buv2 = vertex.buv2;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 3) \n"
	"		pixel.buv3 = vertex.buv3;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 4) \n"
	"		pixel.buv4 = vertex.buv4;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 5) \n"
	"		pixel.buv5 = vertex.buv5;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 6) \n"
	"		pixel.buv6 = vertex.buv6;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 7) \n"
	"		pixel.buv7 = vertex.buv7;\n"
	"	#endif\n"
	"	#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"		pixel.marker_uv = vertex.marker_uv;\n"
	"	#endif\n"
	"	#ifdef SPRITE_MARKER\n"
	"		pixel.marker_size = vertex.marker_size;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 0)\n"
	"		pixel.uvsm0 = vertex.uvsm0;\n"
	"	#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"		pixel.screen_position = vertex.screen_position;\n"
	"	#endif\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 1)\n"
	"		pixel.uvsm1 = vertex.uvsm1;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 2)\n"
	"		pixel.uvsm2 = vertex.uvsm2;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 3)\n"
	"		pixel.uvsm3 = vertex.uvsm3;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 0)\n"
	"		pixel.uvcp0 = vertex.uvcp0;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 4)\n"
	"		pixel.uvcp1 = vertex.uvcp1;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 8)\n"
	"		pixel.uvcp2 = vertex.uvcp2;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 12)\n"
	"		pixel.uvcp3 = vertex.uvcp3;\n"
	"	#endif\n"
	"	#ifdef ENVIRONMENT_TEXTURE \n"
	"		#if !defined(CUBE_ENVIRONMENT_MAP) || !defined(PER_PIXEL_LIGHTING)\n"
	"			pixel.uvenv = vertex.uvenv;\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef MIRROR_TEXTURE\n"
	"		pixel.uvmirror = vertex.uvmirror;\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		pixel.uvspec = vertex.uvspec;\n"
	"	#endif\n"
	"	#ifdef BUMP_TEXTURE\n"
	"		pixel.uvbump = vertex.uvbump;\n"
	"	#endif \n"
	"	#ifdef TRANSMISSION_TEXTURE\n"
	"		pixel.uvtransmission = vertex.uvtransmission;\n"
	"	#endif\n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		pixel.uvemission = vertex.uvemission;\n"
	"	#endif\n"
	"	#if defined(DEPTH_PEELING) || defined(DEPTH_WRITING)\n"
	"		pixel.peel_position = vertex.peel_position;\n"
	"	#endif\n"
	"	#ifdef HAS_FACE_PATTERN\n"
	"		pixel.uvzwfp = vertex.uvzwfp;\n"
	"	#endif\n"
	"	#ifdef HAS_LINE_PATTERN\n"
	"		pixel.uvlp = vertex.uvlp;\n"
	"	#endif\n"
	"	#ifdef HAS_GEOMETRY_SHADER\n"
	"		pixel.PrimitiveIndex = 0;\n"
	"	#endif\n"
	"}\n"
	"#ifdef SPRITE_MARKER\n"
	"uniform float2 MarkerSize;\n"
	"float2 corner_xform(int i)\n"
	"{\n"
	"	if (i == 0)			return float2(-1.0,-1.0);\n"
	"	else if (i == 1)	return float2(-1.0,1.0);\n"
	"	else if (i == 2)	return float2(1.0,-1.0);\n"
	"	else				return float2(1.0,1.0);\n"
	"}\n"
	"float2 coords(int i)\n"
	"{\n"
	"	if (i == 0)			return float2(0,1);\n"
	"	else if (i == 1)	return float2(0,0);\n"
	"	else if (i == 2)	return float2(1,1);\n"
	"	else				return float2(1,0);\n"
	"}\n"
	"void point_splats( \n"
	"	in vertex_output points[1]\n"
	"	, inout STREAM triStream\n"
	"	, in uint PrimitiveIndex\n"
	")\n"
	"{\n"
	"	pixel_input v;\n"
	"	copy_vout_to_pin(points[0], v);\n"
	"	v.PrimitiveIndex = PrimitiveIndex;\n"
	"	float2 RealMarkerSize = MarkerSize;\n"
	"#ifndef WORLD_SPACE_MARKER\n"
	"	RealMarkerSize *= v.position.w;\n"
	"#endif\n"
	"	for (int i = 0; i < 4; i++) {\n"
	"		v.position.xy = points[0].position.xy + corner_xform(i)*RealMarkerSize.xy;\n"
	"#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"		v.marker_uv = coords(i);\n"
	"#endif\n"
	"		AppendVertex(triStream, v);\n"
	"	}\n"
	"}\n"
	"#endif\n"
	"#ifdef GS_ELLIPTICAL_ARC	// equal subdivisions\n"
	"#define TWO_PI 6.28318530718\n"
	"void elliptical_arc(in vertex_output points[3], inout STREAM line_stream)\n"
	"{\n"
	"	pixel_input v;\n"
	"	copy_vout_to_pin(points[0], v);\n"
	"	float4 center = points[0].position;\n"
	"	float4 major = points[1].position - center;\n"
	"	float4 minor = points[2].position - center;\n"
	"	float start = points[0].arc_param;\n"
	"	float end = points[1].arc_param;\n"
	"	if (end < start)\n"
	"		end += 1.0;\n"
	"	int iterations = clamp(2, (int)points[2].arc_param / 4, 28);\n"
	"	float dt = TWO_PI * 0.25 * (end - start) / (iterations - 1);\n"
	"	float t = TWO_PI * (start + 0.25 * points[0].InstanceID * (end - start));\n"
	"	for (int i = 0; i < iterations; ++i)\n"
	"	{\n"
	"		float s, c;\n"
	"		sincos(t, s, c);\n"
	"		v.position = center + c * major + s * minor;\n"
	"		float w = 1.0 - c - s;\n"
	"#if (CUTTING_PLANE_COUNT > 0)\n"
	"		v.uvcp0 = w * points[0].uvcp0 + c * points[1].uvcp0 + s * points[2].uvcp0;		\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 4)\n"
	"		v.uvcp1 = w * points[0].uvcp1 + c * points[1].uvcp1 + s * points[2].uvcp1;\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 8)\n"
	"		v.uvcp2 = w * points[0].uvcp2 + c * points[1].uvcp2 + s * points[2].uvcp2;\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 12)\n"
	"		v.uvcp3 = w * points[0].uvcp3 + c * points[1].uvcp3 + s * points[2].uvcp3;\n"
	"#endif\n"
	"		AppendVertex(line_stream, v);\n"
	"		t += dt;\n"
	"	}\n"
	"	RestartPrimitive(line_stream);\n"
	"}\n"
	"#endif\n"
	"#ifdef HAS_DEFINED_MATERIAL_GS\n"
	"#ifdef DC\n"
	"	uniform row_major float4x4 WorldViewProj;\n"
	"#else\n"
	"	uniform row_major float4x4 Projection;\n"
	"	uniform row_major float4x4 ModelView;\n"
	"	uniform row_major float4x4 Model;\n"
	"	uniform row_major float3x3 NormalizedModelView3x3;\n"
	"#endif\n"
	"static pixel_input mgs_base_vertex;\n"
	"void h3d_emit(const HVertex vertex, inout HStream stream)\n"
	"{\n"
	"#ifdef DC\n"
	"	mgs_base_vertex.position		= mul(vertex.position, WorldViewProj);\n"
	"#else\n"
	"	float4 eye_position				= mul(float4(vertex.position, 1.0), ModelView);\n"
	"	mgs_base_vertex.position		= mul(eye_position, Projection);\n"
	"#endif\n"
	"	mgs_base_vertex.uvst0			= vertex.texcoords;\n"
	"#ifdef PER_PIXEL_LIGHTING\n"
	"	mgs_base_vertex.eye_normal		= mul(vertex.normal, NormalizedModelView3x3);\n"
	"#endif\n"
	"	AppendVertex(stream, mgs_base_vertex);\n"
	"}\n"
	"void h3d_restart(inout HStream stream)\n"
	"{\n"
	"	RestartPrimitive(stream);\n"
	"}\n"
	"void material_geometry_shader(in vertex_output points[1] , inout STREAM stream, uint primitive_index)\n"
	"{\n"
	"	HGlobals globals;\n"
	"	globals.nothing_yet = 0;\n"
	"	HVertex input[1];\n"
	"	for ( int i = 0; i != 1; ++i )\n"
	"	{\n"
	"		input[i].position	= points[i].position;\n"
	"		input[i].texcoords	= points[i].uvst0;\n"
	"#ifdef PER_PIXEL_LIGHTING\n"
	"		input[i].normal		= points[i].eye_normal;\n"
	"#else\n"
	"		input[i].normal		= float3(0.0, 0.0, -1.0);\n"
	"#endif\n"
	"	}\n"
	"	copy_vout_to_pin(points[0], mgs_base_vertex);\n"
	"	mgs_base_vertex.PrimitiveIndex = primitive_index;\n"
	"#ifdef H3D_GEOMETRY_SHADER\n"
	"	H3D_GEOMETRY_SHADER(globals, input, stream);\n"
	"#endif\n"
	"}\n"
	"#endif // HAS_DEFINED_MATERIAL_GS\n"
; 


char const * const h3d_macros =
	"#define PROCESS_PS_TEXTURE_##(sampler)_##(sampler_unit)(use_color, modulate, drop) \\\n"
	"{ \\\n"
	"	if (FrontDiffuseTextureEnable == ##(facing_value)) { \\\n"
	"		tex_color = tex2D(##(sampler)Sampler##(sampler_unit), vertex.##(uv)##(unit).xy); \\\n"
	"		if (use_color) \\\n"
	"			tex_color *= float4(ModulationColor##(sampler_unit),1.0); \\\n"
	"		if (drop && (vertex.##(uv)##(unit).x < 0.0 || vertex.##(uv)##(unit).x > 1.0 || \\\n"
	"					vertex.##(uv)##(unit).y < 0.0 || vertex.##(uv)##(unit).y > 1.0)) \\\n"
	"			tex_color = float4(0.0, 0.0, 0.0, 0.0); \\\n"
	"		new_color = float4(lerp(final_color, tex_color, tex_color.a)); \\\n"
	"		if(modulate) \\\n"
	"			final_color *= new_color; \\\n"
	"		else \\\n"
	"			final_color = new_color; \\\n"
	"	} \\\n"
	"}\n"
	"#endmacro\n"
	"#define PROCESS_VS_TEXTURE_##(facing)_##(unit)(world) \\\n"
	"{ \\\n"
	"	#ifndef DC \\\n"
	"		if (world) \\\n"
	"			result.##(uv)##(unit) = world_position.xy; \\\n"
	"		else \\\n"
	"			result.##(uv)##(unit) = vertex.##(uv)##(unit).xy; \\\n"
	"		result.##(uv)##(unit) = (mul(float4(result.##(uv)##(unit), 0.0, 1.0), TextureMatrix##(unit))).xy; \\\n"
	"	#else \\\n"
	"		result.##(uv)##(unit) = vertex.##(uv)##(unit).xy; \\\n"
	"	#endif \\\n"
	"}\n"
	"#endmacro\n"
; 


char const * const h3d_material =
	"struct HTextures\n"
	"{\n"
	"	HIGHP float4 coords;\n"
	"};\n"
	"struct HCamera\n"
	"{\n"
	"	MEDP float3 direction;\n"
	"	MEDP float3 position;\n"
	"};\n"
	"struct HGlobals\n"
	"{\n"
	"	HCamera cam;\n"
	"	HTextures tex;\n"
	"	LOWP float time;\n"
	"};\n"
	"struct HColor\n"
	"{\n"
	"	MEDP float4 diffuse;\n"
	"	MEDP float4 specular;\n"
	"};\n"
	"struct HSurface\n"
	"{\n"
	"	MEDP float3 position;\n"
	"	MEDP float3 normal;\n"
	"	MEDP float3 tangent;\n"
	"	MEDP float3 bitangent;\n"
	"	MEDP float2 marker_uv;\n"
	"};\n"
	"struct HLighting\n"
	"{\n"
	"	MEDP float3 ambient;\n"
	"	MEDP float3 diffuse;\n"
	"	MEDP float3 specular;\n"
	"	MEDP float3 emissive;\n"
	"};\n"
	"struct HEffects\n"
	"{\n"
	"	LOWP float3 mirror;\n"
	"	LOWP float3 environment;\n"
	"	LOWP float luminance;\n"
	"	LOWP float alpha;\n"
	"};\n"
	"float h3d_schlick_fresnel(float F0, float NdotV, float power)\n"
	"{\n"
	"	return F0 + pow(1.0 - NdotV, power) * (1.0 - F0);\n"
	"}\n"
	"float3 h3d_schlick_fresnel_rgb(float3 F0, float NdotV, float power)\n"
	"{\n"
	"	return F0 + pow(1.0 - NdotV, power) * (1.0 - F0);\n"
	"}\n"
	"#define h3d_compute_f0(ior) ((ior - 1.0) / (ior + 1.0)) * ((ior - 1.0) / (ior + 1.0))\n"
	"#define H3D_DECLARE_USER_LIGHTING_MODEL(name) void name(float3 N, float3 T, float3 B, float3 V, float3 H, float3 L, float4 diffuse, float3 specular, HColor color, out float3 out_diffuse, out float3 out_specular)\n"
	"#define H3D_LIGHTING_MODEL_NAME(name) name\n"
	"#define H3D_DECLARE_LIGHTING_MODEL(name) H3D_DECLARE_USER_LIGHTING_MODEL(H3D_LIGHTING_MODEL_NAME(name))\n"
	"#ifdef PIXEL_SHADER\n"
	"void h3d_normal_map(const float3 map_normal, inout HSurface surface)\n"
	"{\n"
	"	surface.normal *= map_normal.z;\n"
	"	surface.normal += map_normal.x * surface.tangent;\n"
	"	surface.normal += map_normal.y * surface.bitangent;\n"
	"	surface.normal = normalize(surface.normal);\n"
	"}\n"
	"float h3d_estimate_mip_level(float2 uv, float2 texture_size)\n"
	"{\n"
	"#if !defined(OGL_ES) && (SHADER_MODEL >= 3)\n"
	"	uv *= texture_size;\n"
	"	float2 dx = ddx(uv);\n"
	"	float2 dy = ddy(uv);\n"
	"	float2 dd = dx*dx + dy*dy;\n"
	"	float max_dd = max(dd.x, dd.y);\n"
	"	return 0.5 * log2(max_dd);\n"
	"#else\n"
	"	return 0.0;\n"
	"#endif\n"
	"}\n"
	"void hi_parallax_map(const HGlobals globals, const HSurface surface, inout float2 uv, HSampler2D heightfield, float2 size, float depth, float repeat, bool upward)\n"
	"{\n"
	"#if !defined(OGL_ES) && (SHADER_MODEL >= 3)\n"
	"	const float MAX_MIP = 1.0;\n"
	"	const float FADE_RANGE = 1.0;\n"
	"	float mip = h3d_estimate_mip_level(uv * repeat, size);\n"
	"	H3D_BRANCH_HINT\n"
	"	if ( mip > MAX_MIP )\n"
	"		return;\n"
	"	float lod_fade = saturate((MAX_MIP - mip) / FADE_RANGE);	// 1.0 when mip <= MAX_MIP - FADE_RANGE\n"
	"	float angle_fade = 1 - saturate(1 + surface.normal.z);		// 1.0 when surface.normal.z = -1, i.e. facing camera. \n"
	"	float2 dx = ddx(uv*repeat);\n"
	"	float2 dy = ddy(uv*repeat);\n"
	"#ifdef CAMERA_PERSPECTIVE\n"
	"	float3 eye_camera = normalize(globals.cam.position-surface.position);\n"
	"#else\n"
	"	float3 eye_camera = globals.cam.direction;\n"
	"#endif\n"
	"	float3 eye;\n"
	"	eye.x = dot(surface.tangent, eye_camera);\n"
	"	eye.y = dot(surface.bitangent, eye_camera);\n"
	"	eye.z = dot(surface.normal, eye_camera);\n"
	"	float parallax_limit = length(eye.xy) / eye.z; \n"
	"    float2 parallax_offset = normalize(eye.xy) * parallax_limit * depth * lod_fade;\n"
	"    int step_count = int(lerp(40, 8, angle_fade));\n"
	"	float step = 1.0 / step_count;\n"
	"	float3 delta_pos;\n"
	"	delta_pos.xy = parallax_offset * repeat * step;\n"
	"	delta_pos.z = step;\n"
	"	float3 pos;\n"
	"	pos.xy = uv * repeat;\n"
	"	if ( upward )\n"
	"	{\n"
	"		pos.z = 0.0;\n"
	"		float h1 = 0.0;\n"
	"		float h0;\n"
	"		H3D_LOOP_HINT\n"
	"		while ( pos.z < 1.0 ) \n"
	"		{\n"
	"			pos += delta_pos;\n"
	"			h0 = h1;\n"
	"			h1 = tex2Dgrad(heightfield, pos.xy, dx, dy).a;\n"
	"			if (h1 < pos.z)\n"
	"				break;\n"
	"		} \n"
	"		float dh = h1 - h0;\n"
	"		float z0 = pos.z - step;\n"
	"		float dz = step;\n"
	"		float numerator = h0 * dz - z0 * dh;\n"
	"		float denominator = dz - dh;\n"
	"		float z = 0.0;\n"
	"		if ( denominator != 0.0 )\n"
	"			z = numerator / denominator;\n"
	"		uv += parallax_offset * z;\n"
	"	}\n"
	"	else\n"
	"	{\n"
	"		pos.z = 1.0;\n"
	"		float h1 = 1.0;\n"
	"		float h0;\n"
	"		H3D_LOOP_HINT\n"
	"		while ( pos.z > 0.0 ) \n"
	"		{\n"
	"			pos -= delta_pos;\n"
	"			h0 = h1;\n"
	"			h1 = tex2Dgrad(heightfield, pos.xy, dx, dy).a;\n"
	"			if (h1 > pos.z)\n"
	"				break;\n"
	"		} \n"
	"		float d0 = pos.z + step - h0;\n"
	" 		float d1 = pos.z - h1;\n"
	"		float denominator = d0-d1;\n"
	"	 	float z = 0.0;\n"
	"		if ( denominator != 0.0 )\n"
	" 			z = (pos.z * d0 - (pos.z + step) * d1) / denominator;\n"
	"		uv -= parallax_offset * (1-z);\n"
	"	}\n"
	"#endif\n"
	"}\n"
	"void h3d_parallax_map(const HGlobals globals, const HSurface surface, inout float2 uv, HSampler2D heightfield, float2 size, float depth, float repeat)\n"
	"{\n"
	"	hi_parallax_map(globals, surface, uv, heightfield, size, depth, repeat, false);\n"
	"}\n"
	"void h3d_parallax_map_upward(const HGlobals globals, const HSurface surface, inout float2 uv, HSampler2D heightfield, float2 size, float depth, float repeat)\n"
	"{\n"
	"	hi_parallax_map(globals, surface, uv, heightfield, size, depth, repeat, true);\n"
	"}\n"
	"float4 hi_random_tile_lookup(HSampler2D tile, HSampler2D noise, float2 inverse_noise_size, float2 uv, float2 offset, float size_scale, float size_range, float angle_range, float3 rgb_range)\n"
	"{\n"
	"	float2 rand_uv = (uv + offset) * inverse_noise_size;\n"
	"	float4 random = tex2D(noise, rand_uv);\n"
	"	random = 2.0 * random - float4(1.0, 1.0, 1.0, 1.0);\n"
	"	float st = random.z * angle_range;\n"
	"	float ct = sqrt(1.0 - st * st);\n"
	"	float s = size_scale + random.w * size_range;\n"
	"	ct *= s;\n"
	"	st *= s;\n"
	"	float2x2 m = float2x2(st, ct, ct, -st);\n"
	"	float2 tile_uv = mul(uv, m) + random.xy;\n"
	"#if (SHADER_MODEL == 2) || (GLSL_VERSION == 120) || defined(OGL_ES)\n"
	"	float4 result = tex2D(tile, tile_uv);\n"
	"#else\n"
	"	float2 lod_uv = uv * size_scale;\n"
	"	float4 result = tex2Dgrad(tile, tile_uv, ddx(lod_uv), ddy(lod_uv));\n"
	"#endif\n"
	"	float rgb_random = 0.5 * (random.z + random.w);\n"
	"	result.rgb += result.rgb * rgb_range * rgb_random;\n"
	"	return result;\n"
	"}\n"
	"float4 h3d_random_tile(HSampler2D tile, HSampler2D noise, float2 inverse_noise_size, float2 uv, float size_scale, float size_range, float angle_range, float3 rgb_range, float blend_start)\n"
	"{\n"
	"	float4 tl = hi_random_tile_lookup(tile, noise, inverse_noise_size, uv, float2(0.0, 0.0), size_scale, size_range, angle_range, rgb_range);\n"
	"	float4 tr = hi_random_tile_lookup(tile, noise, inverse_noise_size, uv, float2(1.0, 0.0), size_scale, size_range, angle_range, rgb_range);\n"
	"	float4 bl = hi_random_tile_lookup(tile, noise, inverse_noise_size, uv, float2(0.0, 1.0), size_scale, size_range, angle_range, rgb_range);\n"
	"	float4 br = hi_random_tile_lookup(tile, noise, inverse_noise_size, uv, float2(1.0, 1.0), size_scale, size_range, angle_range, rgb_range);\n"
	"	float2 i = frac(uv);\n"
	"	i = smoothstep(float2(blend_start, blend_start), float2(1.0, 1.0), i);\n"
	"	float4 t = lerp(tl, tr, i.x);\n"
	"	float4 b = lerp(bl, br, i.x);\n"
	"	return lerp(t, b, i.y);\n"
	"}\n"
	"#ifdef HAS_DEFINED_MATERIAL_SHADER\n"
	"#define HMaterialSampler1 DiffuseSampler1\n"
	"#define HMaterialSampler2 DiffuseSampler2\n"
	"#define HMaterialSampler3 DiffuseSampler3\n"
	"#define HMaterialSampler4 DiffuseSampler4\n"
	"#endif // HAS_DEFINED_MATERIAL_SHADER\n"
	"#endif // PIXEL_SHADER\n"
; 


char const * const h3d_material_gs =
	"struct HGlobals\n"
	"{\n"
	"	float nothing_yet;\n"
	"};\n"
	"struct HVertex\n"
	"{\n"
	"	float3 position;\n"
	"	float3 normal;\n"
	"	float4 texcoords;\n"
	"};\n"
	"#define HStream STREAM\n"
	"void h3d_emit(const HVertex v, inout HStream stream);\n"
	"void h3d_restart(inout HStream stream);\n"
; 


char const * const h3d_pixel =
	"float Time;\n"
	"uniform int FrontDiffuseTextureEnable;\n"
	"#ifdef TEXTURE_MARKER\n"
	"uniform float MarkerSamplerBias;\n"
	"#endif\n"
	"#ifdef TRANSMISSION_TEXTURE_MODULATE\n"
	"uniform float3 TransmissionModulateColor;\n"
	"#endif\n"
	"#ifdef HAS_FACE_PATTERN\n"
	"uniform float4 FaceContrastColor;\n"
	"uniform float2 FacePatternOffset;\n"
	"uniform float ScaledWindowWidth;\n"
	"uniform float ScaledWindowHeight;\n"
	"#endif\n"
	"#ifdef HAS_LINE_PATTERN\n"
	"uniform float4 LineContrastColor;\n"
	"#endif\n"
	"#ifdef DEPTH_PEELING\n"
	"#undef WRITE_LUMINANCE\n"
	"uniform float4 DepthPeelingScaleAndBias;\n"
	"uniform float4 viewport_scale_and_bias;\n"
	"#endif // DEPTH_PEELING\n"
	"#ifdef SHADOW_MAP_JITTER\n"
	"uniform float4 JitterScaleAndBias;\n"
	"#endif // SHADOW_MAP_JITTER\n"
	"#ifdef SHADOW_MAP_0_VIEW_DEPENDENT\n"
	"uniform float3 SliceScales0[SHADOW_MAP_SLICE_COUNT];\n"
	"uniform float3 SliceBiases0[SHADOW_MAP_SLICE_COUNT];\n"
	"#endif // SHADOW_MAP_0_VIEW_DEPENDENT\n"
	"#ifdef SHADOW_MAP_1_VIEW_DEPENDENT\n"
	"uniform float3 SliceScales1[SHADOW_MAP_SLICE_COUNT];\n"
	"uniform float3 SliceBiases1[SHADOW_MAP_SLICE_COUNT];\n"
	"#endif // SHADOW_MAP_1_VIEW_DEPENDENT\n"
	"#ifdef SHADOW_MAP_2_VIEW_DEPENDENT\n"
	"uniform float3 SliceScales2[SHADOW_MAP_SLICE_COUNT];\n"
	"uniform float3 SliceBiases2[SHADOW_MAP_SLICE_COUNT];\n"
	"#endif // SHADOW_MAP_2_VIEW_DEPENDENT\n"
	"#ifdef SHADOW_MAP_3_VIEW_DEPENDENT\n"
	"uniform float3 SliceScales3[SHADOW_MAP_SLICE_COUNT];\n"
	"uniform float3 SliceBiases3[SHADOW_MAP_SLICE_COUNT];\n"
	"#endif // SHADOW_MAP_3_VIEW_DEPENDENT\n"
	"#ifdef CREATE_SHADOW_MAP\n"
	"uniform float2 ShadowMapBias;\n"
	"#endif\n"
	"uniform float3 Mirror;\n"
	"uniform float3 ModulationColor0;\n"
	"uniform float3 ModulationColor1;\n"
	"uniform float3 ModulationColor2;\n"
	"uniform float3 ModulationColor3;\n"
	"uniform float3 ModulationColor4;\n"
	"uniform float3 ModulationColor5;\n"
	"uniform float3 ModulationColor6;\n"
	"uniform float3 ModulationColor7;\n"
	"#ifdef HAS_LIGHTING\n"
	"uniform float3 AmbientLightUp;\n"
	"uniform float3 AmbientLightDown;\n"
	"#ifdef PER_PIXEL_LIGHTING\n"
	"uniform float3 AmbientLightDir;\n"
	"#else\n"
	"uniform float3 SpecularTint;\n"
	"#endif // ndef PER_PIXEL_LIGHTING\n"
	"uniform float3 EmissiveLight;\n"
	"#endif\n"
	"uniform HColor MaterialColor;\n"
	"#ifdef GOOCH\n"
	"uniform float4 GoochWeights;\n"
	"#endif // GOOCH\n"
	"uniform reflection_plane_t ReflectionPlane;\n"
	"#if defined(SHADER_MUST_FOG) && defined(HAS_ATMOSPHERIC_ATTENUATION)\n"
	"uniform float3 AtmosphericAttenuationColor;\n"
	"#endif\n"
	"uniform float DepthWriteScale;\n"
	"#if (SHADER_MODEL >= 4)\n"
	"	float4 hi_encode_uint_as_color(uint i)\n"
	"	{\n"
	"		uint4 i4 = uint4(i >> 24u, i >> 16u, i >> 8u, i);\n"
	"		return (i4 & uint4(255, 255, 255, 255)) * float4(1.0/255, 1.0/255, 1.0/255, 1.0/255);\n"
	"	}\n"
	"#endif\n"
	"#ifdef CREATE_SELECTION_MAP\n"
	"#if (SHADER_MODEL >= 4)\n"
	"uniform uint SelectionKeyHi;\n"
	"uniform uint SelectionKeyLoBase;\n"
	"uniform uint SelectionKeyLoMask;\n"
	"#else\n"
	"uniform float4 SelectionKeyHi;\n"
	"#endif\n"
	"#endif // CREATE_SELECTION_MAP\n"
	"#ifdef SELECTION_BITMAP\n"
	"#if (SHADER_MODEL >= 4)\n"
	"uniform uint SelectionKeyHi;\n"
	"uniform uint SelectionKeyLoBase;\n"
	"uniform uint SelectionKeyLoMask;\n"
	"#endif\n"
	"#endif\n"
	"#if (SHADOW_MAP_COUNT > 0)\n"
	"#ifdef SHADOW_MAP_SLICE_COUNT\n"
	"#define get_shadowmap_slice( uv, screen_z, scales, biases) \\\n"
	"{ \\\n"
	"	float2 cascade_uv; \\\n"
	"	 \\\n"
	"	if ( screen_z < biases[0].z ) \\\n"
	"		cascade_uv = uv.xy * scales[0].xy + biases[0].xy; \\\n"
	"	else if ( screen_z < biases[1].z ) \\\n"
	"		cascade_uv = uv.xy * scales[1].xy + biases[1].xy; \\\n"
	"	else if ( screen_z < biases[2].z ) \\\n"
	"		cascade_uv = uv.xy * scales[2].xy + biases[2].xy; \\\n"
	"	else \\\n"
	"		cascade_uv = uv.xy * scales[3].xy + biases[3].xy; \\\n"
	"	\\\n"
	"	uv = float4(cascade_uv.xy, uv.zw); \\\n"
	"}\n"
	"#endif // ndef SHADOW_MAP_SLICE_COUNT\n"
	"float read_shadowmap(HSampler2D shadow, float4 uv)\n"
	"{\n"
	"#ifdef SHADOW_MAP_RGBA\n"
	"	return unpack_rgba(tex2D(shadow, uv.xy));\n"
	"#else\n"
	"	return tex2D(shadow, uv.xy).x;\n"
	"#endif\n"
	"}\n"
	"#define ACCUMULATE_SAMPLES(which) \\\n"
	"	{\\\n"
	"		uv = position_xyxy;\\\n"
	"#ifdef SHADOW_MAP_JITTER \\\n"
	"		 \\\n"
	"		uv += jitter_adad * pcftaps(which * 2).xyzw;\\\n"
	"		uv += jitter_bcbc * pcftaps(which * 2).yxwz;\\\n"
	"#else \\\n"
	"		 \\\n"
	"		uv += pcftaps(which * 2); \\\n"
	"#endif  \\\n"
	" \\\n"
	"		 \\\n"
	"		results.x = read_shadowmap(shadowmap, float4(uv.xy,position.zw)); \\\n"
	"		results.y = read_shadowmap(shadowmap, float4(uv.zw,position.zw)); \\\n"
	" \\\n"
	"		uv = position_xyxy; \\\n"
	"#ifdef SHADOW_MAP_JITTER \\\n"
	"		 \\\n"
	"		uv += jitter_adad * pcftaps(which * 2 + 1).xyzw; \\\n"
	"		uv += jitter_bcbc * pcftaps(which * 2 + 1).yxwz; \\\n"
	"#else \\\n"
	"		 \\\n"
	"		uv += pcftaps(which * 2 + 1); \\\n"
	"#endif \\\n"
	"		 \\\n"
	"		 \\\n"
	"		results.z = read_shadowmap(shadowmap, float4(uv.xy,position.zw)); \\\n"
	"		results.w = read_shadowmap(shadowmap, float4(uv.zw,position.zw)); \\\n"
	"		 \\\n"
	"#ifndef DEPTH_TEXTURE_HARDWARE \\\n"
	"		 \\\n"
	"		 \\\n"
	"		 \\\n"
	"		results.x = (position.z < results.x) ? 1.0 : 0.0; \\\n"
	"		results.y = (position.z < results.y) ? 1.0 : 0.0; \\\n"
	"		results.z = (position.z < results.z) ? 1.0 : 0.0; \\\n"
	"		results.w = (position.z < results.w) ? 1.0 : 0.0; \\\n"
	"#endif \\\n"
	" \\\n"
	"		 \\\n"
	"		accumulator += results; \\\n"
	"	}\n"
	"float get_shadowmap_illumination( float4 jitter, float4 position, HSampler2D shadowmap )\n"
	"{\n"
	"	float result;\n"
	"	position /= position.w;\n"
	"#ifndef SHADOW_MAP_SAMPLES\n"
	"#ifdef SHADOW_MAP_JITTER\n"
	"	position.xy += jitter.xy / SHADOW_MAP_SIZE;\n"
	"#endif\n"
	"	result = read_shadowmap(shadowmap, position);\n"
	"#ifndef DEPTH_TEXTURE_HARDWARE\n"
	"	result = (position.z < result) ? 1.0 : 0.0;\n"
	"#endif\n"
	"#else\n"
	"	float4 uv;\n"
	"	float4 results;\n"
	"	float4 accumulator = float4(0.0,0.0,0.0,0.0);\n"
	"	const float weight = 1.0/SHADOW_MAP_SAMPLESF;\n"
	"	const float4 weights = float4(weight, weight, weight, weight);\n"
	"	float4 position_xyxy = position.xyxy;\n"
	"	float4 jitter_adad = jitter.xwxw;\n"
	"	float4 jitter_bcbc = jitter.yzyz;\n"
	"#if (SHADOW_MAP_SAMPLES > 0)\n"
	"	ACCUMULATE_SAMPLES(0);\n"
	"#endif\n"
	"#if (SHADOW_MAP_SAMPLES > 4)\n"
	"	ACCUMULATE_SAMPLES(1);\n"
	"#endif\n"
	"#if (SHADOW_MAP_SAMPLES > 8)\n"
	"	ACCUMULATE_SAMPLES(2);\n"
	"#endif\n"
	"#if (SHADOW_MAP_SAMPLES > 12)\n"
	"	ACCUMULATE_SAMPLES(3);\n"
	"#endif\n"
	"	result = dot(accumulator, weights);\n"
	"#endif // def SHADOW_MAP_SAMPLES\n"
	"	return result;\n"
	"}\n"
	"#ifdef BLACK_SHADOWS\n"
	"#define APPLY_SHADOW(dest, illum) ((dest) *= (illum))\n"
	"#else\n"
	"#define APPLY_SHADOW(dest, illum) ((dest) *= 0.5 + 0.5 * (illum))\n"
	"#endif\n"
	"#ifdef PER_PIXEL_LIGHTING\n"
	"void SHADOWED_DISTANT_LIGHT(const int which, const float4 shadow_map_uv, const HSampler2D shadow_map_texture, const float4 jitter, const HSurface surface, const HColor color, const float3 eye_vector, inout HLighting lighting)\n"
	"{ \n"
	"	if ( DISTANT_LIGHT_COUNT > which) { \n"
	"		float3 d, s; \n"
	"		distant_light(surface, color, DistantLights[COND(which,DISTANT_LIGHT_COUNT)], eye_vector, d, s); \n"
	"		if (DISTANT_SHADOW_MAP_COUNT > which) { \n"
	"			float illumination = get_shadowmap_illumination(jitter, shadow_map_uv, shadow_map_texture); \n"
	"			APPLY_SHADOW(d, illumination); \n"
	"			s *= illumination; \n"
	"		} \n"
	"		lighting.diffuse += d; \n"
	"		lighting.specular += s; \n"
	"	} \n"
	"}\n"
	"void SHADOWED_SPOT_LIGHT(const int which, const float4 shadow_map_uv, const HSampler2D shadow_map_texture, const float4 jitter, const HSurface surface, const HColor color, const float3 eye_vector, inout HLighting lighting)\n"
	"{ \n"
	"	if (SPOT_LIGHT_COUNT > which) { \n"
	"		float3 d, s; \n"
	"		spot_light(surface, color, SpotLights[COND(which,SPOT_LIGHT_COUNT)], eye_vector, d, s); \n"
	"		if (SPOT_SHADOW_MAP_COUNT > which) { \n"
	"			float illumination = get_shadowmap_illumination(jitter, shadow_map_uv, shadow_map_texture); \n"
	"			APPLY_SHADOW(d, illumination); \n"
	"			s *= illumination; \n"
	"			d *= illumination;\n"
	"		} \n"
	"		lighting.diffuse += d; \n"
	"		lighting.specular += s; \n"
	"	} \n"
	"}\n"
	"void shadowed_direct_lighting( const HColor color, \n"
	"							   const float4 jitter,\n"
	"							   const float4 shadow_map_uv[SHADOW_MAP_COUNT],\n"
	"							   const HSurface surface,\n"
	"							   inout HLighting lighting )\n"
	"{\n"
	"	float3 d, s;\n"
	"	float3 eye_vector = normalize(EyeCameraPosition -surface.position);\n"
	"#if (DISTANT_LIGHT_COUNT > 0)\n"
	"	SHADOWED_DISTANT_LIGHT(0, shadow_map_uv[DISTANT_SHADOW_MAP_UV0], DISTANT_SHADOW_MAP_TEXTURE0, jitter, surface, color, eye_vector, lighting);\n"
	"	SHADOWED_DISTANT_LIGHT(1, shadow_map_uv[DISTANT_SHADOW_MAP_UV1], DISTANT_SHADOW_MAP_TEXTURE1, jitter, surface, color, eye_vector, lighting);\n"
	"	SHADOWED_DISTANT_LIGHT(2, shadow_map_uv[DISTANT_SHADOW_MAP_UV2], DISTANT_SHADOW_MAP_TEXTURE2, jitter, surface, color, eye_vector, lighting);\n"
	"	SHADOWED_DISTANT_LIGHT(3, shadow_map_uv[DISTANT_SHADOW_MAP_UV3], DISTANT_SHADOW_MAP_TEXTURE3, jitter, surface, color, eye_vector, lighting);\n"
	"#if (DISTANT_LIGHT_COUNT > 4)\n"
	"	for ( int i = 4; i < DISTANT_LIGHT_COUNT; ++i )\n"
	"	{\n"
	"		distant_light(surface, color, DistantLights[i], eye_vector, d, s);\n"
	"		lighting.diffuse += d;\n"
	"		lighting.specular += s;\n"
	"	}\n"
	"#endif\n"
	"#endif\n"
	"#if (POINT_LIGHT_COUNT > 0)\n"
	"	for ( int i = 0; i < POINT_LIGHT_COUNT; i++)\n"
	"	{\n"
	"		point_light(surface, color, PointLights[i], eye_vector, d, s);\n"
	"		lighting.diffuse += d;\n"
	"		lighting.specular += s;\n"
	"	}\n"
	"#endif // POINT_LIGHT_COUNT > 0\n"
	"#if (SPOT_LIGHT_COUNT > 0)\n"
	"	SHADOWED_SPOT_LIGHT(0, shadow_map_uv[SPOT_SHADOW_MAP_UV0], SPOT_SHADOW_MAP_TEXTURE0, jitter, surface, color, eye_vector, lighting);\n"
	"	SHADOWED_SPOT_LIGHT(1, shadow_map_uv[SPOT_SHADOW_MAP_UV1], SPOT_SHADOW_MAP_TEXTURE1, jitter, surface, color, eye_vector, lighting);\n"
	"	SHADOWED_SPOT_LIGHT(2, shadow_map_uv[SPOT_SHADOW_MAP_UV2], SPOT_SHADOW_MAP_TEXTURE2, jitter, surface, color, eye_vector, lighting);\n"
	"	SHADOWED_SPOT_LIGHT(3, shadow_map_uv[SPOT_SHADOW_MAP_UV3], SPOT_SHADOW_MAP_TEXTURE3, jitter, surface, color, eye_vector, lighting);\n"
	"#if (SPOT_LIGHT_COUNT > 4)\n"
	"	for ( int i = 4; i < SPOT_LIGHT_COUNT; i++)\n"
	"	{\n"
	"		spot_light(surface, color, SpotLights[i], eye_vector, d, s);\n"
	"		lighting.diffuse += d;\n"
	"		lighting.specular += s;\n"
	"	}\n"
	"#endif\n"
	"#endif // SPOT_LIGHT_COUNT > 0\n"
	"}\n"
	"#endif // PER_PIXEL_LIGHTING\n"
	"#endif // (SHADOW_MAP_COUNT > 0)\n"
	"#ifdef PER_PIXEL_LIGHTING\n"
	"float3 fix_normal_handedness( float3 normal, float face )\n"
	"{\n"
	"#if (SHADER_MODEL >= 3) && defined(HAS_HANDEDNESS) && defined(TRIANGLE)\n"
	"	normal *= NORMAL_FLIP_SIGN * sign(face);\n"
	"	#ifdef RIGHT_HANDED_MATRIX\n"
	"		normal = -normal;\n"
	"	#endif\n"
	"#else	\n"
	"	#ifdef HAS_HANDEDNESS\n"
	"		#ifdef RIGHT_HANDED_MATRIX\n"
	"			normal = -normal;\n"
	"		#endif\n"
	"	#else\n"
	"		if(normal.z > 0.0)\n"
	"			normal = -normal;\n"
	"	#endif\n"
	"#endif \n"
	"	normal *= DRIVER_SPECIFIC_FLIP;\n"
	"	return normal;\n"
	"}\n"
	"void reconstruct_surface(const pixel_input vertex, float face, inout HSurface surface)\n"
	"{\n"
	"#ifdef SPHERE_MARKER\n"
	"	float2 marker_uv = vertex.marker_uv;\n"
	"	#ifndef OPENGL2\n"
	"		marker_uv.y = 1.0 - marker_uv.y;\n"
	"	#endif\n"
	"	float2 xy = 2.0 * marker_uv - float2(1.0, 1.0);\n"
	"	xy.x *= NORMAL_FLIP_SIGN;\n"
	"	surface.normal = float3(xy, DRIVER_SPECIFIC_FLIP * -sqrt(1.0 - dot(xy, xy)));\n"
	"#else\n"
	"	surface.normal = normalize(vertex.eye_normal.xyz * 2.0 - 1.0);	\n"
	"	surface.normal = fix_normal_handedness(surface.normal, face);\n"
	"#endif\n"
	"	#ifdef TANGENT_COORD\n"
	"		surface.tangent = normalize(vertex.eye_tangent.xyz * 2.0 - 1.0);\n"
	"		surface.bitangent = normalize(cross(surface.normal, surface.tangent)) * vertex.eye_tangent.w ;\n"
	"		surface.tangent *= DRIVER_SPECIFIC_FLIP;\n"
	"	#endif\n"
	"	#ifdef EYE_POSITION_COORD\n"
	"		surface.position = vertex.eye_position.xyz;\n"
	"	#endif // EYE_POSITION_COORD\n"
	"}		\n"
	"void apply_bump(const pixel_input vertex, inout HSurface surface)\n"
	"{\n"
	"#ifdef BUMP_TEXTURE\n"
	" 	float3 map_normal = tex2D(BumpSampler0, vertex.uvbump).xyz * 2.0 - 1.0;\n"
	"	h3d_normal_map(map_normal, surface);\n"
	"#endif // BUMP_TEXTURE\n"
	"}\n"
	"#endif // PER_PIXEL_LIGHTING\n"
	"void apply_gooch(const HLighting lighting, inout float3 lit_color)\n"
	"{\n"
	"#ifdef GOOCH\n"
	"	float diffuse_intensity = saturate(0.5 + 0.5 * lighting.diffuse.r);\n"
	"	float gooch_coord = GoochWeights.x * diffuse_intensity + GoochWeights.y;\n"
	"	float3 gooch_color = tex2D(GoochSampler0, float2(gooch_coord,0.0)).rgb;\n"
	"	lit_color = lerp( gooch_color, lit_color, GoochWeights.z );\n"
	"#endif // GOOCH\n"
	"}\n"
	"void apply_mirror( const pixel_input vertex, inout HEffects effects )\n"
	"{\n"
	"#ifdef ENVIRONMENT_TEXTURE\n"
	"	effects.mirror = Mirror;\n"
	"#ifdef MIRROR_TEXTURE\n"
	"	effects.mirror *= tex2D(MirrorSampler0, vertex.uvmirror).xyz;\n"
	"#endif\n"
	"#endif\n"
	"}\n"
	"void apply_environment( const pixel_input vertex, const HSurface surface, inout HEffects effects )\n"
	"{\n"
	"#ifdef ENVIRONMENT_TEXTURE\n"
	"	float3 uvenv;\n"
	"#if defined(PER_PIXEL_LIGHTING) && defined(CUBE_ENVIRONMENT_MAP)\n"
	"	#ifdef HAS_PHYSICAL_REFLECTION\n"
	"		uvenv = reflect(normalize(surface.position), surface.normal);\n"
	"		uvenv = uvenv.zyx;\n"
	"		uvenv.x *= -DRIVER_SPECIFIC_FLIP;\n"
	"	#else\n"
	"		uvenv = reflect(float3(0,0,1), surface.normal);\n"
	"		uvenv.xy *= DRIVER_SPECIFIC_FLIP;\n"
	"	#endif\n"
	"#else\n"
	"	uvenv = vertex.uvenv.xyz;	\n"
	"#endif\n"
	"#ifdef CUBE_ENVIRONMENT_MAP\n"
	"	effects.environment = texCUBE(EnvironmentSampler0, uvenv).rgb;\n"
	"#else\n"
	"	effects.environment = tex2D(EnvironmentSampler0, uvenv.xy).rgb;\n"
	"#endif\n"
	"#endif // ENVIRONMENT_TEXTURE\n"
	"}\n"
	"void apply_luminance( const HLighting lighting, inout HEffects effects )\n"
	"{\n"
	"#ifdef WRITE_LUMINANCE\n"
	"	effects.luminance += 0.5*rgb_to_gray(lighting.emissive);\n"
	"	effects.luminance += rgb_to_gray(lighting.specular);\n"
	"	MEDP float3 env = effects.environment.rgb;\n"
	"	float tex_luminance = saturate(2.0 * rgb_to_gray(env) - 1.0);\n"
	"	effects.luminance += tex_luminance*tex_luminance;\n"
	"#endif\n"
	"}\n"
	"#ifdef DEPTH_PEELING\n"
	"#ifdef OGL_ES\n"
	"#define DEPTH_PEELING_BIAS 0.01 \n"
	"#else\n"
	"#ifdef DEPTH_PACKING_RGBA\n"
	"#define DEPTH_PEELING_BIAS 0.0001\n"
	"#else\n"
	"#define DEPTH_PEELING_BIAS 0.000001\n"
	"#endif\n"
	"#endif // OGL_ES\n"
	"#endif // DEPTH_PEELING\n"
	"#ifdef MUST_DEFINE_CLIP_FUNC\n"
	"void clip(float x)\n"
	"{\n"
	"	if (x < 0.0)\n"
	"		discard;\n"
	"}\n"
	"void clip(vec2 x) \n"
	"{\n"
	"	bvec2 result = lessThan(x, float2(0.0,0.0));\n"
	"	if (any(result))\n"
	"		discard;\n"
	"}\n"
	"void clip(vec3 x) \n"
	"{\n"
	"	bvec3 result = lessThan(x, float3(0.0,0.0,0.0));\n"
	"	if (any(result))\n"
	"		discard;\n"
	"}\n"
	"void clip(vec4 x) \n"
	"{\n"
	"	bvec4 result = lessThan(x, float4(0.0,0.0,0.0,0.0));\n"
	"	if (any(result))\n"
	"		discard;\n"
	"}\n"
	"#endif\n"
	"void apply_line_styles(const pixel_input vertex, inout HColor color)\n"
	"{\n"
	"#if defined(ROUND_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"	float alpha = tex2D(LineToolsSampler0, vertex.wide_line_offset.xy).a;\n"
	"	#ifndef ANTI_ALIASED_LINE\n"
	"		if (vertex.wide_line_offset.z > H3D_ROUND - 0.0001 && \n"
	"			vertex.wide_line_offset.z < H3D_ROUND + 0.0001) {\n"
	"			clip (alpha - 0.5);\n"
	"		}\n"
	"	#else\n"
	"		color.diffuse.a *= alpha;\n"
	"	#endif\n"
	"#endif\n"
	"}\n"
	"void apply_vertex_findices(const pixel_input vertex, inout HColor color)\n"
	"{\n"
	"#ifdef HAS_VERTEX_FINDICES\n"
	"	float4 tex_color = tex2D(IndexSampler0, vertex.findex.xy);\n"
	"	color.diffuse = tex_color * float4(1.0, 1.0, 1.0, color.diffuse.a);\n"
	"#endif\n"
	"}\n"
	"void apply_face_pattern(const pixel_input vertex, inout HColor color)\n"
	"{\n"
	"#ifdef HAS_FACE_PATTERN\n"
	"	float4 uvzwfp = vertex.uvzwfp;\n"
	"#ifdef CAMERA_PERSPECTIVE\n"
	"	uvzwfp.xy /= uvzwfp.w;\n"
	"#endif		\n"
	"	uvzwfp.xy *= float2(0.5, 0.5);\n"
	"	uvzwfp.xy += float2(0.5, 0.5);\n"
	"	uvzwfp.xy *= float2(ScaledWindowWidth, -ScaledWindowHeight);\n"
	"	uvzwfp.xy += FacePatternOffset;\n"
	"	float4 tex_color = tex2D(FacePatternSampler0, uvzwfp.xy);\n"
	"	if (tex_color.a < 1.0) {\n"
	"		clip(FaceContrastColor.a - 0.999);\n"
	"		color.diffuse = FaceContrastColor;\n"
	"	}\n"
	"#endif\n"
	"}\n"
	"void apply_line_pattern(const pixel_input vertex, inout HColor color)\n"
	"{\n"
	"#ifdef HAS_LINE_PATTERN\n"
	"	float4 tex_color = tex2D(LinePatternSampler0, vertex.uvlp.xy);\n"
	"	clip (tex_color.a - 1.0);\n"
	"#endif // HAS_LINE_PATTERN	\n"
	"}\n"
	"void apply_multitexture(const pixel_input vertex, inout HColor color)\n"
	"{\n"
	"#if (!defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS)) || defined(DEFINED_MATERIAL_MULTITEXTURE)\n"
	"	float4 material_color = color.diffuse;\n"
	"	float4 final_color = color.diffuse;\n"
	"	float4 tex_color = float4(0.0,0.0,0.0,0.0);\n"
	"	float4 new_color = float4(0.0,0.0,0.0,0.0);\n"
	"	#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER)\n"
	"		if (FrontDiffuseTextureEnable == 1) {\n"
	"			#ifdef HAS_TEXTURE3D\n"
	"				tex_color = tex3D(DiffuseSampler0, vertex.uvst0.xyz); //float4 (vertex.uvst0.xyz, 1); //\n"
	"			#else\n"
	"				tex_color = tex2D(DiffuseSampler0, vertex.uv0.xy);\n"
	"			#endif\n"
	"			#ifdef PRIORITY_COMPOSITING\n"
	"				clip (0.999 - tex_color.a);\n"
	"			#endif\n"
	"			#ifdef BGRA_TO_RGBA\n"
	"				tex_color.rb = tex_color.br;\n"
	"			#endif\n"
	"			#ifdef TEXTURE0_COLOR\n"
	"				tex_color *= float4(ModulationColor0,1);\n"
	"			#endif\n"
	"			#ifdef TEXTURE0_DROP\n"
	"				if (vertex.uv0.x < 0.0 || vertex.uv0.x > 1.0 ||\n"
	"					vertex.uv0.y < 0.0 || vertex.uv0.y > 1.0)\n"
	"					tex_color = float4(0.0, 0.0, 0.0, 0.0);\n"
	"			#endif\n"
	"			#ifdef TEXTURE0_DECAL\n"
	"				new_color = float4(lerp(final_color.rgb, tex_color.rgb, tex_color.a), 1.0);\n"
	"			#else\n"
	"				new_color = tex_color;\n"
	"			#endif\n"
	"			#ifdef TEXTURE0_MODULATE\n"
	"				#ifdef TEXTURE_PREMULTIPLY\n"
	"					new_color.rgb *= new_color.a;\n"
	"				#endif\n"
	"				final_color *= new_color;\n"
	"			#else\n"
	"				final_color = float4(new_color.rgb, final_color.a * new_color.a);\n"
	"			#endif\n"
	"		}\n"
	"	#endif // TEXTURE_COUNT > 0 \n"
	"	#if (TEXTURE_COUNT > 1)\n"
	"		PROCESS_PS_TEXTURE_Diffuse_1(TEXTURE1_COLOR, TEXTURE1_MODULATE, TEXTURE1_DROP);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 2)\n"
	"		PROCESS_PS_TEXTURE_Diffuse_2(TEXTURE2_COLOR, TEXTURE2_MODULATE, TEXTURE2_DROP);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 3)\n"
	"		PROCESS_PS_TEXTURE_Diffuse_3(TEXTURE3_COLOR, TEXTURE3_MODULATE, TEXTURE3_DROP);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 4)\n"
	"		PROCESS_PS_TEXTURE_Diffuse_4(TEXTURE4_COLOR, TEXTURE4_MODULATE, TEXTURE4_DROP);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 5)\n"
	"		PROCESS_PS_TEXTURE_Diffuse_5(TEXTURE5_COLOR, TEXTURE5_MODULATE, TEXTURE5_DROP);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 6)\n"
	"		PROCESS_PS_TEXTURE_Diffuse_6(TEXTURE6_COLOR, TEXTURE6_MODULATE, TEXTURE6_DROP);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 7)\n"
	"		PROCESS_PS_TEXTURE_Diffuse_7(TEXTURE7_COLOR, TEXTURE7_MODULATE, TEXTURE7_DROP);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS)\n"
	"		if (FrontDiffuseTextureEnable == 0) {\n"
	"			#ifdef BACK_TEXTURE0_COLOR\n"
	"				tex_color = tex2D(BackDiffuseSampler0, vertex.buv0.xy) * float4(ModulationColor0,1);\n"
	"			#else\n"
	"				tex_color = tex2D(BackDiffuseSampler0, vertex.buv0.xy);\n"
	"			#endif\n"
	"			#ifdef BACK_TEXTURE0_DROP\n"
	"				if (vertex.uv0.x < 0.0 || vertex.uv0.x > 1.0 ||\n"
	"					vertex.uv0.y < 0.0 || vertex.uv0.y > 1.0)\n"
	"				tex_color = float4(0.0, 0.0, 0.0, 0.0);\n"
	"			#endif\n"
	"			#ifdef BACK_TEXTURE0_DECAL\n"
	"				new_color = float4(lerp(final_color.rgb, tex_color.rgb, tex_color.a), 1.0);\n"
	"			#else\n"
	"				new_color = tex_color;\n"
	"			#endif\n"
	"			#ifdef BACK_TEXTURE0_MODULATE\n"
	"				final_color *= new_color;\n"
	"			#else\n"
	"				final_color = float4(new_color.rgb, final_color.a * new_color.a);\n"
	"			#endif\n"
	"		}\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 1)\n"
	"		PROCESS_PS_TEXTURE_BackDiffuse_1(BACK_TEXTURE1_COLOR, BACK_TEXTURE1_MODULATE, BACK_TEXTURE1_DROP);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 2)\n"
	"		PROCESS_PS_TEXTURE_BackDiffuse_2(BACK_TEXTURE2_COLOR, BACK_TEXTURE2_MODULATE, BACK_TEXTURE2_DROP);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 3)\n"
	"		PROCESS_PS_TEXTURE_BackDiffuse_3(BACK_TEXTURE3_COLOR, BACK_TEXTURE3_MODULATE, BACK_TEXTURE3_DROP);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 4)\n"
	"		PROCESS_PS_TEXTURE_BackDiffuse_4(BACK_TEXTURE4_COLOR, BACK_TEXTURE4_MODULATE, BACK_TEXTURE4_DROP);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 5)\n"
	"		PROCESS_PS_TEXTURE_BackDiffuse_5(BACK_TEXTURE5_COLOR, BACK_TEXTURE5_MODULATE, BACK_TEXTURE5_DROP);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 6)\n"
	"		PROCESS_PS_TEXTURE_BackDiffuse_6(BACK_TEXTURE6_COLOR, BACK_TEXTURE6_MODULATE, BACK_TEXTURE6_DROP);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 7)\n"
	"		PROCESS_PS_TEXTURE_BackDiffuse_7(BACK_TEXTURE7_COLOR, BACK_TEXTURE7_MODULATE, BACK_TEXTURE7_DROP);\n"
	"	#endif\n"
	"	#ifdef TEXTURE0_DROP\n"
	"		clip(final_color.a - 1.0/255.0);\n"
	"	#endif\n"
	"	color.diffuse = final_color;\n"
	"#endif\n"
	"}\n"
	"void pixel_common (pixel_input vertex\n"
	"	#ifdef OGL_ES\n"
	"		, out float4 FinalColor\n"
	"	#else\n"
	"		, out float4 FinalColor semantic(COLOR0)\n"
	"	#endif \n"
	"#if (SHADER_MODEL >= 3)\n"
	"	, in float Face semantic(VFACE)\n"
	"#endif // SHADER_MODEL >= 3\n"
	"#if (SHADER_MODEL >= 4)\n"
	"	, in uint PrimitiveIndex\n"
	"#endif\n"
	"#if defined(DEPTH_WRITING) && defined(DEPTH_WRITING_SINGLE_PASS)\n"
	"	, out float4 FinalDepth semantic(FINAL_DEPTH)\n"
	"#endif // DEPTH_WRITING_SINGLE_PASS && DEPTH_WRITING \n"
	"#if defined(SELECTION_HAS_LO)\n"
	"	, out float4 FinalColor1 semantic(COLOR1)\n"
	"#endif // SELECTION_HAS_LO\n"
	"#if defined(WRITING_SSAA_LINE_TARGET)\n"
	"	, out float4 FinalLineColor semantic(FINAL_LINE_COLOR)\n"
	"#endif\n"
	")\n"
	"{   \n"
	"#if defined(CIRCLE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"	float2 marker_uv = vertex.marker_uv * 2.0 - 1.0;\n"
	"	#ifdef CIRCLE_MARKER\n"
	"		clip (1.0 - dot(marker_uv, marker_uv));\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef TEXTURE_MARKER\n"
	"	float4 marker_texture = tex2D(MarkerSampler0, vertex.marker_uv + MarkerSamplerBias);\n"
	"	clip (marker_texture.a - 0.001);\n"
	"#endif\n"
	"#if defined(CREATE_SHADOW_MAP) || defined(CREATE_SELECTION_MAP)\n"
	"	#ifdef CREATE_SELECTION_MAP\n"
	"		#if (SHADER_MODEL >= 4)\n"
	"			FinalColor = hi_encode_uint_as_color(SelectionKeyHi);\n"
	"			#ifdef SELECTION_HAS_LO\n"
	"				FinalColor1 = hi_encode_uint_as_color( (PrimitiveIndex & SelectionKeyLoMask) | SelectionKeyLoBase );\n"
	"			#endif\n"
	"		#else\n"
	"			FinalColor = SelectionKeyHi;\n"
	"		#endif\n"
	"	#else\n"
	"		#if (CUTTING_PLANE_COUNT > 0)\n"
	"			clip(vertex.uvcp0);\n"
	"		#endif\n"
	"		#if (CUTTING_PLANE_COUNT > 4)\n"
	"			clip(vertex.uvcp1);\n"
	"		#endif\n"
	"		#if (CUTTING_PLANE_COUNT > 8)\n"
	"			clip(vertex.uvcp2);\n"
	"		#endif\n"
	"		#if (CUTTING_PLANE_COUNT > 12)\n"
	"			clip(vertex.uvcp3);\n"
	"		#endif\n"
	"		#ifdef DEPTH_TEXTURE_HARDWARE\n"
	"			FinalColor = 0;\n"
	"		#else\n"
	"			float finaldepth = vertex.shadow_position.z / vertex.shadow_position.w + ShadowMapBias.x;\n"
	"			#ifdef SHADOW_MAP_SLOPE_SCALE_BIAS				\n"
	"				float dzdx = ddx(finaldepth);\n"
	"				float dzdy = ddy(finaldepth);\n"
	"				finaldepth += ShadowMapBias.y * (abs(dzdx) + abs(dzdy));\n"
	"			#endif			\n"
	"			#ifdef SHADOW_MAP_RGBA\n"
	"				FinalColor = pack_rgba(finaldepth);\n"
	"			#else\n"
	"				FinalColor = float4(finaldepth,0.0,0.0,0.0);\n"
	"			#endif\n"
	"		#endif // ndef DEPTH_TEXTURE_HARDWARE\n"
	"		#if defined(WRITING_SSAA_LINE_TARGET)\n"
	"			FinalLineColor = float4(0.0, 0.0, 0.0, 0.0);\n"
	"		#endif\n"
	"	#endif // ndef CREATE_SELECTION_MAP\n"
	"#else // CREATE_SHADOW_MAP||CREATE_SELECTION_MAP (non-standard indent in else case)\n"
	"#ifdef WRITING_SSAA_LINE_TARGET\n"
	"#ifdef LINE\n"
	"	FinalLineColor = float4(1.0, 0.0, 0.0, 1.0);\n"
	"#else\n"
	"	FinalLineColor = float4(0.0, 0.0, 0.0, 1.0);\n"
	"#endif\n"
	"#endif\n"
	"#if defined (DEPTH_PEELING) || defined(DEPTH_WRITING)\n"
	"	float4 peel = vertex.peel_position;\n"
	"	#ifdef DEPTH_PEELING_MODE\n"
	"		peel.xyz /= peel.w;\n"
	"	#else // DEPTH_PEELING_MODE\n"
	"		#ifdef FRAME_BUFFER_EFFECTS\n"
	"			peel.z = (254.0/255.0) * saturate( peel.z * DepthWriteScale );\n"
	"		#else\n"
	"			peel.z = 1.0;\n"
	"		#endif // FRAME_BUFFER_EFFECTS\n"
	"	#endif // ndef DEPTH_PEELING_MODE\n"
	"#endif // DEPTH_PEELING || DEPTH_WRITING\n"
	"#ifdef DEPTH_PEELING\n"
	"	#ifndef DC\n"
	"		peel.xy *= viewport_scale_and_bias.xy;\n"
	"		peel.xy += viewport_scale_and_bias.zw;\n"
	"	#endif\n"
	"	peel.xy *= DepthPeelingScaleAndBias.xy;\n"
	"	peel.xy += DepthPeelingScaleAndBias.zw;\n"
	"	float4 peel_texture = tex2D(DepthPeelingSampler0, peel.xy );\n"
	"	#ifdef DEPTH_PACKING_RGBA\n"
	"		float previous_depth = unpack_rgba( peel_texture );\n"
	"	#else\n"
	"		float previous_depth = peel_texture.r;\n"
	"	#endif // DEPTH_PACKING_RGBA\n"
	"	clip( peel.z - (previous_depth + DEPTH_PEELING_BIAS) );\n"
	"#endif // DEPTH_PEELING\n"
	"#ifdef DEPTH_WRITING\n"
	"	#ifdef DEPTH_PACKING_RGBA\n"
	"		float4 final_depth = pack_rgba(peel.z);\n"
	"	#else\n"
	"		const float4 final_depth = float4(peel.z, 0.0, 0.0, 0.0);\n"
	"	#endif // DEPTH_PACKING_RGBA\n"
	"	#ifdef DEPTH_WRITING_SINGLE_PASS\n"
	"		FinalDepth = final_depth;\n"
	"	#else\n"
	"		FinalColor = final_depth;\n"
	"		return;\n"
	"	#endif // DEPTH_WRITING_SINGLE_PASS\n"
	"#endif // DEPTH_WRITING\n"
	"	#if (CUTTING_PLANE_COUNT > 0)\n"
	"		clip(vertex.uvcp0);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 4)\n"
	"		clip(vertex.uvcp1);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 8)\n"
	"		clip(vertex.uvcp2);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 12)\n"
	"		clip(vertex.uvcp3);\n"
	"	#endif\n"
	"	HColor color;\n"
	"	color.diffuse = vertex.material_color_and_specular_intensity;\n"
	"	color.specular = MaterialColor.specular;\n"
	"#if defined(HAS_LIGHTING) && !defined(PER_PIXEL_LIGHTING)\n"
	"	color.diffuse.a = MaterialColor.diffuse.a;\n"
	"#endif\n"
	"	HSurface surface;\n"
	"	surface.normal = float3(0.0, 0.0, DRIVER_SPECIFIC_FLIP * -1.0);\n"
	"	surface.position = float3(0.0, 0.0, DRIVER_SPECIFIC_FLIP * 100000.0);\n"
	"	surface.tangent = float3(1.0, 0.0, 0.0);\n"
	"	surface.bitangent = float3(0.0, 1.0, 0.0);\n"
	"#if defined(MATERIAL_SHADER_MARKER)\n"
	"	surface.marker_uv = marker_uv;\n"
	"#else\n"
	"	surface.marker_uv = float2(0.0, 0.0);\n"
	"#endif\n"
	"	HLighting lighting;\n"
	"	lighting.ambient = float3(0.0, 0.0, 0.0);\n"
	"	lighting.diffuse = float3(0.0, 0.0, 0.0);\n"
	"	lighting.specular = float3(0.0, 0.0, 0.0);\n"
	"	lighting.emissive = float3(0.0, 0.0, 0.0);\n"
	"	HEffects effects;\n"
	"	effects.mirror = float3(0.0, 0.0, 0.0);\n"
	"	effects.environment = float3(0.0, 0.0, 0.0);\n"
	"	effects.luminance = 0.0;\n"
	"	effects.alpha = color.diffuse.a;\n"
	"	apply_mirror(vertex, effects);\n"
	"	apply_line_styles(vertex, color);\n"
	"	apply_vertex_findices(vertex, color);\n"
	"#if defined(HAS_LIGHTING) && defined(PER_PIXEL_LIGHTING)\n"
	"	#if (SHADER_MODEL >= 3)\n"
	"		float face = Face;\n"
	"	#else\n"
	"		float face = 1.0;\n"
	"	#endif\n"
	"	reconstruct_surface(vertex, face, surface);\n"
	"#endif\n"
	"#ifdef HAS_DEFINED_MATERIAL_SHADER\n"
	"	HGlobals globals;\n"
	"	globals.cam.direction = float3(0, 0, DRIVER_SPECIFIC_FLIP);\n"
	"#ifdef LIGHTIBG\n"
	"	globals.cam.position = EyeCameraPosition;\n"
	"#else\n"
	"	globals.cam.position = float3(0, 0, 0);\n"
	"#endif\n"
	"	globals.tex.coords = vertex.uvst0;\n"
	"	globals.time = Time;\n"
	"#endif // HAS_DEFINED_MATERIAL_SHADER\n"
	"#ifdef H3D_PETURB_SHADER\n"
	"	{\n"
	"		float2 coords = globals.tex.coords.xy;\n"
	"		H3D_PETURB_SHADER(globals, surface, coords);\n"
	"		globals.tex.coords.xy = coords;\n"
	"	}\n"
	"#endif\n"
	"#ifdef H3D_COLOR_SHADER\n"
	"	H3D_COLOR_SHADER(globals, color);\n"
	"#endif\n"
	"	apply_multitexture(vertex, color);\n"
	"#ifdef SELECTION_BITMAP\n"
	"	if ( hi_is_selected(SelectionKeyHi, (SelectionKeyLoMask & PrimitiveIndex) | SelectionKeyLoBase) )\n"
	"		color.diffuse.rgb = float3(1,1,0);\n"
	"#endif\n"
	"#ifdef HAS_LIGHTING\n"
	"	#ifdef PER_PIXEL_LIGHTING\n"
	"		apply_bump(vertex, surface);\n"
	"		#ifdef H3D_SURFACE_SHADER\n"
	"			H3D_SURFACE_SHADER(globals, surface);\n"
	"		#endif // H3D_SURFACE_SHADER\n"
	"		#if (SHADOW_MAP_COUNT > 0)\n"
	"			float4 jitter = float4(0.0,0.0,0.0,0.0);\n"
	"			float screen_z = 0.0;\n"
	"			#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"				vertex.screen_position.xy /= vertex.screen_position.w;\n"
	"				#ifdef SHADOW_MAP_JITTER\n"
	"					float2 jitter_position = vertex.screen_position.xy * JitterScaleAndBias.xy + JitterScaleAndBias.zw;\n"
	"					jitter = tex2D(JitterSampler0, jitter_position) * 2.0 - 1.0;\n"
	"				#endif // SHADOW_MAP_JITTER\n"
	"				#ifdef SHADOW_MAP_SLICE_COUNT\n"
	"					screen_z = vertex.screen_position.z;\n"
	"				#endif\n"
	"			#endif\n"
	"			float4 shadow_map_uv[SHADOW_MAP_COUNT];\n"
	"			shadow_map_uv[0] = vertex.uvsm0;\n"
	"			#ifdef SHADOW_MAP_0_VIEW_DEPENDENT\n"
	"				get_shadowmap_slice( shadow_map_uv[0], screen_z, SliceScales0, SliceBiases0);\n"
	"			#endif\n"
	"			#if (SHADOW_MAP_COUNT > 1)\n"
	"				shadow_map_uv[1]= vertex.uvsm1;\n"
	"				#ifdef SHADOW_MAP_1_VIEW_DEPENDENT\n"
	"					get_shadowmap_slice( shadow_map_uv[1], screen_z, SliceScales1, SliceBiases1);\n"
	"				#endif\n"
	"			#endif\n"
	"			#if (SHADOW_MAP_COUNT > 2)\n"
	"				shadow_map_uv[2] = vertex.uvsm2;\n"
	"				#ifdef SHADOW_MAP_2_VIEW_DEPENDENT\n"
	"					get_shadowmap_slice( shadow_map_uv[2], screen_z, SliceScales2, SliceBiases2);\n"
	"				#endif\n"
	"			#endif\n"
	"			#if (SHADOW_MAP_COUNT > 3)\n"
	"				shadow_map_uv[3] = vertex.uvsm3;\n"
	"				#ifdef SHADOW_MAP_3_VIEW_DEPENDENT\n"
	"					get_shadowmap_slice( shadow_map_uv[3], screen_z, SliceScales3, SliceBiases3);\n"
	"				#endif\n"
	"			#endif\n"
	"			shadowed_direct_lighting( color, jitter, shadow_map_uv, surface, lighting );\n"
	"		#else\n"
	"			direct_lighting( color, surface, lighting );\n"
	"		#endif // SHADOW_MAP_COUNT == 0\n"
	"		#ifdef OGL_ES	\n"
	"			lighting.ambient = AmbientLightUp;\n"
	"		#else\n"
	"			float ambient_blend = 0.5 + 0.5 * dot(surface.normal, AmbientLightDir);\n"
	"			lighting.ambient = lerp( AmbientLightDown, AmbientLightUp, ambient_blend );\n"
	"		#endif\n"
	"	#else // PER_PIXEL_LIGHTING\n"
	"		float3 d = vertex.diffuse_light_and_ambient_blend.rgb;\n"
	"		float3 s = vertex.material_color_and_specular_intensity.a * SpecularTint;\n"
	"		#if (SHADOW_MAP_COUNT > 0)\n"
	"			float4 jitter = float4(0.0,0.0,0.0,0.0);\n"
	"			float screen_z = 0.0;\n"
	"			#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"				vertex.screen_position.xy /= vertex.screen_position.w;\n"
	"				#ifdef SHADOW_MAP_JITTER\n"
	"					float2 jitter_position = vertex.screen_position.xy * JitterScaleAndBias.xy + JitterScaleAndBias.zw;\n"
	"					jitter = tex2D(JitterSampler0, jitter_position) * 2.0 - 1.0;\n"
	"				#endif // SHADOW_MAP_JITTER\n"
	"				#ifdef SHADOW_MAP_SLICE_COUNT\n"
	"					screen_z = vertex.screen_position.z;\n"
	"				#endif\n"
	"			#endif\n"
	"			float4 shadow_map_uv[SHADOW_MAP_COUNT];\n"
	"			shadow_map_uv[0] = vertex.uvsm0;\n"
	"			#ifdef SHADOW_MAP_0_VIEW_DEPENDENT\n"
	"				get_shadowmap_slice( shadow_map_uv[0], screen_z, SliceScales0, SliceBiases0);\n"
	"			#endif\n"
	"			#if (SHADOW_MAP_COUNT > 1)\n"
	"				shadow_map_uv[1]= vertex.uvsm1;\n"
	"				#ifdef SHADOW_MAP_1_VIEW_DEPENDENT\n"
	"					get_shadowmap_slice( shadow_map_uv[1], screen_z, SliceScales1, SliceBiases1);\n"
	"				#endif\n"
	"			#endif\n"
	"			#if (SHADOW_MAP_COUNT > 2)\n"
	"				shadow_map_uv[2] = vertex.uvsm2;\n"
	"				#ifdef SHADOW_MAP_2_VIEW_DEPENDENT\n"
	"					get_shadowmap_slice( shadow_map_uv[2], screen_z, SliceScales2, SliceBiases2);\n"
	"				#endif\n"
	"			#endif\n"
	"			#if (SHADOW_MAP_COUNT > 3)\n"
	"				shadow_map_uv[3] = vertex.uvsm3;\n"
	"				#ifdef SHADOW_MAP_3_VIEW_DEPENDENT\n"
	"					get_shadowmap_slice( shadow_map_uv[3], screen_z, SliceScales3, SliceBiases3);\n"
	"				#endif\n"
	"			#endif\n"
	"			if (DISTANT_SHADOW_MAP_COUNT > 0) {\n"
	"				float illumination = get_shadowmap_illumination( jitter, shadow_map_uv[DISTANT_SHADOW_MAP_UV0], DISTANT_SHADOW_MAP_TEXTURE0);\n"
	"				APPLY_SHADOW(d, illumination);\n"
	"				s *= illumination;\n"
	"			}\n"
	"		#endif\n"
	"		lighting.diffuse = d;\n"
	"		lighting.specular = s;\n"
	"		#ifdef OGL_ES	\n"
	"			lighting.ambient = AmbientLightUp;\n"
	"		#else\n"
	"            lighting.ambient = lerp( AmbientLightDown, AmbientLightUp, vertex.diffuse_light_and_ambient_blend.a );\n"
	"		#endif\n"
	"	#endif // PER_PIXEL_LIGHTING\n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		lighting.emissive = tex2D(EmissionSampler0, vertex.uvemission.xy).xyz;\n"
	"		#ifdef EMISSION_TEXTURE_MODULATE\n"
	"			lighting.emissive *= EmissiveLight;\n"
	"		#endif\n"
	"	#else\n"
	"		lighting.emissive = EmissiveLight;\n"
	"	#endif\n"
	"	#ifdef ENVIRONMENT_TEXTURE\n"
	"		lighting.emissive *= float3(1.0, 1.0, 1.0) - effects.mirror;\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		lighting.specular *= tex2D(SpecularSampler0, vertex.uvspec).rgb;\n"
	"	#endif\n"
	"	#ifdef H3D_LIGHTING_SHADER\n"
	"		H3D_LIGHTING_SHADER(globals, surface, lighting);\n"
	"	#endif\n"
	"    #ifdef AMBIENT_MATERIAL\n"
	"	    color.diffuse.rgb *= (lighting.ambient + lighting.diffuse);\n"
	"    #else\n"
	"	    color.diffuse.rgb = color.diffuse.rgb * lighting.diffuse + lighting.ambient;\n"
	"    #endif\n"
	"	apply_gooch(lighting, color.diffuse.rgb);\n"
	"#endif // HAS_LIGHTING\n"
	"	apply_environment(vertex, surface, effects);\n"
	"	apply_luminance(lighting, effects);\n"
	"	effects.alpha = color.diffuse.a;\n"
	"#ifdef H3D_EFFECTS_SHADER\n"
	"	H3D_EFFECTS_SHADER(globals, surface, lighting, effects);\n"
	"#endif // H3D_EFFECTS_SHADER\n"
	"	color.diffuse.a = effects.alpha;\n"
	"#ifdef ENVIRONMENT_TEXTURE\n"
	"	color.diffuse.rgb *= 1.0 - rgb_to_gray(effects.mirror);\n"
	"	color.diffuse.rgb += effects.environment.rgb * effects.mirror;\n"
	"#endif\n"
	"#if defined(HAS_LIGHTING)\n"
	"	color.diffuse.rgb += (lighting.specular + lighting.emissive);\n"
	"#endif\n"
	"	apply_face_pattern(vertex, color);\n"
	"	apply_line_pattern(vertex, color);\n"
	"#if defined(SHADER_MUST_FOG) && defined(HAS_ATMOSPHERIC_ATTENUATION)\n"
	"	color.diffuse.rgb = lerp(AtmosphericAttenuationColor,color.diffuse.rgb, vertex.fog);\n"
	"#endif\n"
	"#ifdef FORCE_GRAYSCALE\n"
	"	float gray = rgb_to_gray(color.diffuse.rgb);\n"
	"	color.diffuse.rgb = float3(gray, gray, gray);\n"
	"#endif\n"
	"#ifdef CREATE_REFLECTION_PLANE\n"
	"	float plane_distance = dot(vertex.eye_position, ReflectionPlane.plane);\n"
	"	float reflection_strength = 1.0 - saturate( plane_distance * ReflectionPlane.scale + ReflectionPlane.bias );\n"
	"	color.diffuse.a *= reflection_strength * reflection_strength;\n"
	"	color.diffuse.rgb *= color.diffuse.a;\n"
	"#endif // CREATE_REFLECTION_PLANE \n"
	"#ifdef WRITE_LUMINANCE\n"
	"	#ifdef FRAME_BUFFER_EFFECTS\n"
	"		clip (color.diffuse.a - 1.0/255.0);		\n"
	"		color.diffuse.a = (1.0/255.0) + effects.luminance;\n"
	"	#else\n"
	"		color.diffuse.a = 0.0;\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef TRANSMISSION_TEXTURE\n"
	"	float3 transmission = tex2D(TransmissionSampler0, vertex.uvtransmission.xy).xyz;\n"
	"	#ifdef TRANSMISSION_TEXTURE_MODULATE\n"
	"		transmission *= TransmissionModulateColor;\n"
	"	#endif\n"
	"	float tgray = rgb_to_gray(transmission);\n"
	"	color.diffuse.a = 1.0 - tgray;\n"
	"#endif\n"
	"#ifdef CREATE_SIMPLE_SHADOW\n"
	"	color.diffuse.rgb = float3(1.0,1.0,1.0);\n"
	"#endif // CREATE_SIMPLE_SHADOW\n"
	"	FinalColor = color.diffuse;\n"
	"#ifdef WRITING_SSAA_LINE_TARGET\n"
	"	#ifdef LINE\n"
	"		FinalLineColor = float4(1.0, 0.0, 0.0, 1.0);\n"
	"	#else\n"
	"		FinalLineColor = float4(0.0, 0.0, 0.0, 1.0);\n"
	"	#endif\n"
	"#endif\n"
	"#endif // ndef CREATE_SHADOW_MAP\n"
	"}\n"
; 


char const * const h3d_post_add_8 =
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D Sampler0Texture;\n"
	"uniform Texture2D Sampler1Texture;\n"
	"uniform Texture2D Sampler2Texture;\n"
	"uniform Texture2D Sampler3Texture;\n"
	"uniform Texture2D Sampler4Texture;\n"
	"uniform Texture2D Sampler5Texture;\n"
	"uniform Texture2D Sampler6Texture;\n"
	"uniform Texture2D Sampler7Texture;\n"
	"uniform sampler2D Sampler0;\n"
	"uniform sampler2D Sampler1;\n"
	"uniform sampler2D Sampler2;\n"
	"uniform sampler2D Sampler3;\n"
	"uniform sampler2D Sampler4;\n"
	"uniform sampler2D Sampler5;\n"
	"uniform sampler2D Sampler6;\n"
	"uniform sampler2D Sampler7;\n"
	"uniform float4 Kernel[NUM_TAPS];\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	result += Kernel[0] * htex2d( Sampler0, in_uv.xy );\n"
	"	result += Kernel[1] * htex2d( Sampler1, in_uv.xy );\n"
	"	result += Kernel[2] * htex2d( Sampler2, in_uv.xy );\n"
	"	result += Kernel[3] * htex2d( Sampler3, in_uv.xy );\n"
	"	result += Kernel[4] * htex2d( Sampler4, in_uv.xy );\n"
	"	result += Kernel[5] * htex2d( Sampler5, in_uv.xy );\n"
	"	result += Kernel[6] * htex2d( Sampler6, in_uv.xy );\n"
	"	result += Kernel[7] * htex2d( Sampler7, in_uv.xy );\n"
	"}\n"
; 


char const * const h3d_post_ambient_occlusion =
	"#define RATIO 40.0\n"
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform float2 OneOverTexelSize;\n"
	"uniform float Strength;\n"
	"uniform float DepthScale;\n"
	"uniform float MaxRadius;\n"
	"uniform Texture2D JitterTexture reg(t1);\n"
	"uniform sampler2D Jitter reg(s1);\n"
	"uniform float2 JitterScale;\n"
	"uniform float4 Taps[16];\n"
	"uniform float4 Weights[8];\n"
	"uniform float OutputScale;\n"
	"float4 dz_weight( float4 dz )\n"
	"{\n"
	"	return dz / (1.0 + RATIO * dz * dz);\n"
	"}\n"
	"#if QUALITY > 0\n"
	"#ifdef htex2d\n"
	"#undef htex2d\n"
	"#endif\n"
	"#define htex2d(sampler, uv) htex2dlod(sampler, float4((uv).x,(uv).y,0.0,0.0))\n"
	"#endif\n"
	"#define ZERO float4(0.0, 0.0, 0.0, 0.0)\n"
	"#if QUALITY > 0\n"
	"#define SUM_WEIGHTS(a, b) (a + b)\n"
	"#else\n"
	"#define SUM_WEIGHTS(a, b) (2.0 * a)\n"
	"#endif\n"
	"#define JITTER\n"
	"#ifndef JITTER\n"
	"#define JITTER_OFFSET(offset) offset *= r\n"
	"#else\n"
	"#define JITTER_OFFSET(offset) offset = jitter_acac * offset.xxzz + jitter_bdbd * offset.yyww\n"
	"#endif\n"
	"float4 FOUR_SAMPLES(const int which, const float2 in_uv, const float4 jitter_acac, const float4 jitter_bdbd, const float4 z)\n"
	"{	\n"
	"	float4 samples0, samples1;\n"
	"	float4 offset01 = Taps[which*2+0]; \n"
	"	float4 offset23 = Taps[which*2+1]; \n"
	"	JITTER_OFFSET(offset01); \n"
	"	JITTER_OFFSET(offset23); \n"
	"	float4 uv01 = in_uv.xyxy + offset01; \n"
	"	float4 uv23 = in_uv.xyxy + offset23; \n"
	"	samples0.x = unpack_rgba(htex2d(Depth, uv01.xy)); \n"
	"	samples0.y = unpack_rgba(htex2d(Depth, uv01.zw)); \n"
	"	samples0.z = unpack_rgba(htex2d(Depth, uv23.xy)); \n"
	"	samples0.w = unpack_rgba(htex2d(Depth, uv23.zw)); \n"
	"	uv01 = in_uv.xyxy - offset01; \n"
	"	uv23 = in_uv.xyxy - offset23; \n"
	"	samples1.x = unpack_rgba(htex2d(Depth, uv01.xy)); \n"
	"	samples1.y = unpack_rgba(htex2d(Depth, uv01.zw)); \n"
	"	samples1.z = unpack_rgba(htex2d(Depth, uv23.xy)); \n"
	"	samples1.w = unpack_rgba(htex2d(Depth, uv23.zw)); \n"
	"	float4 dz0 = z + samples0 * -Strength; \n"
	"	float4 dz1 = z + samples1 * -Strength; \n"
	"	float4 os0 = dz_weight( dz0 ); \n"
	"	float4 os1 = dz_weight( dz1 ); \n"
	"	float4 masks = float4(greaterThan(dz0, ZERO)) * float4(greaterThan(dz1, ZERO)); \n"
	"	float4 o = Weights[which] * SUM_WEIGHTS(os0, os1); \n"
	"	float4 occlusion = o * masks;\n"
	"	return occlusion;\n"
	"}\n"
	"float3 pack_rgb(float value)\n"
	"{\n"
	"	const float3 shift = float3(1.0, 255.0, 255.0*255.0); \n"
	"	const float3 mask = float3(1.0/255.0, 1.0/255.0, 0.0); \n"
	"	float3 packed_rgb = frac(value * shift);\n"
	"	return packed_rgb - mask * packed_rgb.yzz; \n"
	"}\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float sharp = unpack_rgba(htex2d(Depth, in_uv));\n"
	"#if (QUALITY > 0) && (SHADER_MODEL > 2)\n"
	"H3D_BRANCH_HINT\n"
	"#endif\n"
	"	if ( sharp >= 254.0/255.0 )\n"
	"	{\n"
	"		result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"		return;\n"
	"	}\n"
	"	const float4 z = float4(sharp, sharp, sharp, sharp) * Strength;\n"
	"	float r_value = min(MaxRadius, max(1.0, DepthScale * sharp));\n"
	"	const float4 r = float4(r_value, r_value, r_value, r_value) * OneOverTexelSize.xyxy;\n"
	"	float4 jitter = htex2d(Jitter, in_uv * JitterScale) * 2.0 - 1.0;\n"
	"#if !defined(DX9) || !defined(DX11)\n"
	"	jitter = jitter.wxyz;\n"
	"#endif \n"
	"	const float4 jitter_acac = jitter.xyxy * r;\n"
	"	const float4 jitter_bdbd = jitter.zwzw * r;\n"
	"	float4 occlusions = float4(0.0,0.0,0.0,0.0);\n"
	"	occlusions += FOUR_SAMPLES(0, in_uv, jitter_acac, jitter_bdbd, z);\n"
	"#if QUALITY > 0\n"
	"	occlusions += FOUR_SAMPLES(1, in_uv, jitter_acac, jitter_bdbd, z);\n"
	"#if QUALITY > 1\n"
	"	occlusions += FOUR_SAMPLES(2, in_uv, jitter_acac, jitter_bdbd, z);\n"
	"	occlusions += FOUR_SAMPLES(3, in_uv, jitter_acac, jitter_bdbd, z);\n"
	"#endif\n"
	"#endif\n"
	"	const float scale = OutputScale;\n"
	"	float occlusion = dot(occlusions, float4(scale, scale, scale, scale));\n"
	"	result.rgb = pack_rgb(sharp);\n"
	"	result.a = occlusion;\n"
	"}\n"
; 


char const * const h3d_post_ambient_occlusion_filter =
	"uniform Texture2D SamplerTexture reg(t0);\n"
	"uniform sampler2D Sampler reg(s0);\n"
	"uniform const float4 Taps[4];\n"
	"uniform const float4 Weights[2];\n"
	"uniform const float Tolerance;\n"
	"float unpack_rgb(const float3 value)\n"
	"{\n"
	"	const float3 shift = float3(1.0, 1.0/255.0, 1.0/(255.0*255.0));\n"
	"	return dot(value, shift);\n"
	"}\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	result = htex2d(Sampler, in_uv);\n"
	"	float centre_z = unpack_rgb(result.rgb);\n"
	"	const float CENTRE_WEIGHT = (20.0/64.0);\n"
	"	result.a *= CENTRE_WEIGHT;\n"
	"	float4 uv = in_uv.xyxy + Taps[0];\n"
	"	float4 sample0 = htex2d(Sampler, uv.xy);\n"
	"	float4 sample1 = htex2d(Sampler, uv.zw);\n"
	"	uv = in_uv.xyxy + Taps[1];\n"
	"	float4 sample2 = htex2d(Sampler, uv.xy);\n"
	"	float4 sample3 = htex2d(Sampler, uv.zw);\n"
	"	float4 z;\n"
	"	float4 a;\n"
	"	z.x = unpack_rgb(sample0.rgb);\n"
	"	a.x = sample0.a;	\n"
	"	z.y = unpack_rgb(sample1.rgb);\n"
	"	a.y = sample1.a;	\n"
	"	z.z = unpack_rgb(sample2.rgb);\n"
	"	a.z = sample2.a;	\n"
	"	z.w = unpack_rgb(sample3.rgb);\n"
	"	a.w = sample3.a;	\n"
	"	float4 w = saturate( 1.0 - abs(z - float4(centre_z,centre_z,centre_z,centre_z)) * Tolerance );\n"
	"#if (SHADER_MODEL > 2)\n"
	"#endif // SHADER_MODEL > 2\n"
	"	w *= Weights[0];\n"
	"	float4 total_w = w;\n"
	"	float4 total_a = a * w;\n"
	"	uv = in_uv.xyxy + Taps[2];\n"
	"	sample0 = htex2d(Sampler, uv.xy);\n"
	"	sample1 = htex2d(Sampler, uv.zw);\n"
	"	z.x = unpack_rgb(sample0.rgb);\n"
	"	a.x = sample0.a;	\n"
	"	z.y = unpack_rgb(sample1.rgb);\n"
	"	a.y = sample1.a;	\n"
	"	w.xy = saturate( 1.0 - abs(z.xy - float2(centre_z,centre_z)) * Tolerance );\n"
	"#if (SHADER_MODEL > 2)\n"
	"#endif // SHADER_MODEL > 2\n"
	"	w.xy *= Weights[1].xy;\n"
	"	total_w.xy += w.xy;\n"
	"	total_a.xy += a.xy * w.xy;\n"
	"	result.a += dot(total_a, float4(1.0,1.0,1.0,1.0));\n"
	"	result.a /= CENTRE_WEIGHT + dot(total_w, float4(1.0,1.0,1.0,1.0));\n"
	"} \n"
; 


char const * const h3d_post_apply_reflection =
	"uniform Texture2D ReflectionSamplerTexture;\n"
	"uniform sampler2D ReflectionSampler;\n"
	"uniform float Opacity;\n"
	"#ifdef REFLECTION_BUMPMAP\n"
	"uniform Texture2D NormalMapSamplerTexture;\n"
	"uniform sampler2D NormalMapSampler;\n"
	"uniform float BumpSize;\n"
	"uniform float BumpStrength;\n"
	"#endif // REFLECTION_BUMPMAP\n"
	"void post_pixel(\n"
	"	float2 in_uv0,\n"
	"#ifdef TEXCOORD_INPUT_2\n"
	"	float2 in_uv1,\n"
	"#endif\n"
	"	out float4 result)\n"
	"{\n"
	"#ifdef REFLECTION_BUMPMAP\n"
	"	float2 uv = 0.5 + 0.5 * (in_uv0.xy/in_uv0.w);\n"
	"	float2 offset = htex2d(NormalMapSampler, in_uv1/BumpSize).rg * 2.0 - 1.0;\n"
	"	uv += offset * BumpStrength;\n"
	"#else\n"
	"	float2 uv = in_uv0.xy;\n"
	"#endif // REFLECTION_BUMPMAP\n"
	"	float4 reflection = htex2d( ReflectionSampler, uv );\n"
	"	result = reflection * Opacity;\n"
	"} \n"
; 


char const * const h3d_post_capture_bloom =
	"uniform Texture2D SceneTexture reg(t0);\n"
	"uniform sampler2D Scene reg(s0);\n"
	"#define TINT float4(1.0,0.7,0.4,1.0);\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float4 pixel = htex2d( Scene, in_uv );\n"
	"	pixel.a = (pixel.a - (1.0/255.0)) * (255.0/254.0);\n"
	"	float bloom = 2.0 * pixel.a;\n"
	"	float star = 2.0 * pixel.a - 1.0;\n"
	"	pixel.rgb *= bloom;\n"
	"	pixel.a = star;\n"
	"	result = pixel * TINT;\n"
	"} \n"
; 


char const * const h3d_post_capture_depth =
	"uniform Texture2D DepthTexture;\n"
	"uniform sampler2D Depth;\n"
	"uniform Texture2D PatternTexture;\n"
	"uniform sampler2D Pattern;\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float4 pattern = htex2d(Pattern, in_uv.xy);\n"
	"	float2 uv;\n"
	"	float2 reconstruct = float2(255.0/256.0, 1.0/256.0);\n"
	"	uv.x = dot(pattern.xy, reconstruct);\n"
	"	uv.y = dot(pattern.zw, reconstruct);\n"
	"	result = htex2d(Depth, uv);\n"
	"} \n"
; 


char const * const h3d_post_clear_alpha =
	"uniform Texture2D SceneTexture reg(t0);\n"
	"uniform sampler2D Scene reg(s0);\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float4 pixel = htex2d( Scene, in_uv );\n"
	"	result = float4(pixel.r, pixel.g, pixel.b, 0.0);\n"
	"} \n"
; 


char const * const h3d_post_copy =
	"uniform Texture2D SamplerTexture;\n"
	"uniform sampler2D Sampler;\n"
	"uniform float4 ModulationColor;\n"
	"void post_pixel(\n"
	"	float2 uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	result = ModulationColor * htex2d( Sampler, uv.xy );\n"
	"#ifdef DIVIDE_ALPHA\n"
	"	if (result.a > 0.0)\n"
	"		result.rgb /= result.a;\n"
	"#endif\n"
	"} \n"
; 


char const * const h3d_post_depth_filter =
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D SamplerTexture reg(t0);\n"
	"uniform sampler2D Sampler reg(s0);\n"
	"uniform Texture2D DepthTexture reg(t1);\n"
	"uniform sampler2D Depth reg(s1);\n"
	"uniform const float4 Kernel[NUM_TAPS];\n"
	"uniform const float Tolerance;\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float centre_depth = unpack_rgba(htex2d(Depth, in_uv));\n"
	"	float total_weight = 0.0;\n"
	"	result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	for ( int i = 0; i < NUM_TAPS; ++i )\n"
	"	{\n"
	"		float2 uv = in_uv + Kernel[i].xy;\n"
	"		float depth = unpack_rgba(htex2d(Depth, uv));\n"
	"		float w = saturate( 1.0 - abs(depth - centre_depth) * Tolerance );\n"
	"#if (SHADER_MODEL > 2)\n"
	"		w = smoothstep(0.0, 1.0, w);\n"
	"#endif // SHADER_MODEL > 2\n"
	"		float4 s = htex2d(Sampler, uv);\n"
	"		result += Kernel[i].w * s * w;\n"
	"		total_weight += Kernel[i].w * w; \n"
	"	}\n"
	"	result /= total_weight;\n"
	"} \n"
; 


char const * const h3d_post_depth_of_field =
	"uniform Texture2D SceneTexture reg(t0);\n"
	"uniform sampler2D Scene reg(s0);\n"
	"uniform float2 OneOverTexelSize;\n"
	"uniform float MaxRadius;\n"
	"#define Kernel32_Size 32\n"
	"#ifdef OPENGL2\n"
	"#ifdef const\n"
	"#undef const\n"
	"#endif\n"
	"#endif\n"
	"STATIC_ARRAY_BEGIN(Kernel32_Taps, float4, Kernel32_Size/2)\n"
	"	float4(-0.65229499,0.026542500,-0.26740900,-0.74962401),\n"
	"	float4(-0.13066600,-0.024220601,0.59062499,-0.62143099),\n"
	"	float4(0.72352201,0.38820800,0.053857900,0.83063298),\n"
	"	float4(0.74592000,0.025707399,-0.12658300,-0.57638103),\n"
	"	float4(0.60920501,-0.14094000,-0.31015599,0.41454300),\n"
	"	float4(-0.70582801,-0.0084850304,-0.45170701,0.54161900),\n"
	"	float4(0.16703700,0.11802500,0.42760801,-0.012630700),\n"
	"	float4(0.032751001,0.43645099,-0.16200900,-0.11899800),\n"
	"	float4(-0.79991800,-0.58339602,0.46310601,-0.63896102),\n"
	"	float4(-0.35023299,0.40390000,0.21136899,0.00094752799),\n"
	"	float4(0.50501800,0.63320202,-0.62858403,-0.49965000),\n"
	"	float4(-0.070600897,0.84065801,-0.71336502,0.19370700),\n"
	"	float4(0.18814000,-0.54516101,-0.094322897,-0.60351199),\n"
	"	float4(0.25596899,0.52600801,0.58789700,0.46666300),\n"
	"	float4(0.99604899,0.080805399,-0.40914601,-0.23615099),\n"
	"	float4(0.19501600,-0.97045398,-0.88026899,0.40237501)\n"
	"STATIC_ARRAY_END;\n"
	"#ifdef OPENGL2\n"
	"#define const\n"
	"#endif\n"
	"#if (QUALITY > 1)\n"
	"#define TAP_COUNT 32\n"
	"#elif (QUALITY > 0)\n"
	"#define TAP_COUNT 16\n"
	"#else\n"
	"#define TAP_COUNT 8\n"
	"#endif\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float4 accumulator = htex2d(Scene, in_uv);\n"
	"	float4 tap_scale = OneOverTexelSize.xyxy * accumulator.a;\n"
	"	accumulator.a = 1.0;\n"
	"	for ( int i = 0; i < TAP_COUNT/2; ++i )\n"
	"	{\n"
	"		float4 uv = in_uv.xyxy + Kernel32_Taps[i] * tap_scale;\n"
	"		float4 s = htex2d(Scene, uv.xy);\n"
	"		s.rgb *= s.a;\n"
	"		accumulator += s;\n"
	"		s = htex2d(Scene, uv.zw);\n"
	"		s.rgb *= s.a;\n"
	"		accumulator += s;\n"
	"	}\n"
	"	result = accumulator / accumulator.a;\n"
	"} \n"
; 


char const * const h3d_post_depth_to_focus =
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform float DepthScale;\n"
	"uniform float2 ScaleAndBias;\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float raw_z = unpack_rgba(htex2d(Depth, in_uv));\n"
	"	float z = DepthScale * raw_z;\n"
	"	float focus = saturate(z * ScaleAndBias.x + ScaleAndBias.y);\n"
	"	result.rga = float3(focus, focus, focus);\n"
	"	result.b = float(raw_z != 1.0);\n"
	"	result.rga *= result.b;\n"
	"} \n"
; 


char const * const h3d_post_edl_blur =
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform Texture2D ColorTexture reg(t1);\n"
	"uniform sampler2D Color reg(s1);\n"
	"uniform float3 Taps[3];\n"
	"uniform float2 OneOverTexelSize;\n"
	"uniform float SigmaDepth;\n"
	"void post_pixel(float2 uv, out float4 result)\n"
	"{\n"
	"	float z0 = unpack_rgba(htex2d(Depth, uv));\n"
	"	if (z0 > 0.99)\n"
	"	{\n"
	"		result = htex2d(Color, uv);\n"
	"		return;\n"
	"	}\n"
	"	float3 sum = float3(0.0, 0.0, 0.0);\n"
	"	float wsum = 0.0;\n"
	"	for (int i = 0; i < 3; ++i)\n"
	"	{\n"
	"		float2 coord = uv + Taps[i].xy * OneOverTexelSize;\n"
	"		float fi = Taps[i].z;\n"
	"		float3 color = htex2d(Color, coord).rgb;\n"
	"		float zi = unpack_rgba(htex2d(Depth, coord));\n"
	"		float dz = 10000.0 * (z0 - zi) / SigmaDepth;\n"
	"		fi *= exp(-dz*dz / 2.0);\n"
	"		sum += fi * color;\n"
	"		wsum += fi;\n"
	"	}\n"
	"	result = float4(sum / wsum, 1.0);\n"
	"} \n"
; 


char const * const h3d_post_edl_mix =
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform Texture2D ShadeFullTexture reg(t1);\n"
	"uniform sampler2D ShadeFull reg(s1);\n"
	"uniform Texture2D ShadeHalfTexture reg(t2);\n"
	"uniform sampler2D ShadeHalf reg(s2);\n"
	"uniform Texture2D ShadeQuarterTexture reg(t3);\n"
	"uniform sampler2D ShadeQuarter reg(s3);\n"
	"uniform float		A0;\n"
	"uniform float		A1;\n"
	"uniform float		A2;\n"
	"uniform int			absorb;\n"
	"void post_pixel(float2 uv, out float4 result)\n"
	"{\n"
	"	float d = htex2d(Depth, uv).r;\n"
	"	if (d > 0.99)\n"
	"	{\n"
	"		result.rgb = htex2d(ShadeFull, uv).rgb;\n"
	"		result.a = 1.0;\n"
	"		return;\n"
	"	}\n"
	"	float3 C;\n"
	"	if (d > 0.99 && absorb == 1)\n"
	"	{\n"
	"		C = htex2d(ShadeFull, uv).rgb;\n"
	"	}\n"
	"	else\n"
	"	{\n"
	"		float3 C1 = htex2d(ShadeFull, uv).rgb;\n"
	"		float3 C2 = htex2d(ShadeHalf, uv).rgb;\n"
	"		float3 C4 = htex2d(ShadeQuarter, uv).rgb;\n"
	"		C = (A0*C1 + A1*C2 + A2*C4) / (A0 + A1 + A2);\n"
	"	}\n"
	"	result = float4(C.x, C.y, C.z, 1.0);\n"
	"} \n"
; 


char const * const h3d_post_edl_shade =
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform float2 Taps[8];\n"
	"uniform float2 OneOverTexelSize;\n"
	"uniform float3	LightDir;\n"
	"uniform float	Pix_scale;		    //	(relative) pixel scale in image\n"
	"uniform float	DepthScale;\n"
	"uniform float	ExpScale;		//	exponential scale factor (for computed AO\n"
	"uniform float	Tolerance;\n"
	"#define	Zoom 1.41				// image display zoom (so as to always use - approximately - the same pixels)\n"
	"#define	Zm 0.0					//	minimal depth in image\n"
	"#define ZM 1.0					//	maximal depth in image\n"
	"float ztransform(float z)\n"
	"{\n"
	"	return 1.0 - z;// clamp((z - ZM) / (Zm - ZM), 0.0, 1.0);\n"
	"}\n"
	"float computeObscurance(float2 uv, float depth, float scale)\n"
	"{\n"
	"	float4 P = float4(LightDir.xyz, -dot(LightDir.xyz, float3(0.0, 0.0, depth)));\n"
	"	float sum = 0.0;\n"
	"	float2 r = scale * Zoom * OneOverTexelSize;\n"
	"	for (int i = 0; i < 8; ++i)	\n"
	"	{\n"
	"		float2 N_rel_pos = Taps[i] * r;			// neighbor relative position\n"
	"		float2 N_abs_pos = uv + N_rel_pos;		// neighbor absolute position\n"
	"		float N_depth = unpack_rgba(htex2d(Depth, N_abs_pos));\n"
	"		float Zn = DepthScale * ztransform(N_depth);\n"
	"		float dz = Zn - depth;\n"
	"		float x = sign(Tolerance - dz);\n"
	"		float Znp = x * dot(float4(N_rel_pos, Zn, 1.0), P);	// depth of the in-plane neighbor\n"
	"		sum += max(Znp, 0.0);\n"
	"	}\n"
	"	sum /= scale;\n"
	"	return	sum;\n"
	"}\n"
	"void post_pixel(float2 uv, out float4 result)\n"
	"{\n"
	"	float depth = unpack_rgba(htex2d(Depth, uv));	\n"
	"	if (depth >= 254.0 / 255.0)\n"
	"	{\n"
	"		discard;\n"
	"	}\n"
	"	depth = DepthScale * ztransform(depth);\n"
	"	float f = computeObscurance(uv, depth, Pix_scale);\n"
	"	f = exp(-ExpScale*f);\n"
	"	result = float4(0.0, 0.0, 0.0, f);\n"
	"} \n"
; 


char const * const h3d_post_external_silhouette =
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform float2 OneOverTexelSize;\n"
	"uniform float2 ToleranceScaleAndBias;\n"
	"uniform float2 Taps[4];\n"
	"uniform float3 EdgeColor;\n"
	"void post_pixel(\n"
	"	float2 uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float4 samples;\n"
	"	samples.x = unpack_rgba(htex2d( Depth, uv + Taps[0] * OneOverTexelSize ));\n"
	"	samples.y = unpack_rgba(htex2d( Depth, uv + Taps[1] * OneOverTexelSize ));\n"
	"	samples.z = unpack_rgba(htex2d( Depth, uv + Taps[2] * OneOverTexelSize ));\n"
	"	samples.w = unpack_rgba(htex2d( Depth, uv + Taps[3] * OneOverTexelSize ));\n"
	"#define ONE float4(1.0,1.0,1.0,1.0)\n"
	"#define THRESHOLD float4(254.0/255.0,254.0/255.0,254.0/255.0,254.0/255.0)\n"
	"#if defined(DX9) || defined(DX11)\n"
	"	float disable = dot(ONE, float4(samples == ONE));\n"
	"	float back = dot(ONE, float4(samples >= THRESHOLD));\n"
	"#else\n"
	"	float disable = dot(ONE, float4(equal(samples, ONE)));\n"
	"	float back = dot(ONE, float4(greaterThanEqual(samples, THRESHOLD)));\n"
	"#endif\n"
	"	float silhouette = 0.0;\n"
	"	if ( disable == 0.0 && back > 0.0 && back < 4.0 )\n"
	"		silhouette = 1.0;\n"
	"	result = float4(EdgeColor.r, EdgeColor.g, EdgeColor.b, silhouette);\n"
	"} \n"
; 


char const * const h3d_post_fatten_pixels =
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D LineSamplerTexture;\n"
	"uniform sampler2D LineSampler;\n"
	"uniform Texture2D SceneSamplerTexture;\n"
	"uniform sampler2D SceneSampler;\n"
	"uniform float4 Kernel[NUM_TAPS];\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	result = float4(0,0,0,0);\n"
	"	float4 tap[NUM_TAPS];\n"
	"	float4 line_color[NUM_TAPS];\n"
	"	float pixels_found = 0.0;\n"
	"	for (int i = 0; i < NUM_TAPS; i++) {\n"
	"		float2 uv = in_uv + Kernel[i].xy;\n"
	"		tap[i] = htex2d(LineSampler, uv);\n"
	"		line_color[i] = htex2d(SceneSampler, uv);\n"
	"		if (tap[i].r > 0.9) {\n"
	"			pixels_found += 1.0;\n"
	"			result.rgb += line_color[i].rgb;\n"
	"		}\n"
	"	}\n"
	"	if (pixels_found > 0.0) {\n"
	"		result.rgb /= pixels_found;\n"
	"		result.a = 1.0 - pow(0.5,pixels_found);\n"
	"	}\n"
	"	else {\n"
	"		result = tex2D(SceneSampler, in_uv);\n"
	"		result.a = 0.0;\n"
	"	}\n"
	"}\n"
; 


char const * const h3d_post_filter =
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D SamplerTexture;\n"
	"uniform sampler2D Sampler;\n"
	"uniform float4 Kernel[NUM_TAPS];\n"
	"void post_pixel(\n"
	"	float2 uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	for ( int i = 0; i < NUM_TAPS; ++i )\n"
	"	{\n"
	"		result += Kernel[i].w * htex2d( Sampler, uv + Kernel[i].xy );\n"
	"	}\n"
	"} \n"
; 


char const * const h3d_post_filter_12 =
	"#define NUM_TAPS 12\n"
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D SamplerTexture;\n"
	"uniform sampler2D Sampler;\n"
	"uniform float4 Kernel[NUM_TAPS];\n"
	"float4 post_pixel(\n"
	"	float2 uv)\n"
	"{\n"
	"	float4 result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	for ( int i = 0; i < NUM_TAPS; ++i )\n"
	"	{\n"
	"		result += Kernel[i].w * htex2d( Sampler, uv + Kernel[i].xy );\n"
	"	}\n"
	"	return result;\n"
	"} \n"
; 


char const * const h3d_post_filter_16 =
	"#define NUM_TAPS 16\n"
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D SamplerTexture;\n"
	"uniform sampler2D Sampler;\n"
	"uniform float4 Kernel[NUM_TAPS];\n"
	"float4 post_pixel(\n"
	"	float2 uv)\n"
	"{\n"
	"	float4 result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	for ( int i = 0; i < NUM_TAPS; ++i )\n"
	"	{\n"
	"		result += Kernel[i].w * htex2d( Sampler, uv + Kernel[i].xy );\n"
	"	}\n"
	"	return result;\n"
	"} \n"
; 


char const * const h3d_post_filter_4 =
	"#define NUM_TAPS 4\n"
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D SamplerTexture;\n"
	"uniform sampler2D Sampler;\n"
	"uniform float4 Kernel[NUM_TAPS];\n"
	"float4 post_pixel(\n"
	"	float2 uv)\n"
	"{\n"
	"	float4 result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	for ( int i = 0; i < NUM_TAPS; ++i )\n"
	"	{\n"
	"		result += Kernel[i].w * htex2d( Sampler, uv + Kernel[i].xy );\n"
	"	}\n"
	"	return result;\n"
	"} \n"
; 


char const * const h3d_post_filter_8 =
	"#define NUM_TAPS 8\n"
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D SamplerTexture;\n"
	"uniform sampler2D Sampler;\n"
	"uniform float4 Kernel[NUM_TAPS];\n"
	"float4 post_pixel(\n"
	"	float2 uv)\n"
	"{\n"
	"	float4 result = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	for ( int i = 0; i < NUM_TAPS; ++i )\n"
	"	{\n"
	"		result += Kernel[i].w * htex2d( Sampler, uv + Kernel[i].xy );\n"
	"	}\n"
	"	return result;\n"
	"} \n"
; 


char const * const h3d_post_focus_filter =
	"#ifndef NUM_TAPS\n"
	"#error NUM_TAPS must be defined to use this shader!\n"
	"#endif // NUM_TAPS\n"
	"uniform Texture2D SamplerTexture reg(t0);\n"
	"uniform sampler2D Sampler reg(s0);\n"
	"uniform const float4 Kernel[NUM_TAPS];\n"
	"#define CENTRE_WEIGHT (1.414*112.0/256.0)\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float4 centre = htex2d(Sampler, in_uv);\n"
	"	float total_weight = CENTRE_WEIGHT;\n"
	"	result = centre * CENTRE_WEIGHT;\n"
	"	for ( int i = 0; i < NUM_TAPS; ++i )\n"
	"	{\n"
	"		float2 uv = in_uv + Kernel[i].xy;\n"
	"		float4 s = htex2d(Sampler, uv);\n"
	"		result += Kernel[i].w * s * centre.b;\n"
	"		total_weight += Kernel[i].w;\n"
	"	}\n"
	"	result /= total_weight;\n"
	"	result.b = centre.b;\n"
	"} \n"
; 


char const * const h3d_post_image_block =
	"uniform Texture2D ColorTexture reg(t0);\n"
	"uniform sampler2D Color reg(s0);\n"
	"uniform Texture2D DepthTexture reg(t1);\n"
	"uniform sampler2D Depth reg(s1);\n"
	"#define DEPTH_RANGE\n"
	"#ifdef DEPTH_RANGE\n"
	"uniform float2 DepthRange;\n"
	"#endif\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 out_color,\n"
	"	out float out_depth)\n"
	"{\n"
	"	float4 color = htex2d(Color, in_uv);\n"
	"#ifdef NEED_SWIZZLE\n"
	"	out_color = color.bgra;\n"
	"#else\n"
	"	out_color = color;\n"
	"#endif\n"
	"	float depth = htex2d(Depth, in_uv).r;\n"
	"#ifdef DEPTH_RANGE\n"
	"	depth = DepthRange.x + depth * (DepthRange.y - DepthRange.x);\n"
	"#endif\n"
	"	out_depth = depth;\n"
	"} \n"
; 


char const * const h3d_post_mask_bloom =
	"uniform Texture2D SceneTexture reg(t0);\n"
	"uniform sampler2D Scene reg(s0);\n"
	"void post_pixel(\n"
	"	float2 in_uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	float4 pixel = htex2d( Scene, in_uv );\n"
	"	float mask = float(pixel.a != 0.0);\n"
	"	result = float4(mask, mask, mask, mask);\n"
	"} \n"
; 


char const * const h3d_post_reproject =
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform Texture2D SceneTexture reg(t1);\n"
	"uniform sampler2D Scene reg(s1);\n"
	"uniform float3 EyeDir;\n"
	"#define ReliefMapDepth 1.0\n"
	"void setup_ray(in float2 uv,out float3 p,out float3 v)\n"
	"{\n"
	"	p = float3(uv,0.0);\n"
	"	v = normalize(EyeDir);\n"
	"	v.z = abs(v.z);\n"
	"	v.xy *= ReliefMapDepth;\n"
	"}\n"
	"void ray_intersect_relief(\n"
	"	sampler2D relief_map,\n"
	"	inout float3 p,\n"
	"	inout float3 v)\n"
	"{\n"
	"	const int num_steps_lin=2;\n"
	"	const int num_steps_bin=1;\n"
	"	v /= v.z*num_steps_lin;\n"
	"	int i;\n"
	"	for( i=0;i<num_steps_lin;i++ )\n"
	"	{\n"
	"		float4 tex = htex2d(relief_map, p.xy);\n"
	"		if (p.z<tex.x)\n"
	"			p+=v;\n"
	"	}\n"
	"	for( i=0;i<num_steps_bin;i++ )\n"
	"	{\n"
	"		v *= 0.5;\n"
	"		float4 tex = htex2d(relief_map, p.xy);\n"
	"		if (p.z<tex.x)\n"
	"			p+=v;\n"
	"		else\n"
	"			p-=v;\n"
	"	}\n"
	"}\n"
	"void post_pixel( \n"
	"	float2 in_uv,\n"
	"	out float4 color,\n"
	"	out float depth)\n"
	"{\n"
	"	float3 p,v;\n"
	"	setup_ray(in_uv,p,v);\n"
	"	ray_intersect_relief(Depth,p.xyz,v);\n"
	"	color = htex2d(Scene, p.xy);\n"
	"	depth = htex2d(Depth, p.xy).r;\n"
	"} \n"
; 


char const * const h3d_post_silhouette =
	"uniform Texture2D DepthTexture reg(t0);\n"
	"uniform sampler2D Depth reg(s0);\n"
	"uniform float2 OneOverTexelSize;\n"
	"uniform float2 ToleranceScaleAndBias;\n"
	"uniform float2 Taps[4];\n"
	"uniform float DepthScale;\n"
	"uniform float3 EdgeColor;\n"
	"#define ONE float4(1.0, 1.0, 1.0, 1.0)\n"
	"void post_pixel(\n"
	"	float2 uv,\n"
	"	out float4 result)\n"
	"{\n"
	"	const float sharp = unpack_rgba(htex2d(Depth, uv));\n"
	"	float silhouette = 0.0;\n"
	"	if (sharp != 1.0)\n"
	"	{\n"
	"		float4 samples;\n"
	"		samples.x = unpack_rgba(htex2d( Depth, uv + Taps[0] * OneOverTexelSize ));\n"
	"		samples.y = unpack_rgba(htex2d( Depth, uv + Taps[1] * OneOverTexelSize ));\n"
	"		samples.z = unpack_rgba(htex2d( Depth, uv + Taps[2] * OneOverTexelSize ));\n"
	"		samples.w = unpack_rgba(htex2d( Depth, uv + Taps[3] * OneOverTexelSize ));\n"
	"		float4 deltas = abs(samples - float4(sharp, sharp, sharp, sharp)) * DepthScale;\n"
	"		deltas *= float4(notEqual(samples, ONE));\n"
	"		float max_delta = max(max(deltas.x, deltas.y), max(deltas.z, deltas.w));\n"
	"		silhouette = saturate(max_delta * ToleranceScaleAndBias.x + ToleranceScaleAndBias.y);\n"
	"	}\n"
	"	result = float4(EdgeColor.r, EdgeColor.g, EdgeColor.b, silhouette);\n"
	"} \n"
; 


char const * const h3d_results =
	"#ifndef CREATE_SHADOW_MAP\n"
	"#ifdef PIXEL_SHADER\n"
	"struct pixel_input\n"
	"#else\n"
	"struct vertex_output\n"
	"#endif\n"
	"{\n"
	"	float4 position semantic(POSITION);\n"
	"	FLAT float4 material_color_and_specular_intensity semantic(COLOR0);\n"
	"	#ifdef EYE_POSITION_COORD\n"
	"		float4 eye_position semantic(EYE_POSITION_COORD_OUT);\n"
	"	#endif\n"
	"	#ifdef PER_PIXEL_LIGHTING\n"
	"		#ifndef SPHERE_MARKER\n"
	"			FLAT float3 eye_normal semantic(COLOR1);\n"
	"		#endif\n"
	"	#else\n"
	"		#ifdef HAS_LIGHTING\n"
	"		FLAT float4 diffuse_light_and_ambient_blend semantic(COLOR1);\n"
	"		#endif // HAS_LIGHTING\n"
	"	#endif // PER_PIXEL_LIGHTING\n"
	"	#ifdef TANGENT_COORD	\n"
	"		float4 eye_tangent semantic(TANGENT_COORD_OUT);\n"
	"	#endif\n"
	"	#ifdef HAS_ATMOSPHERIC_ATTENUATION\n"
	"		float fog semantic(FOG);\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_FINDICES\n"
	"		float2 findex semantic(FINDEX_COORD_OUT);\n"
	"	#endif\n"
	"	#if defined(WIDE_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"		float3 wide_line_offset semantic(OFFSET_COORD_OUT);\n"
	"	#endif\n"
	"	#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined (HAS_DEFINED_MATERIAL_GS) || defined(HAS_TEXTURE3D)\n"
	"		float4 uvst0 semantic(DIFFUSE_TEXTURE_INTERPOLATOR0_OUT);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		float2 uv0 semantic(DIFFUSE_TEXTURE_INTERPOLATOR0_OUT);\n"
	"	#endif\n"
	"	#ifndef SHARED_DIFFUSE_COORDS\n"
	"		#if (TEXTURE_COUNT > 1)\n"
	"			float2 uv1 semantic(DIFFUSE_TEXTURE_COORD1_OUT);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 2) \n"
	"			float2 uv2 semantic(DIFFUSE_TEXTURE_COORD2_OUT);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 3) \n"
	"			float2 uv3 semantic(DIFFUSE_TEXTURE_COORD3_OUT);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 4) \n"
	"			float2 uv4 semantic(DIFFUSE_TEXTURE_COORD4_OUT);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 5) \n"
	"			float2 uv5 semantic(DIFFUSE_TEXTURE_COORD5_OUT);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 6) \n"
	"			float2 uv6 semantic(DIFFUSE_TEXTURE_COORD6_OUT);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 7) \n"
	"			float2 uv7 semantic(DIFFUSE_TEXTURE_COORD7_OUT);\n"
	"		#endif\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_TEXTURE3D)\n"
	"		float2 buv0 semantic(BACK_DIFFUSE_TEXTURE_INTERPOLATOR0_OUT);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 1)\n"
	"		float2 buv1 semantic(BACK_DIFFUSE_TEXTURE_COORD1_OUT);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 2) \n"
	"		float2 buv2 semantic(BACK_DIFFUSE_TEXTURE_COORD2_OUT);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 3) \n"
	"		float2 buv3 semantic(BACK_DIFFUSE_TEXTURE_COORD3_OUT);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 4) \n"
	"		float2 buv4 semantic(BACK_DIFFUSE_TEXTURE_COORD4_OUT);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 5) \n"
	"		float2 buv5 semantic(BACK_DIFFUSE_TEXTURE_COORD5_OUT);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 6) \n"
	"		float2 buv6 semantic(BACK_DIFFUSE_TEXTURE_COORD6_OUT);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 7) \n"
	"		float2 buv7 semantic(BACK_DIFFUSE_TEXTURE_COORD7_OUT);\n"
	"	#endif\n"
	"	#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"		float2 marker_uv semantic(MARKER_TEXTURE_OUT);\n"
	"	#endif\n"
	"	#ifdef SPRITE_MARKER\n"
	"		float marker_size semantic(PSIZE);\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 0)\n"
	"		float4 uvsm0 semantic(SHADOW_MAP_COORD0_OUT);	\n"
	"	#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"		float4 screen_position semantic(SHADOW_MAP_JITTER_COORD_OUT);\n"
	"	#endif\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 1)\n"
	"		float4 uvsm1 semantic(SHADOW_MAP_COORD1_OUT);\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 2)\n"
	"		float4 uvsm2 semantic(SHADOW_MAP_COORD2_OUT);\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 3)\n"
	"		float4 uvsm3 semantic(SHADOW_MAP_COORD3_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 0)\n"
	"		float4 uvcp0 semantic(CUTTING_PLANE_COORD0_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 4)\n"
	"		float4 uvcp1 semantic(CUTTING_PLANE_COORD1_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 8)\n"
	"		float4 uvcp2 semantic(CUTTING_PLANE_COORD2_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 12)\n"
	"		float4 uvcp3 semantic(CUTTING_PLANE_COORD3_OUT);\n"
	"	#endif\n"
	"	#ifdef ENVIRONMENT_TEXTURE \n"
	"		#if !defined(CUBE_ENVIRONMENT_MAP) || !defined(PER_PIXEL_LIGHTING)\n"
	"			float3 uvenv semantic(ENVIRONMENT_TEXTURE_OUT);\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef MIRROR_TEXTURE\n"
	"		float2 uvmirror semantic(MIRROR_TEXTURE_OUT);\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		float2 uvspec semantic(SPECULAR_TEXTURE_OUT);\n"
	"	#endif\n"
	"	#ifdef BUMP_TEXTURE\n"
	"		float2 uvbump semantic(BUMP_TEXTURE_OUT);\n"
	"	#endif \n"
	"	#ifdef TRANSMISSION_TEXTURE\n"
	"		float2 uvtransmission semantic(TRANSMISSION_TEXTURE_OUT);\n"
	"	#endif\n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		float2 uvemission semantic(EMISSION_TEXTURE_OUT);\n"
	"	#endif\n"
	"	#if defined(DEPTH_PEELING) || defined(DEPTH_WRITING)\n"
	"		float4 peel_position semantic(DEPTH_PEELING_POSITION_COORD_OUT);\n"
	"	#endif\n"
	"	#ifdef HAS_FACE_PATTERN\n"
	"		float4 uvzwfp semantic(FACE_PATTERN_COORD_OUT);\n"
	"	#endif\n"
	"	#ifdef HAS_LINE_PATTERN\n"
	"		float4 uvlp semantic(LINE_PATTERN_COORD_OUT);\n"
	"	#endif\n"
	"	#if defined(HAS_GEOMETRY_SHADER) && !defined(PIXEL_SHADER)\n"
	"		#ifdef GS_ELLIPTICAL_ARC\n"
	"			float arc_param semantic(GS_ELLIPTICAL_ARC_COORD_OUT);\n"
	"		#endif\n"
	"		uint InstanceID semantic(SV_InstanceID);\n"
	"	#endif\n"
	"	#if defined(HAS_GEOMETRY_SHADER) && defined(PIXEL_SHADER)\n"
	"		uint PrimitiveIndex semantic(PRIMITIVE_INDEX);\n"
	"	#endif\n"
	"};\n"
	"#else // CREATE_SHADOW_MAP\n"
	"#ifdef PIXEL_SHADER\n"
	"struct pixel_input\n"
	"#else\n"
	"struct vertex_output\n"
	"#endif\n"
	"{\n"
	"	float4 position semantic(POSITION);\n"
	"	float4 shadow_position semantic(TEXCOORD4);\n"
	"	#if defined(WIDE_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"		float3 wide_line_offset semantic(OFFSET_COORD_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 0)\n"
	"		float4 uvcp0 semantic(CUTTING_PLANE_COORD0_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 4)\n"
	"		float4 uvcp1 semantic(CUTTING_PLANE_COORD1_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 8)\n"
	"		float4 uvcp2 semantic(CUTTING_PLANE_COORD2_OUT);\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 12)\n"
	"		float4 uvcp3 semantic(CUTTING_PLANE_COORD3_OUT);\n"
	"	#endif\n"
	"#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"	float2 marker_uv semantic(MARKER_TEXTURE_OUT);\n"
	"#endif\n"
	"};\n"
	"#endif // ndef CREATE_SHADOW_MAP\n"
; 


char const * const h3d_vertex =
	"#ifdef HAS_DOUBLE_POSITIONS\n"
	"#define POS_TYPE double3\n"
	"#else\n"
	"#define POS_TYPE float3\n"
	"#endif\n"
	"#ifndef CREATE_SHADOW_MAP\n"
	"struct vertex_input\n"
	"{\n"
	"	POS_TYPE position semantic(POSITION);\n"
	"	#ifdef HAS_VERTEX_NORMALS\n"
	"		float3 normal semantic(NORMAL);\n"
	"	#endif\n"
	"	#ifdef TANGENT_COORD\n"
	"		float4 tangent semantic(TANGENT_COORD);\n"
	"	#endif\n"
	"	#ifdef WIDE_LINE\n"
	"		float3 end semantic(NEXT_COORD);\n"
	"		#ifdef MITERED_LINE\n"
	"			float3 previous semantic(PREV_COORD);	\n"
	"		#endif\n"
	"		float4 offset semantic(OFFSET_COORD);\n"
	"		#if defined(ROUND_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"			float4 uv semantic(ROUND_COORD);\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_COLORS\n"
	"		float4 color semantic(COLOR0);\n"
	"	#endif\n"
	"	#ifdef HAS_AMBIENT_OCCLUSION\n"
	"		float4 ambient_occlusion semantic(COLOR1);\n"
	"	#endif \n"
	"	#ifdef HAS_LINE_PATTERN\n"
	"		float2 uvlp semantic(LINE_PATTERN_COORD);\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_FINDICES\n"
	"		float2 findex semantic(FINDEX_COORD);\n"
	"	#endif\n"
	"	#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined (HAS_DEFINED_MATERIAL_GS) || defined(HAS_TEXTURE3D)\n"
	"		float4 uvst0 semantic(DIFFUSE_TEXTURE_COORD0);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		float2 uv0 semantic(DIFFUSE_TEXTURE_COORD0);\n"
	"	#endif\n"
	"	#ifndef SHARED_DIFFUSE_COORDS\n"
	"		#if (TEXTURE_COUNT > 1) \n"
	"			float2 uv1 semantic(DIFFUSE_TEXTURE_COORD1);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 2) \n"
	"			float2 uv2 semantic(DIFFUSE_TEXTURE_COORD2);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 3) \n"
	"			float2 uv3 semantic(DIFFUSE_TEXTURE_COORD3);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 4) \n"
	"			float2 uv4 semantic(DIFFUSE_TEXTURE_COORD4);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 5) \n"
	"			float2 uv5 semantic(DIFFUSE_TEXTURE_COORD5);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 6) \n"
	"			float2 uv6 semantic(DIFFUSE_TEXTURE_COORD6);\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 7) \n"
	"			float2 uv7 semantic(DIFFUSE_TEXTURE_COORD7);\n"
	"		#endif\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		float2 buv0 semantic(BACK_DIFFUSE_TEXTURE_COORD0);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 1) \n"
	"		float2 buv1 semantic(BACK_DIFFUSE_TEXTURE_COORD1);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 2) \n"
	"		float2 buv2 semantic(BACK_DIFFUSE_TEXTURE_COORD2);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 3) \n"
	"		float2 buv3 semantic(BACK_DIFFUSE_TEXTURE_COORD3);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 4) \n"
	"		float2 buv4 semantic(BACK_DIFFUSE_TEXTURE_COORD4);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 5) \n"
	"		float2 buv5 semantic(BACK_DIFFUSE_TEXTURE_COORD5);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 6) \n"
	"		float2 buv6 semantic(BACK_DIFFUSE_TEXTURE_COORD6);\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 7) \n"
	"		float2 buv7 semantic(BACK_DIFFUSE_TEXTURE_COORD7);\n"
	"	#endif\n"
	"	#ifdef MIRROR_TEXTURE\n"
	"		float2 uvmirror semantic(MIRROR_TEXTURE);\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		float2 uvspec semantic(SPECULAR_TEXTURE);\n"
	"	#endif\n"
	"	#ifdef BUMP_TEXTURE\n"
	"		float2 uvbump semantic(BUMP_TEXTURE);\n"
	"	#endif\n"
	"	#ifdef TRANSMISSION_TEXTURE\n"
	"		float2 uvtransmission semantic(TRANSMISSION_TEXTURE);\n"
	"	#endif\n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		float2 uvemission semantic(EMISSION_TEXTURE);\n"
	"	#endif\n"
	"	#ifdef QUAD_MARKER\n"
	"		float2 marker_offset semantic(MARKER_TEXTURE);\n"
	"	#endif\n"
	"	#ifdef PRIORITY_HSRA\n"
	"		float priority semantic(PRIORITY_HSRA_COORD);\n"
	"	#endif \n"
	"	#if defined(HAS_GEOMETRY_SHADER)\n"
	"		#ifdef GS_ELLIPTICAL_ARC\n"
	"			float arc_param semantic(GS_ELLIPTICAL_ARC_COORD);\n"
	"		#endif\n"
	"		uint InstanceID semantic(SV_InstanceID);\n"
	"	#endif\n"
	"};\n"
	"#else \n"
	"struct vertex_input\n"
	"{\n"
	"	POS_TYPE position semantic(POSITION);\n"
	"	#ifdef WIDE_LINE\n"
	"		float3 end semantic(NEXT_COORD);\n"
	"		#ifdef MITERED_LINE\n"
	"			float3 previous semantic(PREV_COORD);	\n"
	"		#endif\n"
	"		float4 offset semantic(OFFSET_COORD);\n"
	"		#if defined(ROUND_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"			float4 uv semantic(ROUND_COORD);\n"
	"		#endif\n"
	"	#endif\n"
	"#ifdef QUAD_MARKER\n"
	"	float2 marker_offset semantic(MARKER_TEXTURE);\n"
	"#endif\n"
	"};\n"
	"#endif\n"
	"struct shadow_map_t\n"
	"{\n"
	"	row_major float4x4 transform;\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"	float4 distortion;\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"};\n"
	"struct atmospheric_attenuation_t\n"
	"{\n"
	"	float hither;\n"
	"	float yon;\n"
	"};\n"
	"#ifdef DC\n"
	"	uniform row_major float4x4 WorldViewProj;\n"
	"#else	\n"
	"	#ifdef DOUBLE_TRANSFORMS\n"
	"		uniform row_major double4x4 Projection;\n"
	"		uniform row_major double4x4 ModelView;\n"
	"		uniform row_major double4x4 Model;\n"
	"	#else\n"
	"		uniform row_major float4x4 Projection;\n"
	"		uniform row_major float4x4 ModelView;\n"
	"		uniform row_major float4x4 Model;\n"
	"	#endif	\n"
	"	uniform row_major float3x3 NormalizedModelView3x3;\n"
	"	#ifdef HAS_VERTEX_FINDICES\n"
	"		uniform row_major float4x4 IndexTextureMatrix;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 0 || BACK_TEXTURE_COUNT > 0)\n"
	"		uniform row_major float4x4 TextureMatrix0;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 1 || BACK_TEXTURE_COUNT > 1)\n"
	"		uniform row_major float4x4 TextureMatrix1;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 2 || BACK_TEXTURE_COUNT > 2)\n"
	"		uniform row_major float4x4 TextureMatrix2;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 3 || BACK_TEXTURE_COUNT > 3)\n"
	"		uniform row_major float4x4 TextureMatrix3;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 4 || BACK_TEXTURE_COUNT > 4)\n"
	"		uniform row_major float4x4 TextureMatrix4;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 5 || BACK_TEXTURE_COUNT > 5)\n"
	"		uniform row_major float4x4 TextureMatrix5;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 6 || BACK_TEXTURE_COUNT > 6)\n"
	"		uniform row_major float4x4 TextureMatrix6;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 7 || BACK_TEXTURE_COUNT > 7)\n"
	"		uniform row_major float4x4 TextureMatrix7;\n"
	"	#endif\n"
	"	#ifdef BUMP_TEXTURE\n"
	"		uniform row_major float4x4 BumpTextureMatrix;\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		uniform row_major float4x4 SpecularTextureMatrix;\n"
	"	#endif\n"
	"	#ifdef MIRROR_TEXTURE\n"
	"		uniform row_major float4x4 MirrorTextureMatrix;\n"
	"	#endif\n"
	"	#ifdef ENVIRONMENT_TEXTURE\n"
	"		uniform row_major float4x4 EnvironmentTextureMatrix;\n"
	"	#endif\n"
	"	#ifdef TRANSMISSION_TEXTURE\n"
	"		uniform row_major float4x4 TransmissionTextureMatrix;\n"
	"	#endif\n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		uniform row_major float4x4 EmissionTextureMatrix;\n"
	"	#endif\n"
	"#endif\n"
	"uniform float3 CameraPosition;		//camera position in object space\n"
	"#ifdef WIDE_LINE\n"
	"	uniform float WindowWidth;\n"
	"	uniform float WindowHeight;\n"
	"#endif\n"
	"#ifdef HAS_DEFINED_MATERIAL_SHADER\n"
	"	uniform float ScaledWindowWidth;\n"
	"	uniform float ScaledWindowHeight;\n"
	"#endif\n"
	"#ifdef WIDE_LINE\n"
	"	#define LINE_TOOLS_SIZE 256.0\n"
	"	uniform float LineWeight;		\n"
	"	uniform float CircleSubImageStart;\n"
	"	#ifdef MITERED_LINE\n"
	"	uniform float CosJoinCutoffAngle;\n"
	"	#endif\n"
	"#endif\n"
	"uniform shadow_map_t ShadowMaps[SHADOW_MAP_COUNT+1];\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"#ifdef CREATE_SHADOW_MAP\n"
	"uniform float4 ShadowDistortion;\n"
	"#endif // CREATE_SHADOW_MAP\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"uniform HColor MaterialColor;\n"
	"uniform float4 CuttingPlanes[CUTTING_PLANE_COUNT+1];\n"
	"uniform atmospheric_attenuation_t AtmosphericAttenuation;\n"
	"uniform float ColormapSize;\n"
	"#if defined(QUAD_MARKER) || defined(SPRITE_MARKER)\n"
	"uniform float2 MarkerSize;\n"
	"#endif\n"
	"#ifdef SNAPPED_MARKER\n"
	"uniform float4 MarkerSnap;\n"
	"uniform float4 MarkerUnsnap;\n"
	"#endif \n"
	"#ifdef POLY_CYLINDER\n"
	"uniform float4 PolyCylinderScale;\n"
	"#endif\n"
	"#ifdef HAS_LIGHTING\n"
	"#ifndef PER_PIXEL_LIGHTING\n"
	"uniform float3 AmbientLightDir;\n"
	"#endif\n"
	"#endif\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"float4 distort_shadowmap_position( float4 position, uniform float4 distortion )\n"
	"{\n"
	"	float2 delta = position.xy - distortion.xy;\n"
	"	float t = length(delta);\n"
	"	#ifndef CREATE_SHADOW_MAP\n"
	"		t *= 2.0;\n"
	"	#endif // CREATE_SHADOW_MAP\n"
	"	if ( t < 1 )\n"
	"	{\n"
	"		float t_dash = distortion.w * log( distortion.z * t + 1) / t; \n"
	"		position.xy = distortion.xy + delta * t_dash;\n"
	"	}\n"
	"	return position;\n"
	"}\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"#ifndef CREATE_SHADOW_MAP\n"
	"#ifdef HAS_VERTEX_NORMALS\n"
	"float3 spheremap( float3 ray )\n"
	"{\n"
	"	ray.z = 1.0 - ray.z;\n"
	"	float tmp = length(ray);\n"
	"	if(tmp < 0.000001)\n"
	"		tmp = 0.000001;\n"
	"	tmp = 0.5 / tmp;\n"
	"	ray.y = -ray.y;\n"
	"	float3 uv;\n"
	"	uv.xy = ray.xy * tmp + 0.5;\n"
	"	uv.z = 0.0;\n"
	"	return uv;\n"
	"}\n"
	"#endif // HAS_VERTEX_NORMALS\n"
	"#endif // CREATE_SHADOW_MAP\n"
	"#ifdef WIDE_LINE\n"
	"void wide_line_transform(\n"
	"		const vertex_input vertex,\n"
	"		out float4 position,\n"
	"		out float3 wide_line_offset)\n"
	"{\n"
	"	position = float4(vertex.position,1);\n"
	"#ifdef DC\n"
	"	float2 windowfactor = float2(1.0,1.0);\n"
	"#else\n"
	"	float2 windowfactor = float2(2.0 / WindowWidth, 2.0 / WindowHeight);\n"
	"	float ratio = WindowWidth / WindowHeight;\n"
	"#endif\n"
	"#ifdef MITERED_LINE\n"
	"	position.x = ceil(position.x) - 0.5;\n"
	"	position.y = ceil(position.y) - 0.5;\n"
	"	if (vertex.offset.w == H3D_MITER) {\n"
	"		#ifdef DC\n"
	"			float2 prev_path = normalize( float2(vertex.previous.xy - vertex.position.xy) );\n"
	"			float2 path = normalize( float2(vertex.end.xy - vertex.position.xy) );\n"
	"		#else\n"
	"			float4 end = mul (float4(vertex.end,1.0), ModelView);\n"
	"			end = mul(end, Projection);\n"
	"			float4 prev = mul (float4(vertex.previous,1.0), ModelView);\n"
	"			prev = mul(prev, Projection);\n"
	"			float4 pos = mul (float4(vertex.position,1.0), ModelView);\n"
	"			pos = mul(pos, Projection);\n"
	"			#ifdef CAMERA_PERSPECTIVE\n"
	"			#endif\n"
	"			position = pos;\n"
	"			float4 prev_path = prev - pos;\n"
	"			float4 path = end - pos;\n"
	"			prev_path.x *= ratio;\n"
	"			path.x *= ratio;\n"
	"			prev_path.xy = normalize(prev_path.xy);\n"
	"			path.xy = normalize(path.xy);\n"
	"		#endif	\n"
	"		float cos_angle = dot(prev_path, path) * 0.999;\n"
	"		float sin_angle = prev_path.x*path.y - prev_path.y*path.x;\n"
	"		float tan_half = sqrt( (1.0+cos_angle) / (1.0-cos_angle) );\n"
	"		float adjust = tan_half;\n"
	"		if (cos_angle >= CosJoinCutoffAngle)\n"
	"			adjust = 0.0;\n"
	"		float3 miter_offset = vertex.offset.xyz;\n"
	"#ifdef DC\n"
	"		prev_path *= WIDE_LINE_SCALE;\n"
	"		path *= WIDE_LINE_SCALE;\n"
	"#endif\n"
	"		if (miter_offset.z > 0.0)\n"
	"			path = -prev_path * LineWeight/2.0;\n"
	"		else\n"
	"			path *= LineWeight/2.0;\n"
	"		if (vertex.offset.w == H3D_ROUND)		// shrink the line a bit if we're not texture sampling\n"
	"			path *= WIDE_LINE_SAMPLER_SCALE;\n"
	"		path *= position.w;\n"
	"		if (sin_angle < -0.00001)\n"
	"			miter_offset.x *= -1.0;\n"
	"		position.xy += miter_offset.x * float2( -path.y, path.x ) * windowfactor;\n"
	"		position.xy += miter_offset.y * adjust * path.xy * windowfactor;\n"
	"	}\n"
	"	else\n"
	"#endif\n"
	"	{\n"
	"		#ifdef DC\n"
	"			float2 path = normalize( float2(vertex.end.xy - vertex.position.xy) );\n"
	"			path *= WIDE_LINE_SCALE;\n"
	"		#else\n"
	"			float4 end = mul (float4(vertex.end,1.0), ModelView);\n"
	"			end = mul(end, Projection);\n"
	"			float4 pos = mul (float4(vertex.position,1.0), ModelView);\n"
	"			pos = mul(pos, Projection);\n"
	"			position = pos;\n"
	"			float4 path = end - pos;\n"
	"			path.x *= ratio;\n"
	"			float len = length(path.xy);\n"
	"			if (len > 0.00001) {\n"
	"				path.xy /= len;\n"
	"			}\n"
	"			#ifdef CAMERA_PERSPECTIVE\n"
	"				else {\n"
	"					end /= end.w;\n"
	"					pos /= pos.w;\n"
	"					path = end - pos;\n"
	"					path.x *= ratio;\n"
	"					len = length(path.xy);\n"
	"					if (len > 0.00001)\n"
	"						path.xy /= len;\n"
	"				}\n"
	"			#endif\n"
	"		#endif\n"
	"		path *= LineWeight/2.0;\n"
	"		if (vertex.offset.w == H3D_ROUND)	// shrink the line a bit if we're not texture sampling\n"
	"			path *= WIDE_LINE_SAMPLER_SCALE;\n"
	"		path.xy *= position.w;\n"
	"		position.xy += vertex.offset.x * float2( -path.y, path.x ) * windowfactor;\n"
	"		position.xy += vertex.offset.y * path.xy * windowfactor;\n"
	"	}\n"
	"	#if defined(ROUND_LINE) || defined(ANTI_ALIASED_LINE)	\n"
	"		if (vertex.offset.w == H3D_ROUND) {\n"
	"			wide_line_offset.xy = vertex.uv.xy * 0.5 + 0.5;\n"
	"		}\n"
	"		else\n"
	"			wide_line_offset.xy = float2(0.5, 0.5);\n"
	"		#if defined(ANTI_ALIASED_LINE)\n"
	"			wide_line_offset.xy = vertex.uv.xy * 0.5 + 0.5;\n"
	"		#endif\n"
	"		wide_line_offset.xy *= (LineWeight+2.0)/LINE_TOOLS_SIZE;\n"
	"		wide_line_offset.x += CircleSubImageStart;\n"
	"	#else\n"
	"		wide_line_offset.xy = float2(0.0, 0.0);\n"
	"	#endif\n"
	"	wide_line_offset.z = vertex.offset.w;			//pass through the flag stored in w\n"
	"	#ifdef DC\n"
	"		position += 0.5;\n"
	"	#endif\n"
	"}\n"
	"#endif\n"
	"vertex_output vertex_common(vertex_input vertex)\n"
	"{\n"
	"	int i;\n"
	"	vertex_output result;\n"
	"#ifdef HAS_GEOMETRY_SHADER\n"
	"	result.InstanceID = vertex.InstanceID;\n"
	"#endif\n"
	"#ifdef GS_ELLIPTICAL_ARC\n"
	"	result.arc_param = vertex.arc_param;\n"
	"#endif\n"
	"#ifndef CREATE_SHADOW_MAP\n"
	"	#ifdef HAS_VERTEX_COLORS\n"
	"		#if !defined(HAS_VERTEX_RGBAS) && !defined(DC)\n"
	"			vertex.color.a = MaterialColor.diffuse.a;\n"
	"		#endif\n"
	"		result.material_color_and_specular_intensity = vertex.color;\n"
	"	#else\n"
	"		result.material_color_and_specular_intensity = MaterialColor.diffuse;\n"
	"	#endif\n"
	"#endif // ndef CREATE_SHADOW_MAP\n"
	"	POS_TYPE position = vertex.position;\n"
	"#ifdef DC	\n"
	"	#ifdef WIDE_LINE\n"
	"		float4 out_pos;\n"
	"		wide_line_transform(vertex, out_pos, result.wide_line_offset);\n"
	"		position.xyz = out_pos.xyz;\n"
	"	#endif\n"
	"    #ifdef HAS_DEFINED_MATERIAL_GS\n"
	"		result.position = float4(position, 1.0);\n"
	"	#else\n"
	"		result.position = mul(float4(position, 1.0), WorldViewProj);\n"
	"	#endif\n"
	"	#ifdef EYE_POSITION_COORD\n"
	"		result.eye_position = result.position;\n"
	"	#endif \n"
	"#else // ndef DC -> 3D\n"
	"#ifdef DOUBLE_TRANSFORMS\n"
	"	double4 eye_position = mul(double4(position, 1.0), ModelView);\n"
	"#else\n"
	"	float4 eye_position = mul(float4(position, 1.0), ModelView);\n"
	"#endif\n"
	"	#ifdef HAS_VERTEX_NORMALS\n"
	"		float3 eye_normal = mul( vertex.normal, NormalizedModelView3x3);\n"
	"		#ifdef HAS_NON_UNIFORM_SCALE\n"
	"			eye_normal = normalize(eye_normal);\n"
	"		#endif\n"
	"		#if defined(HAS_VERTEX_NORMALS) && defined(POLY_CYLINDER)\n"
	"		#ifndef CAMERA_PERSPECTIVE\n"
	"			eye_position.xyz += PolyCylinderScale.x * eye_normal;\n"
	"		#else\n"
	"			float pixel = PolyCylinderScale.y * eye_position.z;\n"
	"			eye_position.xyz += pixel * eye_normal;\n"
	"		#endif\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef TANGENT_COORD\n"
	"		float3 eye_tangent = float3(1,0,0);\n"
	"		if (vertex.tangent.x != 0.0 ||\n"
	"			vertex.tangent.y != 0.0 ||\n"
	"			vertex.tangent.z != 0.0) {\n"
	"			eye_tangent = mul( vertex.tangent.xyz, NormalizedModelView3x3);\n"
	"			#ifdef HAS_NON_UNIFORM_SCALE\n"
	"				eye_tangent = normalize(eye_tangent);\n"
	"			#endif\n"
	"		}\n"
	"	#endif\n"
	"	#ifndef WIDE_LINE\n"
	"	#ifdef HAS_DEFINED_MATERIAL_GS\n"
	"		result.position = float4(vertex.position, 1.0);\n"
	"	#else		\n"
	"		result.position = float4(mul(eye_position, Projection));		\n"
	"	#endif\n"
	"	#else\n"
	"		wide_line_transform(vertex, result.position, result.wide_line_offset);\n"
	"	#endif\n"
	"#ifndef CREATE_SHADOW_MAP\n"
	"	#ifdef EYE_POSITION_COORD\n"
	"		result.eye_position = float4(eye_position);\n"
	"	#endif \n"
	"	#ifdef TANGENT_COORD\n"
	"		result.eye_tangent.xyz = eye_tangent * 0.5 + 0.5;\n"
	"		result.eye_tangent.w = vertex.tangent.w;\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_NORMALS\n"
	"		#ifdef HAS_LIGHTING\n"
	"			#ifdef PER_PIXEL_LIGHTING\n"
	"				result.eye_normal.xyz = eye_normal * 0.5 + 0.5;\n"
	"			#endif // PER_PIXEL_LIGHTING\n"
	"			#ifdef HAS_HANDEDNESS\n"
	"				#ifdef RIGHT_HANDED_MATRIX\n"
	"					eye_normal = -eye_normal;\n"
	"				#endif\n"
	"				eye_normal *= DRIVER_SPECIFIC_FLIP;\n"
	"			#else\n"
	"				#ifdef CAMERA_PERSPECTIVE\n"
	"					if (dot(float3(eye_position.xyz),eye_normal) > 0.0)\n"
	"						eye_normal = -eye_normal;\n"
	"				#else\n"
	"					if(eye_normal.z > 0.0)\n"
	"						eye_normal = -eye_normal;\n"
	"					eye_normal *= DRIVER_SPECIFIC_FLIP;\n"
	"				#endif\n"
	"			#endif\n"
	"			#ifndef PER_PIXEL_LIGHTING\n"
	"				HSurface surface;\n"
	"				surface.position = float3(eye_position.xyz);\n"
	"				surface.normal = eye_normal;\n"
	"				#ifdef TANGENT_COORD\n"
	"					surface.tangent = eye_tangent;\n"
	"				#else\n"
	"					surface.tangent = float3(1.0, 0.0, 0.0);\n"
	"				#endif\n"
	"				surface.bitangent = normalize(cross(surface.normal, surface.tangent));\n"
	"				HLighting lighting;\n"
	"				lighting.diffuse = float3(0.0, 0.0, 0.0);\n"
	"				lighting.specular = float3(0.0, 0.0, 0.0);\n"
	"				lighting.ambient = float3(0.0, 0.0, 0.0);\n"
	"				lighting.emissive = float3(0.0, 0.0, 0.0);\n"
	"				HColor material_color;\n"
	"				material_color.diffuse = MaterialColor.diffuse;\n"
	"				material_color.specular = MaterialColor.specular;\n"
	"				direct_lighting(material_color, surface, lighting);\n"
	"				result.diffuse_light_and_ambient_blend.rgb = lighting.diffuse;\n"
	"				result.material_color_and_specular_intensity.a = rgb_to_gray(lighting.specular);\n"
	"				float ambient_blend = 0.5 + 0.5 * dot(eye_normal, AmbientLightDir);\n"
	"				result.diffuse_light_and_ambient_blend.a = ambient_blend;\n"
	"			#endif // ndef PER_PIXEL_LIGHTING\n"
	"		#endif // HAS_LIGHTING\n"
	"	#endif // HAS_VERTEX_NORMALS\n"
	"#endif // ndef CREATE_SHADOW_MAP\n"
	"#endif // ndef DC\n"
	"#ifdef SNAPPED_MARKER\n"
	"#ifdef CAMERA_PERSPECTIVE\n"
	"	result.position.xy /= result.position.w;\n"
	"#endif // CAMERA_PERSPECTIVE\n"
	"	result.position.xy = result.position.xy * MarkerSnap.xy + MarkerSnap.zw;\n"
	"	result.position.xy = floor(result.position.xy) + MARKER_HALF_PIXEL_OFFSET;\n"
	"	result.position.xy = result.position.xy * MarkerUnsnap.xy + MarkerUnsnap.zw;\n"
	"#ifdef CAMERA_PERSPECTIVE\n"
	"	result.position.xy *= result.position.w;\n"
	"#endif\n"
	"#endif // SNAPPED_MARKER\n"
	"#ifdef QUAD_MARKER\n"
	"#if defined (CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"	result.marker_uv = float2(1.0,-(DRIVER_SPECIFIC_FLIP)) * vertex.marker_offset * 0.5 + 0.5;	\n"
	"#endif\n"
	"#ifndef WORLD_SPACE_MARKER\n"
	"	result.position.xy += MarkerSize * vertex.marker_offset.xy * result.position.w;\n"
	"#else\n"
	"	result.position.xy += MarkerSize * vertex.marker_offset.xy;\n"
	"#endif\n"
	"#endif // QUAD_MARKER\n"
	"#ifdef SPRITE_MARKER\n"
	"#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"	result.marker_uv = float2(0.0, 0.0);\n"
	"#endif\n"
	"#ifdef WORLD_SPACE_MARKER\n"
	"	result.marker_size = min(MarkerSize.y / result.position.w, MAX_MARKER_SIZE);\n"
	"#else\n"
	"	result.marker_size = min(MarkerSize.y, MAX_MARKER_SIZE);\n"
	"#endif\n"
	"#endif // ndef MARKER_SPRITE\n"
	"#ifndef CREATE_SHADOW_MAP\n"
	"#ifdef HAS_VERTEX_FINDICES\n"
	"	result.findex = (mul(float4(vertex.findex, 0.0, 1.0), IndexTextureMatrix)).xy;\n"
	"	float colormap_shift = 0.5/ColormapSize;\n"
	"	result.findex.x = result.findex.x / ColormapSize + colormap_shift;\n"
	"	result.findex.y -= 0.5;\n"
	"#endif\n"
	"#ifndef DC\n"
	"	#ifdef DOUBLE_TRANSFORMS\n"
	"		float4 world_position = float4(mul(float4(vertex.position, 1), Model));\n"
	"	#else\n"
	"		float4 world_position = mul(float4(vertex.position,1), Model);\n"
	"	#endif\n"
	"#endif\n"
	"#if (TEXTURE_COUNT > 0)\n"
	"	#ifndef DC\n"
	"		#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined(HAS_DEFINED_MATERIAL_GS) || defined(HAS_TEXTURE3D)\n"
	"			#if defined(DEFINED_MATERIAL_PS_UVW) || defined(HAS_TEXTURE3D)\n"
	"				result.uvst0 = float4(vertex.uvst0.xyz, 1.0);\n"
	"			#endif\n"
	"			#if defined(DEFINED_MATERIAL_PS_WORLD)\n"
	"				result.uvst0 = float4(world_position.xyz, 1.0) / world_position.w;\n"
	"			#endif\n"
	"			#if defined(DEFINED_MATERIAL_PS_OBJECT)\n"
	"				result.uvst0 = float4(vertex.position, 1.0);	\n"
	"			#endif\n"
	"			#if defined(DEFINED_MATERIAL_PS_SURFACE_NORMAL)\n"
	"				#if defined(HAS_VERTEX_NORMALS)\n"
	"					result.uvst0 = float4(vertex.normal,1.0);\n"
	"				#else\n"
	"					result.uvst0 = float4(0.0, 0.0, 0.0, 1.0);\n"
	"				#endif\n"
	"			#endif\n"
	"			#if defined(DEFINED_MATERIAL_PS_LOCAL_PIXELS) || defined(DEFINED_MATERIAL_PS_OUTER_PIXELS)\n"
	"				result.uvst0.x = ScaledWindowWidth * result.position.x;\n"
	"				result.uvst0.y = -ScaledWindowHeight * result.position.y;\n"
	"				result.uvst0.z = 0.0;\n"
	"				result.uvst0.w = result.position.w;\n"
	"			#endif\n"
	"			#if defined(DEFINED_MATERIAL_PS_LOCAL_WINDOW) || defined(DEFINED_MATERIAL_PS_OUTER_WINDOW)\n"
	"				result.uvst0.x = result.position.x;\n"
	"				result.uvst0.y = result.position.y;\n"
	"				result.uvst0.z = 0.0;\n"
	"				result.uvst0.w = result.position.w;\n"
	"			#endif\n"
	"			#if defined(DEFINED_MATERIAL_PS_PHYSICAL_REFLECTION)\n"
	"				#if defined(HAS_VERTEX_NORMALS)\n"
	"					result.uvst0 = float4(reflect(normalize(vertex.position - CameraPosition), vertex.normal), 1);\n"
	"				#else\n"
	"					result.uvst0 = float4(0.0, 0.0, 0.0, 1.0);\n"
	"				#endif\n"
	"			#endif\n"
	"			result.uvst0 = mul(result.uvst0, TextureMatrix0);\n"
	"		#else\n"
	"			#if defined(TEXTURE0_WORLD)\n"
	"				result.uv0 = world_position.xy;\n"
	"			#else\n"
	"				result.uv0 = vertex.uv0.xy;\n"
	"			#endif\n"
	"			result.uv0 = (mul(float4(result.uv0, 0.0, 1.0), TextureMatrix0)).xy;\n"
	"		#endif\n"
	"	#else\n"
	"	    result.uv0 = vertex.uv0.xy;\n"
	"	#endif\n"
	"#endif\n"
	"#ifndef SHARED_DIFFUSE_COORDS\n"
	"	#if (TEXTURE_COUNT > 1) \n"
	"		PROCESS_VS_TEXTURE_FRONT_1(TEXTURE1_WORLD);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 2) \n"
	"		PROCESS_VS_TEXTURE_FRONT_2(TEXTURE2_WORLD);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 3) \n"
	"		PROCESS_VS_TEXTURE_FRONT_3(TEXTURE3_WORLD);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 4) \n"
	"		PROCESS_VS_TEXTURE_FRONT_4(TEXTURE4_WORLD);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 5) \n"
	"		PROCESS_VS_TEXTURE_FRONT_5(TEXTURE5_WORLD);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 6) \n"
	"		PROCESS_VS_TEXTURE_FRONT_6(TEXTURE6_WORLD);\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 7) \n"
	"		PROCESS_VS_TEXTURE_FRONT_7(TEXTURE7_WORLD);\n"
	"	#endif\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 0)\n"
	"	#ifndef DC\n"
	"		#ifdef BACK_TEXTURE0_WORLD\n"
	"			result.buv0 = world_position.xy;\n"
	"		#else\n"
	"			result.buv0 = vertex.buv0.xy;\n"
	"		#endif\n"
	"		result.buv0 = (mul(float4(result.buv0, 0.0, 1.0), TextureMatrix0)).xy;\n"
	"	#else\n"
	"	    result.buv0 = vertex.buv0.xy;\n"
	"	#endif\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 1) \n"
	"	PROCESS_VS_TEXTURE_BACK_1(BACK_TEXTURE1_WORLD);\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 2)\n"
	"	PROCESS_VS_TEXTURE_BACK_2(BACK_TEXTURE2_WORLD);\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 3)\n"
	"	PROCESS_VS_TEXTURE_BACK_3(BACK_TEXTURE3_WORLD);\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 4)\n"
	"	PROCESS_VS_TEXTURE_BACK_4(BACK_TEXTURE4_WORLD);\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 5)\n"
	"	PROCESS_VS_TEXTURE_BACK_5(BACK_TEXTURE5_WORLD);\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 6)\n"
	"	PROCESS_VS_TEXTURE_BACK_6(BACK_TEXTURE6_WORLD);\n"
	"#endif\n"
	"#if (BACK_TEXTURE_COUNT > 7)\n"
	"	PROCESS_VS_TEXTURE_BACK_7(BACK_TEXTURE7_WORLD);\n"
	"#endif\n"
	"#ifdef HAS_FACE_PATTERN\n"
	"	result.uvzwfp.xy = result.position.xy;\n"
	"	result.uvzwfp.z = 0.0;\n"
	"	result.uvzwfp.w = result.position.w;\n"
	"#endif\n"
	"#ifdef HAS_LINE_PATTERN\n"
	"	result.uvlp.x = vertex.uvlp.x;\n"
	"	result.uvlp.y = vertex.uvlp.y;\n"
	"	result.uvlp.z = 0.0;\n"
	"	result.uvlp.w = 0.0;\n"
	"#endif\n"
	"#ifdef ENVIRONMENT_TEXTURE\n"
	"	#if !defined(CUBE_ENVIRONMENT_MAP) || !defined(PER_PIXEL_LIGHTING)\n"
	"		#ifdef HAS_PHYSICAL_REFLECTION\n"
	"			result.uvenv = reflect(normalize(vertex.position - CameraPosition), vertex.normal);\n"
	"		#else\n"
	"			eye_normal.xy *= DRIVER_SPECIFIC_FLIP;\n"
	"			result.uvenv = reflect(float3(0,0,1), eye_normal);\n"
	"		#endif\n"
	"		#ifndef CUBE_ENVIRONMENT_MAP\n"
	"			result.uvenv = spheremap( result.uvenv );\n"
	"			result.uvenv = (mul(float4(result.uvenv,1.0), EnvironmentTextureMatrix)).xyz;\n"
	"		#endif\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef SPECULAR_TEXTURE\n"
	"	#ifdef SPECULAR_TEXTURE_WORLD\n"
	"		result.uvspec = (mul(float4(world_position.xy, 0.0, 1.0), SpecularTextureMatrix)).xy;\n"
	"	#else\n"
	"		result.uvspec = (mul(float4(vertex.uvspec, 0.0, 1.0), SpecularTextureMatrix)).xy;\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef BUMP_TEXTURE\n"
	"	#ifdef BUMP_TEXTURE_WORLD\n"
	"		result.uvbump = (mul(float4(world_position.xy, 0.0, 1.0), BumpTextureMatrix)).xy;\n"
	"	#else\n"
	"		result.uvbump = (mul(float4(vertex.uvbump, 0.0, 1.0), BumpTextureMatrix)).xy;\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef MIRROR_TEXTURE\n"
	"	#ifdef MIRROR_TEXTURE_WORLD\n"
	"		result.uvmirror = (mul(float4(world_position.xy, 0.0, 1.0), MirrorTextureMatrix)).xy;\n"
	"	#else\n"
	"		result.uvmirror = (mul(float4(vertex.uvmirror, 0.0, 1.0), MirrorTextureMatrix)).xy;\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef TRANSMISSION_TEXTURE\n"
	"	#ifdef TRANSMISSION_TEXTURE_WORLD\n"
	"		result.uvtransmission = (mul(float4(world_position.xy, 0.0, 1.0), TransmissionTextureMatrix)).xy;\n"
	"	#else\n"
	"		result.uvtransmission = (mul(float4(vertex.uvtransmission, 0.0, 1.0), TransmissionTextureMatrix)).xy;\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef EMISSION_TEXTURE\n"
	"	#ifdef EMISSION_TEXTURE_WORLD\n"
	"		result.uvemission = (mul(float4(world_position.xy, 0.0, 1.0), EmissionTextureMatrix)).xy;\n"
	"	#else\n"
	"		result.uvemission = (mul(float4(vertex.uvemission, 0.0, 1.0), EmissionTextureMatrix)).xy;\n"
	"	#endif\n"
	"#endif\n"
	"#if (SHADOW_MAP_COUNT > 0)\n"
	"	shadow_map_t sm0 = ShadowMaps[0];\n"
	"	result.uvsm0 = mul( float4(vertex.position,1), sm0.transform);\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"	result.uvsm0 = distort_shadowmap_position( result.uvsm0, sm0.distortion );\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"	result.screen_position = result.position;\n"
	"#endif // SHADOW_MAP_JITTER\n"
	"#endif\n"
	"#if (SHADOW_MAP_COUNT > 1)\n"
	"	shadow_map_t sm1 = ShadowMaps[1];\n"
	"	result.uvsm1 = mul( float4(vertex.position,1), sm1.transform);\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"	result.uvsm1 = distort_shadowmap_position( result.uvsm1, sm1.distortion );\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"#endif\n"
	"#if (SHADOW_MAP_COUNT > 2)\n"
	"	shadow_map_t sm2 = ShadowMaps[2];\n"
	"	result.uvsm2 = mul( float4(vertex.position,1), sm2.transform);\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"	result.uvsm2 = distort_shadowmap_position( result.uvsm2, sm2.distortion );\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"#endif\n"
	"#if (SHADOW_MAP_COUNT > 3)\n"
	"	shadow_map_t sm3 = ShadowMaps[3];\n"
	"	result.uvsm3 = mul( float4(vertex.position,1), sm3.transform);\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"	result.uvsm3 = distort_shadowmap_position( result.uvsm3, sm3.distortion );\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 0)\n"
	"	#ifdef DC\n"
	"		float4 cutting_position = float4(vertex.position,1.0);\n"
	"	#else\n"
	"		float4 cutting_position = float4(eye_position);\n"
	"	#endif\n"
	"	result.uvcp0 = float4(dot(cutting_position, CuttingPlanes[0]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 1)\n"
	"	result.uvcp0.y = dot(cutting_position, CuttingPlanes[1]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 2)\n"
	"	result.uvcp0.z = dot(cutting_position, CuttingPlanes[2]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 3)\n"
	"	result.uvcp0.w = dot(cutting_position, CuttingPlanes[3]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 4)\n"
	"	result.uvcp1 = float4(dot(cutting_position, CuttingPlanes[4]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 5)\n"
	"	result.uvcp1.y = dot(cutting_position, CuttingPlanes[5]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 6)\n"
	"	result.uvcp1.z = dot(cutting_position, CuttingPlanes[6]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 7)\n"
	"	result.uvcp1.w = dot(cutting_position, CuttingPlanes[7]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 8)\n"
	"	result.uvcp2 = float4(dot(cutting_position, CuttingPlanes[8]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 9)\n"
	"	result.uvcp2.y = dot(cutting_position, CuttingPlanes[9]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 10)\n"
	"	result.uvcp2.z = dot(cutting_position, CuttingPlanes[10]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 11)\n"
	"	result.uvcp2.w = dot(cutting_position, CuttingPlanes[11]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 12)\n"
	"	result.uvcp3 = float4(dot(cutting_position, CuttingPlanes[12]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 13)\n"
	"	result.uvcp3.y = dot(cutting_position, CuttingPlanes[13]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 14)\n"
	"	result.uvcp3.z = dot(cutting_position, CuttingPlanes[14]);\n"
	"#endif\n"
	"#ifdef PRIORITY_HSRA\n"
	"	result.position.z = vertex.priority * result.position.w;\n"
	"#endif\n"
	"#if defined(DEPTH_PEELING) || defined(DEPTH_WRITING)\n"
	"	result.peel_position = result.position;\n"
	"#endif\n"
	"#ifdef HAS_ATMOSPHERIC_ATTENUATION\n"
	"	float fog_z = abs(eye_position.z);\n"
	"	result.fog = (fog_z - AtmosphericAttenuation.yon) / (AtmosphericAttenuation.hither - AtmosphericAttenuation.yon);\n"
	"#endif\n"
	"#else // CREATE_SHADOW_MAP\n"
	"#ifdef SHADOW_MAP_DISTORTION\n"
	"	result.position = distort_shadowmap_position( result.position, ShadowDistortion );\n"
	"#endif // SHADOW_MAP_DISTORTION\n"
	"#if (CUTTING_PLANE_COUNT > 0)\n"
	"	#ifdef DC\n"
	"		float4 cutting_position = float4(vertex.position,1.0);\n"
	"	#else\n"
	"		float4 cutting_position = eye_position;\n"
	"	#endif\n"
	"	result.uvcp0 = float4(dot(cutting_position, CuttingPlanes[0]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 1)\n"
	"	result.uvcp0.y = dot(cutting_position, CuttingPlanes[1]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 2)\n"
	"	result.uvcp0.z = dot(cutting_position, CuttingPlanes[2]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 3)\n"
	"	result.uvcp0.w = dot(cutting_position, CuttingPlanes[3]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 4)\n"
	"	result.uvcp1 = float4(dot(cutting_position, CuttingPlanes[4]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 5)\n"
	"	result.uvcp1.y = dot(cutting_position, CuttingPlanes[5]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 6)\n"
	"	result.uvcp1.z = dot(cutting_position, CuttingPlanes[6]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 7)\n"
	"	result.uvcp1.w = dot(cutting_position, CuttingPlanes[7]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 8)\n"
	"	result.uvcp2 = float4(dot(cutting_position, CuttingPlanes[8]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 9)\n"
	"	result.uvcp2.y = dot(cutting_position, CuttingPlanes[9]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 10)\n"
	"	result.uvcp2.z = dot(cutting_position, CuttingPlanes[10]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 11)\n"
	"	result.uvcp2.w = dot(cutting_position, CuttingPlanes[11]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 12)\n"
	"	result.uvcp3 = float4(dot(cutting_position, CuttingPlanes[12]),1.0,1.0,1.0);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 13)\n"
	"	result.uvcp3.y = dot(cutting_position, CuttingPlanes[13]);\n"
	"#endif\n"
	"#if (CUTTING_PLANE_COUNT > 14)\n"
	"	result.uvcp3.z = dot(cutting_position, CuttingPlanes[14]);\n"
	"#endif\n"
	"	result.shadow_position = result.position;\n"
	"#endif // ndef CREATE_SHADOW_MAP\n"
	"	return result;\n"
	"}\n"
; 


char const * const ogl2_cs_edgepat_length =
	"#version 430\n"
	"#define THREAD_GROUP_X 256\n"
	"layout(std140, binding=0) uniform TransformMatrix\n"
	"{\n"
	"	mat4			xform;\n"
	"	float			U_SCALE;\n"
	"	float			V_SCALE;\n"
	"};\n"
	"struct FLOAT3\n"
	"{\n"
	"	float x;\n"
	"	float y;\n"
	"	float z;\n"
	"};\n"
	"layout(std430, binding=1) buffer InputBuffer\n"
	"{\n"
	"	FLOAT3 in_positions[];\n"
	"};\n"
	"layout(std430, binding=2) buffer OutputBuffer\n"
	"{\n"
	"	FLOAT3 out_uvws[];\n"
	"};\n"
	"vec3 getpoint(uint i)\n"
	"{\n"
	"	vec3 p;\n"
	"	p.x = in_positions[i].x;\n"
	"	p.y = in_positions[i].y;\n"
	"	p.z = in_positions[i].z;\n"
	"	return p;\n"
	"}\n"
	"layout (local_size_x = THREAD_GROUP_X, local_size_y = 1, local_size_z = 1) in;\n"
	"void main()\n"
	"{\n"
	"	uint dtid = gl_GlobalInvocationID.x;\n"
	"	vec3 p0 = getpoint(2 * dtid);\n"
	"	vec3 p1 = getpoint(2 * dtid + 1);\n"
	"	vec4 t0 = xform * vec4(p0, 1.0);\n"
	"	vec4 t1 = xform * vec4(p1, 1.0);\n"
	"	vec2 tt0 = t0.xy / t0.w;\n"
	"	vec2 tt1 = t1.xy / t1.w;\n"
	"	float len = length(tt1 - tt0) * U_SCALE;\n"
	"	out_uvws[2*dtid + 1].x = len;\n"
	"	out_uvws[2*dtid + 1].y = V_SCALE;\n"
	"}\n"
; 


char const * const ogl2_cs_linepat_clip =
	"#version 430\n"
	"#define THREAD_GROUP_X 256\n"
	"layout(std140, binding=0) uniform Planes\n"
	"{\n"
	"	vec4 leftPlane;\n"
	"	vec4 rightPlane;\n"
	"	vec4 bottomPlane;\n"
	"	vec4 topPlane;\n"
	"	vec4 nearPlane;\n"
	"	vec4 farPlane;\n"
	"};\n"
	"struct FLOAT3\n"
	"{\n"
	"	float x;\n"
	"	float y;\n"
	"	float z;\n"
	"};\n"
	"layout(std430, binding=1) buffer InputBuffer\n"
	"{\n"
	"	FLOAT3 in_positions[];\n"
	"};\n"
	"layout(std430, binding=2) buffer OutputBuffer\n"
	"{\n"
	"	FLOAT3 out_positions[];\n"
	"};\n"
	"vec3 getpoint(uint i)\n"
	"{\n"
	"	vec3 p;\n"
	"	p.x = in_positions[i].x;\n"
	"	p.y = in_positions[i].y;\n"
	"	p.z = in_positions[i].z;\n"
	"	return p;\n"
	"}\n"
	"void storepoint(uint i, float x, float y, float z)\n"
	"{\n"
	"	out_positions[i].x = x;\n"
	"	out_positions[i].y = y;\n"
	"	out_positions[i].z = z;\n"
	"}\n"
	"void clipLinePlane(inout vec3 p0, inout vec3 p1, const vec4 plane)\n"
	"{\n"
	"	vec3 N = plane.xyz;\n"
	"	float w = plane.w;\n"
	"	float denom = dot(N, p1 - p0);\n"
	"	if (abs(denom) < 0.0001)\n"
	"		return;\n"
	"	float d0 = dot(N, p0) + w;\n"
	"	float d1 = dot(N, p1) + w;\n"
	"	if (d0 > 0 && d1 > 0)\n"
	"		return;\n"
	"	if (d0 < 0 && d1 < 0)\n"
	"	{\n"
	"		p1 = p0;\n"
	"		return;	\n"
	"	}\n"
	"	float t = -(dot(N, p0) + w) / denom;\n"
	"	vec3 p = p0 + t * (p1 - p0);\n"
	"	if (d0 < 0)\n"
	"		p0 = p;\n"
	"	else\n"
	"		p1 = p;\n"
	"}\n"
	"layout(local_size_x = THREAD_GROUP_X, local_size_y = 1, local_size_z = 1) in;\n"
	"void main()\n"
	"{\n"
	"	uint dtid = gl_GlobalInvocationID.x;\n"
	"	vec3 p0 = getpoint(2*dtid);\n"
	"	vec3 p1 = getpoint(2*dtid+1);\n"
	"	clipLinePlane(p0, p1, leftPlane);\n"
	"	clipLinePlane(p0, p1, rightPlane);\n"
	"	clipLinePlane(p0, p1, bottomPlane);\n"
	"	clipLinePlane(p0, p1, topPlane);\n"
	"	clipLinePlane(p0, p1, nearPlane);\n"
	"	clipLinePlane(p0, p1, farPlane);\n"
	"	storepoint(2*dtid, p0.x, p0.y, p0.z);\n"
	"	storepoint(2*dtid+1, p1.x, p1.y, p1.z);\n"
	"}\n"
; 


char const * const ogl2_cs_linepat_length =
	"#version 430\n"
	"#define THREAD_GROUP_X 256\n"
	"shared float temp[THREAD_GROUP_X * 2];\n"
	"layout(std140, binding=0) uniform TransformMatrix\n"
	"{\n"
	"	mat4			xform;\n"
	"	float			U_SCALE;\n"
	"	float			V_SCALE;\n"
	"};\n"
	"struct FLOAT3\n"
	"{\n"
	"	float x;\n"
	"	float y;\n"
	"	float z;\n"
	"};\n"
	"layout(std430, binding=1) buffer InputBuffer\n"
	"{\n"
	"	FLOAT3 in_positions[];\n"
	"};\n"
	"layout(std430, binding=2) buffer OutputBuffer\n"
	"{\n"
	"	FLOAT3 out_uvws[];\n"
	"};\n"
	"vec3 getpoint(uint i)\n"
	"{\n"
	"	vec3 p;\n"
	"	p.x = in_positions[i].x;\n"
	"	p.y = in_positions[i].y;\n"
	"	p.z = in_positions[i].z;\n"
	"	return p;\n"
	"}\n"
	"layout (local_size_x = THREAD_GROUP_X, local_size_y = 1, local_size_z = 1) in;\n"
	"void main()\n"
	"{\n"
	"	uint gid = gl_WorkGroupID.x;\n"
	"	uint gtid = gl_LocalInvocationID.x;\n"
	"	uint dtid = gl_GlobalInvocationID.x;\n"
	"	vec3 p0 = getpoint(2 * dtid);\n"
	"	vec3 p1 = getpoint(2 * dtid + 1);\n"
	"	vec4 t0 = xform * vec4(p0, 1.0);\n"
	"	vec4 t1 = xform * vec4(p1, 1.0);\n"
	"	vec2 tt0 = t0.xy / t0.w;\n"
	"	vec2 tt1 = t1.xy / t1.w;\n"
	"	float len = length(tt1 - tt0) * U_SCALE;\n"
	"	int pout = 0;\n"
	"	int pin  = 1;	\n"
	"	temp[pout*THREAD_GROUP_X + gtid] = len;\n"
	"	for (uint offset = 1; offset < THREAD_GROUP_X; offset *= 2)\n"
	"	{\n"
	"		pout = 1 - pout;\n"
	"		pin  = 1 - pin;\n"
	"		barrier();\n"
	"		temp[pout*THREAD_GROUP_X + gtid] = temp[pin*THREAD_GROUP_X + gtid];\n"
	"		if (gtid >= offset)\n"
	"			temp[pout*THREAD_GROUP_X + gtid] += temp[pin*THREAD_GROUP_X + gtid - offset];	\n"
	"	}\n"
	"	barrier();\n"
	"	len = temp[pout*THREAD_GROUP_X + gtid];\n"
	"	out_uvws[2*dtid + 1].x = len;\n"
	"	out_uvws[2*dtid + 1].y = V_SCALE;\n"
	"	out_uvws[2*dtid + 2].x = len;\n"
	"	out_uvws[2*dtid + 2].y = V_SCALE;\n"
	"	if (gtid == (THREAD_GROUP_X - 1))\n"
	"		out_uvws[gid].z = len;\n"
	"}\n"
; 


char const * const ogl2_cs_linepat_sum =
	"#version 430\n"
	"#define THREAD_GROUP_X 256\n"
	"struct FLOAT3\n"
	"{\n"
	"	float x;\n"
	"	float y;\n"
	"	float z;\n"
	"};\n"
	"layout(std430, binding=2) buffer BufferInOut\n"
	"{\n"
	"	FLOAT3 uvws[];\n"
	"};\n"
	"layout (local_size_x = THREAD_GROUP_X, local_size_y = 1, local_size_z = 1) in;\n"
	"void main()\n"
	"{\n"
	"	uint gid = gl_WorkGroupID.x;\n"
	"	uint dtid = gl_GlobalInvocationID.x;\n"
	"	float sums = 0.0;\n"
	"	for (uint i = 1; i <= gid; i++)\n"
	"		sums += uvws[gid-1].z;\n"
	"	float x = uvws[2*dtid+1].x;\n"
	"	float sum = x + sums;\n"
	"	uvws[2*dtid+1].x = sum;\n"
	"	uvws[2*dtid+2].x = sum;\n"
	"}\n"
; 


char const * const ogl2_geometry =
	"#extension GL_EXT_geometry_shader4 : enable\n"
	"void populate_input(out vertex_output vertex[gl_VerticesIn])\n"
	"{\n"
	"	for (int i = 0; i < gl_VerticesIn; i++) {\n"
	"		vertex[i].position = gl_PositionIn[i];\n"
	"		vertex[i].material_color_and_specular_intensity = OUT_COLOR0[i];\n"
	"		#ifdef EYE_POSITION_COORD\n"
	"			vertex[i].eye_position = EYE_POSITION_COORD_OUT[i];\n"
	"		#endif\n"
	"		#ifdef TANGENT_COORD\n"
	"			vertex[i].eye_tangent = TANGENT_COORD_OUT[i];\n"
	"		#endif\n"
	"		#ifdef PER_PIXEL_LIGHTING\n"
	"			vertex[i].eye_normal = OUT_COLOR1[i].xyz;\n"
	"		#else\n"
	"			#ifdef HAS_LIGHTING\n"
	"			vertex[i].diffuse_light_and_ambient_blend = OUT_COLOR1[i];\n"
	"			#endif // HAS_LIGHTING\n"
	"		#endif // PER_PIXEL_LIGHTING\n"
	"		#ifdef HAS_ATMOSPHERIC_ATTENUATION\n"
	"			clamp(vertex[i].fog, 0.0, 1.0) = OUT_FOG[i];\n"
	"		#endif\n"
	"		#ifdef HAS_VERTEX_FINDICES\n"
	"			vertex[i].findex = FINDEX_COORD_OUT[i].xy;\n"
	"		#endif\n"
	"		#if defined(WIDE_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"			vertex[i].wide_line_offset = OFFSET_COORD_OUT[i].xyz;\n"
	"		#endif\n"
	"		#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined(HAS_TEXTURE3D)\n"
	"			vertex[i].uvst0 = DIFFUSE_TEXTURE_INTERPOLATOR0_OUT[i].xyzw;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_TEXTURE3D)\n"
	"			vertex[i].uv0 = DIFFUSE_TEXTURE_INTERPOLATOR0_OUT[i].xy;\n"
	"		#endif\n"
	"		#ifndef SHARED_DIFFUSE_COORDS\n"
	"			#if (TEXTURE_COUNT > 1)\n"
	"				vertex[i].uv1 = DIFFUSE_TEXTURE_COORD1_OUT[i].xy;\n"
	"			#endif\n"
	"			#if (TEXTURE_COUNT > 2) \n"
	"				vertex[i].uv2 = DIFFUSE_TEXTURE_COORD2_OUT[i].xy;\n"
	"			#endif\n"
	"			#if (TEXTURE_COUNT > 3) \n"
	"				vertex[i].uv3 = DIFFUSE_TEXTURE_COORD3_OUT[i].xy;\n"
	"			#endif\n"
	"			#if (TEXTURE_COUNT > 4) \n"
	"				vertex[i].uv4 = DIFFUSE_TEXTURE_COORD4_OUT[i].xy;\n"
	"			#endif\n"
	"			#if (TEXTURE_COUNT > 5) \n"
	"				vertex[i].uv5 = DIFFUSE_TEXTURE_COORD5_OUT[i].xy;\n"
	"			#endif\n"
	"			#if (TEXTURE_COUNT > 6) \n"
	"				vertex[i].uv6 = DIFFUSE_TEXTURE_COORD6_OUT[i].xy;\n"
	"			#endif\n"
	"			#if (TEXTURE_COUNT > 7) \n"
	"				vertex[i].uv7 = DIFFUSE_TEXTURE_COORD7_OUT[i].xy;\n"
	"			#endif\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_TEXTURE3D)\n"
	"			vertex[i].buv0 = BACK_DIFFUSE_TEXTURE_INTERPOLATOR0_OUT[i].xy;\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 1)\n"
	"			vertex[i].buv1 = BACK_DIFFUSE_TEXTURE_COORD1_OUT[i].xy;\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 2) \n"
	"			vertex[i].buv2 = BACK_DIFFUSE_TEXTURE_COORD2_OUT[i].xy;\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 3) \n"
	"			vertex[i].buv3 = BACK_DIFFUSE_TEXTURE_COORD3_OUT[i].xy;\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 4) \n"
	"			vertex[i].buv4 = BACK_DIFFUSE_TEXTURE_COORD4_OUT[i].xy;\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 5) \n"
	"			vertex[i].buv5 = BACK_DIFFUSE_TEXTURE_COORD5_OUT[i].xy;\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 6) \n"
	"			vertex[i].buv6 = BACK_DIFFUSE_TEXTURE_COORD6_OUT[i].xy;\n"
	"		#endif\n"
	"		#if (BACK_TEXTURE_COUNT > 7) \n"
	"			vertex[i].buv7 = BACK_DIFFUSE_TEXTURE_COORD7_OUT[i].xy;\n"
	"		#endif\n"
	"		#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"			vertex[i].marker_uv = MARKER_TEXTURE_OUT[i].xy;\n"
	"			#ifdef SPRITE_MARKER\n"
	"				vertex[i].marker_size = MARKER_TEXTURE_OUT[i].z;\n"
	"			#endif\n"
	"		#endif\n"
	"		#ifdef SPRITE_MARKER\n"
	"			vertex[i].marker_size = OUT_PSIZE;\n"
	"		#endif\n"
	"		#if (SHADOW_MAP_COUNT > 0)\n"
	"			vertex[i].uvsm0 = SHADOW_MAP_COORD0_OUT[i];\n"
	"		#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"			vertex[i].screen_position = SHADOW_MAP_JITTER_COORD_OUT[i];\n"
	"		#endif\n"
	"		#endif\n"
	"		#if (SHADOW_MAP_COUNT > 1)\n"
	"			vertex[i].uvsm1 = SHADOW_MAP_COORD1_OUT[i];\n"
	"		#endif\n"
	"		#if (SHADOW_MAP_COUNT > 2)\n"
	"			vertex[i].uvsm2 = SHADOW_MAP_COORD2_OUT[i];\n"
	"		#endif\n"
	"		#if (SHADOW_MAP_COUNT > 3)\n"
	"			vertex[i].uvsm3 = SHADOW_MAP_COORD3_OUT[i];\n"
	"		#endif\n"
	"		#if (CUTTING_PLANE_COUNT > 0)\n"
	"			vertex[i].uvcp0 = CUTTING_PLANE_COORD0_OUT[i];\n"
	"		#endif\n"
	"		#if (CUTTING_PLANE_COUNT > 4)\n"
	"			vertex[i].uvcp1 = CUTTING_PLANE_COORD1_OUT[i];\n"
	"		#endif\n"
	"		#if (CUTTING_PLANE_COUNT > 8)\n"
	"			vertex[i].uvcp2 = CUTTING_PLANE_COORD2_OUT[i];\n"
	"		#endif\n"
	"		#if (CUTTING_PLANE_COUNT > 12)\n"
	"			vertex[i].uvcp3 = CUTTING_PLANE_COORD3_OUT[i];\n"
	"		#endif\n"
	"		#ifdef ENVIRONMENT_TEXTURE\n"
	"			#if !defined(CUBE_ENVIRONMENT_MAP) || !defined(PER_PIXEL_LIGHTING)\n"
	"				vertex[i].uvenv = ENVIRONMENT_TEXTURE_OUT[i].xyz;\n"
	"			#endif\n"
	"		#endif\n"
	"		#ifdef SPECULAR_TEXTURE\n"
	"			vertex[i].uvspec = SPECULAR_TEXTURE_OUT[i].xy;\n"
	"		#endif\n"
	"		#ifdef BUMP_TEXTURE\n"
	"			vertex[i].uvbump = BUMP_TEXTURE_OUT[i].xy;\n"
	"		#endif \n"
	"		#ifdef TRANSMISSION_TEXTURE\n"
	"			vertex[i].uvtransmission = TRANSMISSION_TEXTURE_OUT[i].xy;\n"
	"		#endif \n"
	"		#ifdef EMISSION_TEXTURE\n"
	"			vertex[i].uvemission = EMISSION_TEXTURE_OUT[i].xy;\n"
	"		#endif \n"
	"		#ifdef MIRROR_TEXTURE\n"
	"			vertex[i].uvmirror = MIRROR_TEXTURE_OUT[i].xy;\n"
	"		#endif \n"
	"		#if defined(DEPTH_PEELING) || defined(DEPTH_WRITING)\n"
	"			vertex[i].peel_position = DEPTH_PEELING_POSITION_COORD_OUT[i];\n"
	"		#endif\n"
	"		#ifdef HAS_FACE_PATTERN\n"
	"			vertex[i].uvzwfp = FACE_PATTERN_COORD_OUT[i];\n"
	"		#endif\n"
	"		#ifdef HAS_LINE_PATTERN\n"
	"			vertex[i].uvlp = LINE_PATTERN_COORD_OUT[i];\n"
	"		#endif\n"
	"		#ifdef GS_ELLIPTICAL_ARC\n"
	"			vertex[i].arc_param = GS_ELLIPTICAL_ARC_COORD_OUT[i].x;\n"
	"		#endif\n"
	"		vertex[i].InstanceID = InstanceID[i];\n"
	"	}\n"
	"}\n"
	"#undef OUT_COLOR0\n"
	"#undef OUT_COLOR1\n"
	"#undef OUT_TEXCOORD0\n"
	"#undef OUT_TEXCOORD1\n"
	"#undef OUT_TEXCOORD2\n"
	"#undef OUT_TEXCOORD3\n"
	"#undef OUT_TEXCOORD4\n"
	"#undef OUT_TEXCOORD5\n"
	"#undef OUT_TEXCOORD6\n"
	"#undef OUT_TEXCOORD7\n"
	"#undef OUT_FOG\n"
	"#define OUT_COLOR0		out_gs_color0\n"
	"#define OUT_COLOR1		out_gs_color1\n"
	"#define OUT_TEXCOORD0	out_gs_texcoord0\n"
	"#define OUT_TEXCOORD1	out_gs_texcoord1\n"
	"#define OUT_TEXCOORD2	out_gs_texcoord2\n"
	"#define OUT_TEXCOORD3	out_gs_texcoord3\n"
	"#define OUT_TEXCOORD4	out_gs_texcoord4\n"
	"#define OUT_TEXCOORD5	out_gs_texcoord5\n"
	"#define OUT_TEXCOORD6	out_gs_texcoord6\n"
	"#define OUT_TEXCOORD7	out_gs_texcoord7\n"
	"#define OUT_FOG			out_gs_fogcoord\n"
	"void export_pin(pixel_input vertex)\n"
	"{\n"
	"	gl_Position = vertex.position;\n"
	"	OUT_COLOR0 = vertex.material_color_and_specular_intensity;\n"
	"	EmitVertex();\n"
	"}\n"
	"void main()\n"
	"{\n"
	"	STREAM stream;\n"
	"	vertex_output points[gl_VerticesIn];\n"
	"	populate_input(points);\n"
	"#ifdef GS_ELLIPTICAL_ARC\n"
	"	elliptical_arc(points, stream);\n"
	"#endif\n"
	"#ifdef SPRITE_MARKER\n"
	"	point_splats(points, stream);\n"
	"#endif\n"
	"#ifdef HAS_DEFINED_MATERIAL_GS\n"
	"	material_geometry_shader(points, stream, 0);\n"
	"#endif\n"
	"}\n"
; 


char const * const ogl2_gs_header =
	"#ifndef GLSL_120\n"
	"	#ifdef OGL_ES		\n"
	"		precision lowp float;	//default for anything that doesn't specify otherwise\n"
	"	#else		\n"
	"		#if !defined(GLSL_130)\n"
	"			#extension GL_EXT_gpu_shader4 : enable\n"
	"		#endif\n"
	"	#endif\n"
	"#endif\n"
	"#define DRIVER_SPECIFIC_FLIP -1.0\n"
	"#define MUST_DEFINE_CLIP_FUNC\n"
	"#define BAD_VARIABLE_INDEX\n"
	"#define OPENGL2\n"
	"#define ddx dFdx\n"
	"#define ddy dFdy\n"
	"#define float2 vec2\n"
	"#define float3 vec3\n"
	"#define float4 vec4\n"
	"#define float2x2 mat2\n"
	"#define float3x3 mat3\n"
	"#define float4x4 mat4\n"
	"#define reg(a)\n"
	"#define semantic(a)\n"
	"#define static\n"
	"#define const\n"
	"#define row_major\n"
	"#define STREAM float\n"
	"#define HSampler2D sampler2D\n"
	"#define HSampler3D sampler3D\n"
	"#define HSamplerCUBE samplerCube\n"
	"#define tex2D(sampler,uv) texture2D(sampler,uv)\n"
	"#define tex3D(sampler,uv) texture3D(sampler,uv)\n"
	"#define texCUBE(sampler,uv) textureCube(sampler,uv)\n"
	"#define tex2Dgrad(sampler,uv,ddx,ddy) textureGrad(sampler,uv,ddx,ddy)\n"
	"#define mul(a,b) ((b) * (a))\n"
	"#define saturate(a) clamp((a),0.0,1.0)\n"
	"#define lerp(x,y,s) mix(x,y,s)\n"
	"#define frac(x)	fract(x)\n"
	"#define atan2(x,y) atan(y,x)\n"
	"#define STATIC_ARRAY_BEGIN(name,type,size) type name[size] = type[size] (\n"
	"#define STATIC_ARRAY_END )\n"
	"#define OUT_POSITION	gl_Position\n"
	"#define OUT_PSIZE		gl_PointSize\n"
	"#ifdef OPENGL_FLAT_SHADING\n"
	"	flat in float4 out_color0[gl_VerticesIn];\n"
	"	flat in float4 out_color1[gl_VerticesIn];\n"
	"#else \n"
	"	in float4 out_color0[gl_VerticesIn];\n"
	"	in float4 out_color1[gl_VerticesIn];\n"
	"#endif\n"
	"in float4 out_texcoord0[gl_VerticesIn];\n"
	"in float4 out_texcoord1[gl_VerticesIn];\n"
	"in float4 out_texcoord2[gl_VerticesIn];\n"
	"in float4 out_texcoord3[gl_VerticesIn];\n"
	"in float4 out_texcoord4[gl_VerticesIn];\n"
	"in float4 out_texcoord5[gl_VerticesIn];\n"
	"in float4 out_texcoord6[gl_VerticesIn];\n"
	"in float4 out_texcoord7[gl_VerticesIn];\n"
	"in float out_fogcoord[gl_VerticesIn];\n"
	"in uint InstanceID[gl_VerticesIn];\n"
	"out float4 out_gs_color0;\n"
	"out float4 out_gs_color1;\n"
	"out float4 out_gs_texcoord0;\n"
	"out float4 out_gs_texcoord1;\n"
	"out float4 out_gs_texcoord2;\n"
	"out float4 out_gs_texcoord3;\n"
	"out float4 out_gs_texcoord4;\n"
	"out float4 out_gs_texcoord5;\n"
	"out float4 out_gs_texcoord6;\n"
	"out float4 out_gs_texcoord7;\n"
	"out float out_gs_fogcoord;\n"
	"#define OUT_COLOR0		out_color0\n"
	"#define OUT_COLOR1		out_color1\n"
	"#define OUT_TEXCOORD0	out_texcoord0\n"
	"#define OUT_TEXCOORD1	out_texcoord1\n"
	"#define OUT_TEXCOORD2	out_texcoord2\n"
	"#define OUT_TEXCOORD3	out_texcoord3\n"
	"#define OUT_TEXCOORD4	out_texcoord4\n"
	"#define OUT_TEXCOORD5	out_texcoord5\n"
	"#define OUT_TEXCOORD6	out_texcoord6\n"
	"#define OUT_TEXCOORD7	out_texcoord7\n"
	"#define OUT_FOG			out_fogcoord\n"
	"#define BEGIN_CBUFFER(a)\n"
	"#define END_CBUFFER\n"
	"#define AppendVertex(stream, p) export_pin(p)\n"
	"#define RestartPrimitive(stream) EndPrimitive()\n"
; 


char const * const ogl2_header =
	"#ifdef OGL_ES\n"
	"	#define uint int\n"
	"	#ifdef OPENGL_PIXEL_SHADER\n"
	"		precision mediump float;		\n"
	"	#endif\n"
	"	#define LOWP lowp\n"
	"	#define MEDP mediump\n"
	"	#define HIGHP highp\n"
	"#else\n"
	"	#define LOWP\n"
	"	#define MEDP\n"
	"	#define HIGHP\n"
	"#if (GLSL_VERSION >= 130)\n"
	"	#if (GLSL_VERSION >= 140 && GL_EXT_gpu_shader4)		\n"
	"		#extension GL_EXT_gpu_shader4 : enable\n"
	"	#endif\n"
	"	#if (GLSL_VERSION >= 150 && GL_ARB_gpu_shader5)\n"
	"		#extension GL_ARB_gpu_shader5 : enable\n"
	"	#endif	\n"
	"#endif\n"
	"#endif\n"
	"const float DRIVER_SPECIFIC_FLIP = -1.0;\n"
	"#define MUST_DEFINE_CLIP_FUNC\n"
	"#define BAD_VARIABLE_INDEX\n"
	"#define OPENGL2\n"
	"#define ddx dFdx\n"
	"#define ddy dFdy\n"
	"#define float2 vec2\n"
	"#define float3 vec3\n"
	"#define float4 vec4\n"
	"#define float2x2 mat2\n"
	"#define float3x3 mat3\n"
	"#define float4x4 mat4\n"
	"#define double2 dvec2\n"
	"#define double3 dvec3\n"
	"#define double4 dvec4\n"
	"#define double4x4 dmat4\n"
	"#define int2 ivec2\n"
	"#define int3 ivec3\n"
	"#define int4 ivec4\n"
	"#define uint2 uvec2\n"
	"#define uint3 uvec3\n"
	"#define uint4 uvec4\n"
	"#define reg(a)\n"
	"#define semantic(a)\n"
	"#define static\n"
	"#define const\n"
	"#define row_major\n"
	"#define HSampler2D sampler2D\n"
	"#define HSampler3D sampler3D\n"
	"#define HSamplerCUBE samplerCube\n"
	"#ifdef OGL_ES\n"
	"	#if (__VERSION__ == 300)\n"
	"		#define tex2D(sampler,uv) texture(sampler,uv)\n"
	"		#define tex3D(sampler,uv) texture(sampler,uv)\n"
	"		#define texCUBE(sampler,uv) texture(sampler,uv)\n"
	"		#define tex2Dgrad(sampler,uv,ddx,ddy) textureGrad(sampler,uv,ddx,ddy)\n"
	"	#else\n"
	"		#define tex2D(sampler,uv) texture2D(sampler,uv)\n"
	"		#define tex3D(sampler,uv) texture3D(sampler,uv)\n"
	"		#define texCUBE(sampler,uv) textureCube(sampler,uv)\n"
	"		#define tex2Dgrad(sampler,uv,ddx,ddy) texture2D(sampler,uv)\n"
	"	#endif\n"
	"#else\n"
	"	#if (GLSL_VERSION <= 120)\n"
	"		#define tex2D(sampler,uv) texture2D(sampler,uv)\n"
	"		#define tex3D(sampler,uv) texture3D(sampler,uv)\n"
	"		#define texCUBE(sampler,uv) textureCube(sampler,uv)\n"
	"		#define tex2Dgrad(sampler,uv,ddx,ddy) texture2D(sampler,uv)\n"
	"	#else\n"
	"		#define tex2D(sampler,uv) texture(sampler,uv)\n"
	"		#define tex3D(sampler,uv) texture(sampler,uv)\n"
	"		#define texCUBE(sampler,uv) texture(sampler,uv)\n"
	"		#define tex2Dgrad(sampler,uv,ddx,ddy) textureGrad(sampler,uv,ddx,ddy)\n"
	"	#endif\n"
	"#endif\n"
	"#define mul(a,b) ((b) * (a))\n"
	"#define saturate(a) clamp((a),0.0,1.0)\n"
	"#define lerp(x,y,s) mix(x,y,s)\n"
	"#define frac(x)	fract(x)\n"
	"#define atan2(x,y) atan(y,x)\n"
	"#define STATIC_ARRAY_BEGIN(name,type,size) const type name[size] = type[size] (\n"
	"#define STATIC_ARRAY_END )\n"
	"#define OUT_POSITION	gl_Position\n"
	"#define OUT_PSIZE		gl_PointSize\n"
	"#if (GLSL_VERSION <= 120)\n"
	"	#ifdef OPENGL_PIXEL_SHADER\n"
	"		#define OUT_COLOR0		gl_Color\n"
	"		#define OUT_COLOR1		gl_SecondaryColor\n"
	"	#else\n"
	"		#define OUT_COLOR0		gl_FrontColor\n"
	"		#define OUT_COLOR1		gl_FrontSecondaryColor\n"
	"	#endif\n"
	"	#define VARYING		varying\n"
	"	#define OUT_TEXCOORD0	gl_TexCoord[0]\n"
	"	#define OUT_TEXCOORD1	gl_TexCoord[1]\n"
	"	#define OUT_TEXCOORD2	gl_TexCoord[2]\n"
	"	#define OUT_TEXCOORD3	gl_TexCoord[3]\n"
	"	#define OUT_TEXCOORD4	gl_TexCoord[4]\n"
	"	#define OUT_TEXCOORD5	gl_TexCoord[5]\n"
	"	#define OUT_TEXCOORD6	gl_TexCoord[6]\n"
	"	#define OUT_TEXCOORD7	gl_TexCoord[7]\n"
	"	#define OUT_FOG			gl_FogFragCoord\n"
	"#else\n"
	"    #ifdef OGL_ES\n"
	"		#if (__VERSION__ == 300)\n"
	"			#ifdef OPENGL_PIXEL_SHADER\n"
	"				#define VARYING in\n"
	"			#else\n"
	"				#define VARYING out\n"
	"			#endif\n"
	"		#else\n"
	"			#ifdef OPENGL_PIXEL_SHADER\n"
	"				#define VARYING varying\n"
	"			#else\n"
	"				#define VARYING varying\n"
	"			#endif\n"
	"		#endif\n"
	"	#else\n"
	"		#ifdef OPENGL_PIXEL_SHADER\n"
	"			#define VARYING in\n"
	"		#else\n"
	"			#define VARYING out\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef OPENGL_FLAT_SHADING\n"
	"		flat VARYING float4 out_color0;\n"
	"		flat VARYING float4 out_color1;\n"
	"	#else \n"
	"		VARYING float4 out_color0;\n"
	"		VARYING float4 out_color1;\n"
	"	#endif\n"
	"	VARYING float4 out_texcoord0;\n"
	"	VARYING float4 out_texcoord1;\n"
	"	VARYING float4 out_texcoord2;\n"
	"	VARYING float4 out_texcoord3;\n"
	"	VARYING float4 out_texcoord4;\n"
	"	VARYING float4 out_texcoord5;\n"
	"	VARYING float4 out_texcoord6;\n"
	"	VARYING float4 out_texcoord7;\n"
	"	VARYING float out_fogcoord;\n"
	"	#ifndef OGL_ES\n"
	"		flat VARYING uint InstanceID;\n"
	"	#endif\n"
	"	#define OUT_COLOR0		out_color0\n"
	"	#define OUT_COLOR1		out_color1\n"
	"	#define OUT_TEXCOORD0	out_texcoord0\n"
	"	#define OUT_TEXCOORD1	out_texcoord1\n"
	"	#define OUT_TEXCOORD2	out_texcoord2\n"
	"	#define OUT_TEXCOORD3	out_texcoord3\n"
	"	#define OUT_TEXCOORD4	out_texcoord4\n"
	"	#define OUT_TEXCOORD5	out_texcoord5\n"
	"	#define OUT_TEXCOORD6	out_texcoord6\n"
	"	#define OUT_TEXCOORD7	out_texcoord7\n"
	"	#define OUT_FOG			out_fogcoord\n"
	"#endif\n"
	"#define H3D_BRANCH_HINT\n"
	"#define H3D_LOOP_HINT\n"
	"#define BEGIN_CBUFFER(a)\n"
	"#define END_CBUFFER\n"
; 


char const * const ogl2_oit_pixel =
	"#version 430\n"
	"layout(r32ui, binding = 0) uniform readonly uimageBuffer headPtrs;\n"
	"layout(rgba32ui, binding = 1) uniform readonly uimageBuffer data;\n"
	"uniform uint Width;\n"
	"layout(location = 0) out vec4 final_color0;\n"
	"#define MAX_FRAGS 16\n"
	"void main()\n"
	"{\n"
	"	ivec2 coord = ivec2(gl_FragCoord.xy);\n"
	"	int fragIndex = coord.y * int(Width) + coord.x;\n"
	"	uint head = imageLoad(headPtrs, fragIndex).r;\n"
	"	int fragCount = 0;\n"
	"	uvec4 frags[MAX_FRAGS];	\n"
	"	uint sample_bit = 1 << gl_SampleID;\n"
	"	while (head != 0 && fragCount < MAX_FRAGS)\n"
	"	{\n"
	"		uvec4 frag = imageLoad(data, int(head));\n"
	"		uint coverage = frag.a;\n"
	"		if ((coverage & sample_bit) != 0)\n"
	"		{\n"
	"			frags[fragCount++] = frag;			\n"
	"		}\n"
	"		head = frag.z;\n"
	"	}	\n"
	"	for (int j = 1; j < fragCount; ++j)\n"
	"	{\n"
	"		uvec4 frag = frags[j];\n"
	"		int i = j - 1;\n"
	"		while (i >= 0 && frags[i].y > frag.y)\n"
	"		{\n"
	"			frags[i + 1] = frags[i];\n"
	"			--i;\n"
	"		}\n"
	"		frags[i + 1] = frag;\n"
	"	}\n"
	"	vec4 color = vec4(0, 0, 0, 0);\n"
	"	for (int i = fragCount - 1; i >= 0; --i)\n"
	"	{\n"
	"		vec4 c = unpackUnorm4x8(frags[i].x);\n"
	"		color *= (1.0 - c.a);\n"
	"		c.rgb *= c.a;\n"
	"		color += c;\n"
	"	}\n"
	"	final_color0 = vec4(color);\n"
	"}\n"
; 


char const * const ogl2_oit_vertex =
	"#version 430\n"
	"in vec3 _in_position;\n"
	"void main()\n"
	"{\n"
	"	gl_Position = vec4(_in_position, 1.0);\n"
	"}\n"
; 


char const * const ogl2_pixel =
	"#if defined(PIXEL_SHADER) && defined(HAS_GEOMETRY_SHADER)\n"
	"	VARYING float4 out_gs_color0;\n"
	"	VARYING float4 out_gs_color1;\n"
	"	VARYING float4 out_gs_texcoord0;\n"
	"	VARYING float4 out_gs_texcoord1;\n"
	"	VARYING float4 out_gs_texcoord2;\n"
	"	VARYING float4 out_gs_texcoord3;\n"
	"	VARYING float4 out_gs_texcoord4;\n"
	"	VARYING float4 out_gs_texcoord5;\n"
	"	VARYING float4 out_gs_texcoord6;\n"
	"	VARYING float4 out_gs_texcoord7;\n"
	"	VARYING float out_gs_fogcoord;\n"
	"	#undef OUT_COLOR0\n"
	"	#undef OUT_COLOR1\n"
	"	#undef OUT_TEXCOORD0\n"
	"	#undef OUT_TEXCOORD1\n"
	"	#undef OUT_TEXCOORD2\n"
	"	#undef OUT_TEXCOORD3\n"
	"	#undef OUT_TEXCOORD4\n"
	"	#undef OUT_TEXCOORD5\n"
	"	#undef OUT_TEXCOORD6\n"
	"	#undef OUT_TEXCOORD7\n"
	"	#undef OUT_FOG\n"
	"	#define OUT_COLOR0		out_gs_color0\n"
	"	#define OUT_COLOR1		out_gs_color1\n"
	"	#define OUT_TEXCOORD0	out_gs_texcoord0\n"
	"	#define OUT_TEXCOORD1	out_gs_texcoord1\n"
	"	#define OUT_TEXCOORD2	out_gs_texcoord2\n"
	"	#define OUT_TEXCOORD3	out_gs_texcoord3\n"
	"	#define OUT_TEXCOORD4	out_gs_texcoord4\n"
	"	#define OUT_TEXCOORD5	out_gs_texcoord5\n"
	"	#define OUT_TEXCOORD6	out_gs_texcoord6\n"
	"	#define OUT_TEXCOORD7	out_gs_texcoord7\n"
	"	#define OUT_FOG			out_gs_fogcoord\n"
	"#endif\n"
	"#if (GLSL_VERSION <= 120) // desktop <= 120\n"
	"	#define FINAL_COLOR0 gl_FragData[0]\n"
	"	#define FINAL_COLOR1 gl_FragData[1]\n"
	"	#define FINAL_COLOR2 gl_FragData[2]\n"
	"#else\n"
	"	#ifdef OGL_ES		\n"
	"		#if (__VERSION__ == 300) // ES 300\n"
	"			layout(location=0) out float4 final_color0;\n"
	"			layout(location=1) out float4 final_color1;\n"
	"			layout(location=2) out float4 final_color2;\n"
	"			#define FINAL_COLOR0 final_color0\n"
	"			#define FINAL_COLOR1 final_color1\n"
	"			#define FINAL_COLOR2 final_color2		\n"
	"		#else // ES 100\n"
	"			#define FINAL_COLOR0 gl_FragData[0]\n"
	"			#define FINAL_COLOR1 gl_FragData[1]\n"
	"			#define FINAL_COLOR2 gl_FragData[2]\n"
	"		#endif	\n"
	"	#else // desktop > 120\n"
	"		out float4 final_color0;\n"
	"		out float4 final_color1;\n"
	"		out float4 final_color2;\n"
	"		#define FINAL_COLOR0 final_color0\n"
	"		#define FINAL_COLOR1 final_color1\n"
	"		#define FINAL_COLOR2 final_color2\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef SELECTION_BITMAP\n"
	"#define Mask 1023\n"
	"#define Shift 10\n"
	"uint table(uint index)\n"
	"{\n"
	"	int2 coords = int2(index & Mask, index >> Shift);\n"
	"	return texelFetch(SelectionTableSampler0, coords, 0).x;\n"
	"}\n"
	"void decode(uint hi, uint lo, out uint word, out uint bit)\n"
	"{\n"
	"	uint geom_shift		= table(hi * 6 + 0);	\n"
	"	uint geom_mask		= table(hi * 6 + 1);	\n"
	"	uint subgeom_shift	= table(hi * 6 + 2);	\n"
	"	uint subgeom_mask	= table(hi * 6 + 3);	\n"
	"	uint face_mask		= table(hi * 6 + 4);	\n"
	"	uint index			= table(hi * 6 + 5);	// Where in the texture to find the geometry table for this path\n"
	"	uint geom = geom_mask & (lo >> geom_shift);\n"
	"	uint subgeom = subgeom_mask & (lo >> subgeom_shift);\n"
	"	uint face = face_mask & lo;\n"
	"	index += geom * (1+subgeom_mask);\n"
	"	index += subgeom;\n"
	"	uint start = table(index);\n"
	"	face = face + start;\n"
	"	bit = 1 << (face & 31);						// Convert index to word/bit-within-word address\n"
	"	word = face >> 5;\n"
	"}\n"
	"bool hi_is_selected(uint hi, uint lo) \n"
	"{\n"
	"	uint word, bit;\n"
	"	decode(hi, lo, word, bit);\n"
	"	int2 coords = int2(word&Mask, word>>Shift);\n"
	"	uint bits = texelFetch(SelectionBitmapSampler0, coords, 0).x;\n"
	"	return 0 != (bits & bit);\n"
	"}\n"
	"#endif // SELECTION_BITMAP\n"
	"#ifdef OIT\n"
	"layout(early_fragment_tests) in;\n"
	"uniform uint Width;\n"
	"uniform uint MaxFragments;\n"
	"layout(binding = 0, offset = 0) uniform atomic_uint allocOffset;\n"
	"layout(r32ui, binding = 0) uniform uimageBuffer headPtrs;\n"
	"layout(rgba32ui, binding = 1) uniform uimageBuffer data;\n"
	"void addFragment(vec4 color)\n"
	"{\n"
	"	ivec2 coord = ivec2(gl_FragCoord.xy);\n"
	"	int fragIndex = coord.y * int(Width) + coord.x;\n"
	"	uint nodeAlloc = atomicCounterIncrement(allocOffset);\n"
	"	if (nodeAlloc < MaxFragments)\n"
	"	{\n"
	"		uint currentHead = imageAtomicExchange(headPtrs, fragIndex, nodeAlloc).r;\n"
	"		uint c = packUnorm4x8(color);\n"
	"		uint d = uint(gl_FragCoord.z * (0x00FFFFFF - 1));\n"
	"		imageStore(data, int(nodeAlloc), uvec4(c, d, currentHead, gl_SampleMaskIn[0]));\n"
	"	}\n"
	"}\n"
	"#endif\n"
	"void main()\n"
	"{\n"
	"	pixel_input result;\n"
	"	#if defined(WIDE_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"		result.wide_line_offset = OFFSET_COORD_OUT.xyz;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 0)\n"
	"		result.uvcp0 = CUTTING_PLANE_COORD0_OUT;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 4)\n"
	"		result.uvcp1 = CUTTING_PLANE_COORD1_OUT;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 8)\n"
	"		result.uvcp2 = CUTTING_PLANE_COORD2_OUT;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 12)\n"
	"		result.uvcp3 = CUTTING_PLANE_COORD3_OUT;\n"
	"	#endif\n"
	"#ifndef CREATE_SHADOW_MAP\n"
	"	result.material_color_and_specular_intensity = OUT_COLOR0;\n"
	"	#ifdef EYE_POSITION_COORD\n"
	"		result.eye_position = EYE_POSITION_COORD_OUT;\n"
	"	#endif\n"
	"	#ifdef TANGENT_COORD\n"
	"		result.eye_tangent = TANGENT_COORD_OUT;\n"
	"	#endif\n"
	"	#ifdef PER_PIXEL_LIGHTING\n"
	"		#ifndef SPHERE_MARKER\n"
	"			result.eye_normal = OUT_COLOR1.xyz;\n"
	"		#endif\n"
	"	#else\n"
	"		#ifdef HAS_LIGHTING\n"
	"		result.diffuse_light_and_ambient_blend = OUT_COLOR1;\n"
	"		#endif // HAS_LIGHTING\n"
	"	#endif // PER_PIXEL_LIGHTING\n"
	"	#ifdef HAS_ATMOSPHERIC_ATTENUATION\n"
	"		result.fog = OUT_FOG;\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_FINDICES\n"
	"		result.findex = FINDEX_COORD_OUT.xy;\n"
	"	#endif\n"
	"	#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined(HAS_TEXTURE3D)\n"
	"		result.uvst0 = DIFFUSE_TEXTURE_INTERPOLATOR0_OUT.xyzw;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		result.uv0 = DIFFUSE_TEXTURE_INTERPOLATOR0_OUT.xy;\n"
	"	#endif\n"
	"	#ifndef SHARED_DIFFUSE_COORDS\n"
	"		#if (TEXTURE_COUNT > 1)\n"
	"			result.uv1 = DIFFUSE_TEXTURE_COORD1_OUT.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 2) \n"
	"			result.uv2 = DIFFUSE_TEXTURE_COORD2_OUT.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 3) \n"
	"			result.uv3 = DIFFUSE_TEXTURE_COORD3_OUT.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 4) \n"
	"			result.uv4 = DIFFUSE_TEXTURE_COORD4_OUT.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 5) \n"
	"			result.uv5 = DIFFUSE_TEXTURE_COORD5_OUT.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 6) \n"
	"			result.uv6 = DIFFUSE_TEXTURE_COORD6_OUT.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 7) \n"
	"			result.uv7 = DIFFUSE_TEXTURE_COORD7_OUT.xy;\n"
	"		#endif\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		result.buv0 = BACK_DIFFUSE_TEXTURE_INTERPOLATOR0_OUT.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 1)\n"
	"		result.buv1 = BACK_DIFFUSE_TEXTURE_COORD1_OUT.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 2) \n"
	"		result.buv2 = BACK_DIFFUSE_TEXTURE_COORD2_OUT.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 3) \n"
	"		result.buv3 = BACK_DIFFUSE_TEXTURE_COORD3_OUT.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 4) \n"
	"		result.buv4 = BACK_DIFFUSE_TEXTURE_COORD4_OUT.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 5) \n"
	"		result.buv5 = BACK_DIFFUSE_TEXTURE_COORD5_OUT.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 6) \n"
	"		result.buv6 = BACK_DIFFUSE_TEXTURE_COORD6_OUT.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 7) \n"
	"		result.buv7 = BACK_DIFFUSE_TEXTURE_COORD7_OUT.xy;\n"
	"	#endif\n"
	"	#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"		#ifdef SPRITE_MARKER\n"
	"			result.marker_uv = gl_PointCoord;\n"
	"		#else\n"
	"			result.marker_uv = MARKER_TEXTURE_OUT.xy;\n"
	"		#endif\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 0)\n"
	"		result.uvsm0 = SHADOW_MAP_COORD0_OUT;\n"
	"	#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"		result.screen_position = SHADOW_MAP_JITTER_COORD_OUT;\n"
	"	#endif\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 1)\n"
	"		result.uvsm1 = SHADOW_MAP_COORD1_OUT;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 2)\n"
	"		result.uvsm2 = SHADOW_MAP_COORD2_OUT;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 3)\n"
	"		result.uvsm3 = SHADOW_MAP_COORD3_OUT;\n"
	"	#endif\n"
	"	#ifdef ENVIRONMENT_TEXTURE\n"
	"		#if !defined(CUBE_ENVIRONMENT_MAP) || !defined(PER_PIXEL_LIGHTING)\n"
	"			result.uvenv = ENVIRONMENT_TEXTURE_OUT.xyz;\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		result.uvspec = SPECULAR_TEXTURE_OUT.xy;\n"
	"	#endif\n"
	"	#ifdef BUMP_TEXTURE\n"
	"		result.uvbump = BUMP_TEXTURE_OUT.xy;\n"
	"	#endif\n"
	"	#ifdef TRANSMISSION_TEXTURE\n"
	"		result.uvtransmission = TRANSMISSION_TEXTURE_OUT.xy;\n"
	"	#endif \n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		result.uvemission = EMISSION_TEXTURE_OUT.xy;\n"
	"	#endif \n"
	"	#ifdef MIRROR_TEXTURE\n"
	"		result.uvmirror = MIRROR_TEXTURE_OUT.xy;\n"
	"	#endif \n"
	"	#if defined(DEPTH_PEELING) || defined(DEPTH_WRITING)\n"
	"		result.peel_position = DEPTH_PEELING_POSITION_COORD_OUT;\n"
	"	#endif\n"
	"	#ifdef HAS_FACE_PATTERN\n"
	"		result.uvzwfp = FACE_PATTERN_COORD_OUT;\n"
	"	#endif\n"
	"	#ifdef HAS_LINE_PATTERN\n"
	"		result.uvlp = LINE_PATTERN_COORD_OUT;\n"
	"	#endif\n"
	"#else // CREATE_SHADOW_MAP\n"
	"	result.shadow_position = OUT_TEXCOORD4;\n"
	"#endif // ndef CREATE_SHADOW_MAP\n"
	"#if (SHADER_MODEL >= 3)\n"
	"	float facing = gl_FrontFacing ? -1.0 : 1.0;\n"
	"#endif // SHADER_MODEL >= 3\n"
	"#if (SHADER_MODEL >= 4)\n"
	"	uint PrimitiveIndex = uint(gl_PrimitiveID);\n"
	"#endif\n"
	"	vec4 color;\n"
	"	pixel_common (\n"
	"		result\n"
	"		, color\n"
	"	#if (SHADER_MODEL >= 3)\n"
	"		, facing\n"
	"	#endif // SHADER_MODEL >= 3\n"
	"	#if (SHADER_MODEL >= 4)\n"
	"		, PrimitiveIndex\n"
	"	#endif\n"
	"	#if defined(DEPTH_WRITING) && defined(DEPTH_WRITING_SINGLE_PASS)\n"
	"		, FINAL_DEPTH\n"
	"	#endif // DEPTH_WRITING_SINGLE_PASS && DEPTH_WRITING \n"
	"	#if defined(SELECTION_HAS_LO)\n"
	"		, FINAL_COLOR1\n"
	"	#endif // SELECTION_HAS_LO\n"
	"	#ifdef WRITING_SSAA_LINE_TARGET\n"
	"		, FINAL_LINE_COLOR\n"
	"	#endif\n"
	"	);\n"
	"#ifdef OIT	\n"
	"	addFragment(color);\n"
	"	FINAL_COLOR0 = vec4(1.0); // is this necessary?\n"
	"#else\n"
	"	FINAL_COLOR0 = color;\n"
	"	#if !defined(DEPTH_WRITING) && (__VERSION__ > 100) && !defined(WRITING_SSAA_LINE_TARGET)\n"
	"	#if	!defined(SELECTION_HAS_LO)\n"
	"		FINAL_COLOR1 = float4(0.0, 0.0, 0.0, 0.0);\n"
	"	#endif\n"
	"	#endif\n"
	"#endif\n"
	"}\n"
; 


char const * const ogl2_post_header =
	"#define Texture2D float\n"
	"#if (GLSL_VERSION <= 120) // desktop <= 120\n"
	"	#define htex2dlod(id, uv) texture2D(id, (uv).xy) //texture2DLod(id, uv.xy, uv.w)\n"
	"	#define htex2d(id, uv) texture2D(id, uv)\n"
	"#else\n"
	"	#ifdef OGL_ES		\n"
	"		#if (__VERSION__ == 300) // ES 300\n"
	"			#define htex2d(id, uv) texture(id, uv)\n"
	"			#define htex2dlod(id, uv) textureLod(id, uv.xy, uv.w)\n"
	"		#else // ES 100\n"
	"			#define htex2dlod(id, uv) texture2D(id, (uv).xy)\n"
	"			#define htex2d(id, uv) texture2D(id, uv)\n"
	"		#endif	\n"
	"	#else // desktop > 120\n"
	"		#define htex2d(id, uv) texture(id, uv)\n"
	"		#define htex2dlod(id, uv) textureLod(id, uv.xy, uv.w)\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef DEPTH_PACKING_RGBA\n"
	"float unpack_rgba(const float4 value)\n"
	"{\n"
	"#define RADIX 255.0\n"
	"	const float4 shift = float4(1.0, 1.0/RADIX, 1.0/(RADIX*RADIX),  1.0/(RADIX*RADIX*RADIX)); \n"
	"#ifdef FULL_ENCODE\n"
	"	float mantissa = dot(value.xyz, shift.xyz);\n"
	"	float exponent = value.w * RADIX - 128;\n"
	"	return ldexp(mantissa, exponent);\n"
	"#else\n"
	"	return dot(value, shift);\n"
	"#endif\n"
	"#undef RADIX\n"
	"}\n"
	"#else\n"
	"#define unpack_rgba(x) x.r\n"
	"#endif\n"
; 


char const * const ogl2_post_pixel =
	"VARYING float4 texCoord0;\n"
	"#ifdef TEXCOORD_INPUT_2\n"
	"VARYING float4 texCoord1;\n"
	"#endif\n"
	"#if (GLSL_VERSION <= 120) // desktop <= 120\n"
	"	#define FINAL_COLOR0 gl_FragData[0]	\n"
	"#else\n"
	"	#ifdef OGL_ES		\n"
	"		#if (__VERSION__ == 300) // ES 300\n"
	"			layout(location=0) out float4 final_color0;			\n"
	"			#define FINAL_COLOR0 final_color0			\n"
	"		#else // ES 100\n"
	"			#define FINAL_COLOR0 gl_FragData[0]			\n"
	"		#endif	\n"
	"	#else // desktop > 120\n"
	"		out float4 final_color0;		\n"
	"		#define FINAL_COLOR0 final_color0		\n"
	"	#endif\n"
	"#endif\n"
	"void main()\n"
	"{\n"
	"	vec4 color;\n"
	"	post_pixel(\n"
	"		texCoord0.xy\n"
	"#ifdef TEXCOORD_INPUT_2\n"
	"		,texCoord1.xy\n"
	"#endif\n"
	"		,color\n"
	"#ifdef DEPTH_OUTPUT\n"
	"		,gl_FragDepth\n"
	"#endif\n"
	"	);\n"
	"	FINAL_COLOR0 = color;\n"
	"}\n"
; 


char const * const ogl2_post_vertex =
	"#if (GLSL_VERSION <= 120) // destkop <= 120\n"
	"	#define ATTRIB attribute\n"
	"#else\n"
	"	#ifdef OGL_ES			\n"
	"		#if (__VERSION__ == 300) // ES 300\n"
	"			#define ATTRIB in		\n"
	"		#else // ES 100\n"
	"			#define ATTRIB attribute\n"
	"		#endif		\n"
	"	#else // desktop > 120\n"
	"		#define ATTRIB in\n"
	"	#endif\n"
	"#endif\n"
	"ATTRIB float4 _in_position;\n"
	"VARYING float4 texCoord0;\n"
	"VARYING float4 texCoord1;\n"
	"uniform float ConstantDepth;\n"
	"uniform vec2 TexelOffset;\n"
	"void main()\n"
	"{\n"
	"	vec4 position = vec4(_in_position.xy,ConstantDepth,1.0);\n"
	"	gl_Position = position;\n"
	"	texCoord0 = position * 0.5 + 0.5;\n"
	"	texCoord1 = float4(0.0);\n"
	"} \n"
; 


char const * const ogl2_post_vertex_3d =
	"#if (GLSL_VERSION <= 120) // destkop <= 120\n"
	"	#define ATTRIB attribute\n"
	"#else\n"
	"	#ifdef OGL_ES			\n"
	"		#if (__VERSION__ == 300) // ES 300\n"
	"			#define ATTRIB in		\n"
	"		#else // ES 100\n"
	"			#define ATTRIB attribute\n"
	"		#endif		\n"
	"	#else // desktop > 120\n"
	"		#define ATTRIB in\n"
	"	#endif\n"
	"#endif\n"
	"ATTRIB float3 _in_position;\n"
	"VARYING float4 texCoord0;\n"
	"VARYING float4 texCoord1;\n"
	"uniform float ConstantDepth;\n"
	"uniform mat4 ModelToProjection;\n"
	"void main()\n"
	"{\n"
	"	float4 position = mul(float4(_in_position.xy,0.0,1.0), ModelToProjection);\n"
	"	gl_Position = float4(position.xy, ConstantDepth * position.w, position.w);\n"
	"	texCoord0.xy = _in_position.xy * 0.5 + 0.5;\n"
	"	texCoord0.y = 1.0 - texCoord0.y;\n"
	"	texCoord1 = position;\n"
	"} \n"
; 


char const * const ogl2_vertex =
	"#if (GLSL_VERSION <= 120) // destkop <= 120\n"
	"	#define ATTRIB attribute\n"
	"#else\n"
	"	#ifdef OGL_ES			\n"
	"		#if (__VERSION__ == 300) // ES 300\n"
	"			#define ATTRIB in		\n"
	"		#else // ES 100\n"
	"			#define ATTRIB attribute\n"
	"		#endif		\n"
	"	#else // desktop > 120\n"
	"		#define ATTRIB in\n"
	"	#endif\n"
	"#endif\n"
	"#ifdef HAS_DOUBLE_POSITIONS\n"
	"#if (GLSL_VERSION < 410)\n"
	"#extension GL_ARB_gpu_shader_fp64 : enable\n"
	"#extension GL_ARB_vertex_attrib_64bit : enable\n"
	"#endif\n"
	"ATTRIB double3 _in_position;\n"
	"#else\n"
	"ATTRIB float3 _in_position;\n"
	"#endif\n"
	"ATTRIB float3 _in_normal;\n"
	"ATTRIB float4 _in_color;\n"
	"ATTRIB float4 _in_secondary_color;\n"
	"ATTRIB float4 _in_texcoord0;\n"
	"ATTRIB float4 _in_texcoord1;\n"
	"ATTRIB float4 _in_texcoord2;\n"
	"ATTRIB float4 _in_texcoord3;\n"
	"ATTRIB float4 _in_texcoord4;\n"
	"ATTRIB float4 _in_texcoord5;\n"
	"ATTRIB float4 _in_texcoord6;\n"
	"ATTRIB float4 _in_texcoord7;\n"
	"#define TEXCOORD0		_in_texcoord0\n"
	"#define TEXCOORD1		_in_texcoord1\n"
	"#define TEXCOORD2		_in_texcoord2\n"
	"#define TEXCOORD3		_in_texcoord3\n"
	"#define TEXCOORD4		_in_texcoord4\n"
	"#define TEXCOORD5		_in_texcoord5\n"
	"#define TEXCOORD6		_in_texcoord6\n"
	"#define TEXCOORD7		_in_texcoord7\n"
	"void main()\n"
	"{	\n"
	"	vertex_input vertex;\n"
	"	vertex_output result;\n"
	"	vertex.position = _in_position;\n"
	"	#ifdef HAS_VERTEX_NORMALS\n"
	"		vertex.normal = _in_normal;\n"
	"	#endif\n"
	"	#ifdef TANGENT_COORD\n"
	"		vertex.tangent = TANGENT_COORD;\n"
	"	#endif\n"
	"	#ifdef WIDE_LINE\n"
	"		vertex.end = NEXT_COORD.xyz;\n"
	"		#ifdef MITERED_LINE\n"
	"			vertex.previous = PREV_COORD.xyz;	\n"
	"		#endif\n"
	"		vertex.offset = OFFSET_COORD;\n"
	"		#if defined(ROUND_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"			vertex.uv = ROUND_COORD;\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef PRIORITY_HSRA\n"
	"		vertex.priority = PRIORITY_HSRA_COORD.x;\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_COLORS\n"
	"		vertex.color = _in_color;\n"
	"	#endif\n"
	"	#ifdef HAS_AMBIENT_OCCLUSION\n"
	"		vertex.ambient_occlusion = _in_secondary_color;\n"
	"	#endif \n"
	"	#ifdef HAS_LINE_PATTERN\n"
	"		vertex.uvlp = LINE_PATTERN_COORD.xy;\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_FINDICES\n"
	"		vertex.findex = FINDEX_COORD.xy;\n"
	"	#endif\n"
	"	#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined(HAS_DEFINED_MATERIAL_GS) || defined(HAS_TEXTURE3D)\n"
	"		vertex.uvst0 = DIFFUSE_TEXTURE_COORD0.xyzw;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		vertex.uv0 = DIFFUSE_TEXTURE_COORD0.xy;\n"
	"	#endif\n"
	"	#ifndef SHARED_DIFFUSE_COORDS\n"
	"		#if (TEXTURE_COUNT > 1) \n"
	"			vertex.uv1 = DIFFUSE_TEXTURE_COORD1.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 2) \n"
	"			vertex.uv2 = DIFFUSE_TEXTURE_COORD2.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 3) \n"
	"			vertex.uv3 = DIFFUSE_TEXTURE_COORD3.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 4) \n"
	"			vertex.uv4 = DIFFUSE_TEXTURE_COORD4.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 5) \n"
	"			vertex.uv5 = DIFFUSE_TEXTURE_COORD5.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 6) \n"
	"			vertex.uv6 = DIFFUSE_TEXTURE_COORD6.xy;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 7) \n"
	"			vertex.uv7 = DIFFUSE_TEXTURE_COORD7.xy;\n"
	"		#endif\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 0)  && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		vertex.buv0 = BACK_DIFFUSE_TEXTURE_COORD0.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 1) \n"
	"		vertex.buv1 = BACK_DIFFUSE_TEXTURE_COORD1.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 2) \n"
	"		vertex.buv2 = BACK_DIFFUSE_TEXTURE_COORD2.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 3) \n"
	"		vertex.buv3 = BACK_DIFFUSE_TEXTURE_COORD3.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 4) \n"
	"		vertex.buv4 = BACK_DIFFUSE_TEXTURE_COORD4.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 5) \n"
	"		vertex.buv5 = BACK_DIFFUSE_TEXTURE_COORD5.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 6) \n"
	"		vertex.buv6 = BACK_DIFFUSE_TEXTURE_COORD6.xy;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 7) \n"
	"		vertex.buv7 = BACK_DIFFUSE_TEXTURE_COORD7.xy;\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		vertex.uvspec = SPECULAR_TEXTURE.xy;\n"
	"	#endif\n"
	"	#ifdef BUMP_TEXTURE\n"
	"		vertex.uvbump = BUMP_TEXTURE.xy;\n"
	"	#endif\n"
	"	#ifdef TRANSMISSION_TEXTURE\n"
	"		vertex.uvtransmission = TRANSMISSION_TEXTURE.xy;\n"
	"	#endif\n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		vertex.uvemission = EMISSION_TEXTURE.xy;\n"
	"	#endif\n"
	"	#ifdef MIRROR_TEXTURE\n"
	"		vertex.uvmirror = MIRROR_TEXTURE.xy;\n"
	"	#endif\n"
	"	#ifdef QUAD_MARKER\n"
	"		vertex.marker_offset = MARKER_TEXTURE.xy;\n"
	"	#endif\n"
	"	#ifdef HAS_GEOMETRY_SHADER\n"
	"		#ifdef GS_ELLIPTICAL_ARC\n"
	"			vertex.arc_param = GS_ELLIPTICAL_ARC_COORD.x;\n"
	"		#endif\n"
	"	#endif\n"
	"	result = vertex_common(vertex);\n"
	"	result.position.z = result.position.z*2.0 - 1.0*result.position.w;\n"
	"#ifdef SPRITE_MARKER\n"
	"	result.position.x += MarkerSize.y;\n"
	"	result.position.x -= MarkerSize.y;\n"
	"#endif\n"
	"#ifndef CREATE_SHADOW_MAP\n"
	"	OUT_POSITION = result.position;\n"
	"	OUT_COLOR0 = result.material_color_and_specular_intensity;\n"
	"	#ifdef EYE_POSITION_COORD\n"
	"		EYE_POSITION_COORD_OUT = result.eye_position;\n"
	"	#endif\n"
	"	#ifdef TANGENT_COORD\n"
	"		TANGENT_COORD_OUT = result.eye_tangent;\n"
	"	#endif\n"
	"	#ifdef PER_PIXEL_LIGHTING\n"
	"		#ifndef SPHERE_MARKER\n"
	"			OUT_COLOR1.xyz = result.eye_normal;\n"
	"		#endif\n"
	"	#else\n"
	"		#ifdef HAS_LIGHTING\n"
	"		OUT_COLOR1 = result.diffuse_light_and_ambient_blend;\n"
	"		#endif // HAS_LIGHTING\n"
	"	#endif // PER_PIXEL_LIGHTING\n"
	"	#ifdef HAS_ATMOSPHERIC_ATTENUATION\n"
	"		OUT_FOG = clamp(result.fog, 0.0, 1.0);\n"
	"	#endif\n"
	"	#ifdef HAS_VERTEX_FINDICES\n"
	"		FINDEX_COORD_OUT.xy = result.findex;\n"
	"	#endif\n"
	"	#if defined(WIDE_LINE) || defined(ANTI_ALIASED_LINE)\n"
	"		OFFSET_COORD_OUT.xyz = result.wide_line_offset;\n"
	"	#endif\n"
	"	#if defined(HAS_DEFINED_MATERIAL_SHADER) || defined(HAS_DEFINED_MATERIAL_GS) || defined(HAS_TEXTURE3D)\n"
	"		DIFFUSE_TEXTURE_INTERPOLATOR0_OUT.xyzw = result.uvst0;\n"
	"	#endif\n"
	"	#if (TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		DIFFUSE_TEXTURE_INTERPOLATOR0_OUT.xy = result.uv0;\n"
	"	#endif\n"
	"	#ifndef SHARED_DIFFUSE_COORDS\n"
	"		#if (TEXTURE_COUNT > 1)\n"
	"			DIFFUSE_TEXTURE_COORD1_OUT.xy = result.uv1;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 2) \n"
	"			DIFFUSE_TEXTURE_COORD2_OUT.xy = result.uv2;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 3) \n"
	"			DIFFUSE_TEXTURE_COORD3_OUT.xy = result.uv3;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 4) \n"
	"			DIFFUSE_TEXTURE_COORD4_OUT.xy = result.uv4;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 5) \n"
	"			DIFFUSE_TEXTURE_COORD5_OUT.xy = result.uv5;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 6) \n"
	"			DIFFUSE_TEXTURE_COORD6_OUT.xy = result.uv6;\n"
	"		#endif\n"
	"		#if (TEXTURE_COUNT > 7) \n"
	"			DIFFUSE_TEXTURE_COORD7_OUT.xy = result.uv7;\n"
	"		#endif\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 0) && !defined(HAS_DEFINED_MATERIAL_SHADER) && !defined(HAS_DEFINED_MATERIAL_GS) && !defined(HAS_TEXTURE3D)\n"
	"		BACK_DIFFUSE_TEXTURE_INTERPOLATOR0_OUT.xy = result.buv0;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 1)\n"
	"		BACK_DIFFUSE_TEXTURE_COORD1_OUT.xy = result.buv1;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 2) \n"
	"		BACK_DIFFUSE_TEXTURE_COORD2_OUT.xy = result.buv2;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 3) \n"
	"		BACK_DIFFUSE_TEXTURE_COORD3_OUT.xy = result.buv3;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 4) \n"
	"		BACK_DIFFUSE_TEXTURE_COORD4_OUT.xy = result.buv4;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 5) \n"
	"		BACK_DIFFUSE_TEXTURE_COORD5_OUT.xy = result.buv5;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 6) \n"
	"		BACK_DIFFUSE_TEXTURE_COORD6_OUT.xy = result.buv6;\n"
	"	#endif\n"
	"	#if (BACK_TEXTURE_COUNT > 7) \n"
	"		BACK_DIFFUSE_TEXTURE_COORD7_OUT.xy = result.buv7;\n"
	"	#endif\n"
	"	#if defined(CIRCLE_MARKER) || defined(TEXTURE_MARKER) || defined(MATERIAL_SHADER_MARKER)\n"
	"		MARKER_TEXTURE_OUT.xy = result.marker_uv;\n"
	"		#ifdef SPRITE_MARKER\n"
	"			MARKER_TEXTURE_OUT.z = result.marker_size;\n"
	"		#endif\n"
	"	#endif	\n"
	"	#ifdef POINT		\n"
	"		#ifdef SPRITE_MARKER\n"
	"			OUT_PSIZE = result.marker_size;	\n"
	"		#else\n"
	"			OUT_PSIZE = 1.0;\n"
	"		#endif\n"
	"	#endif\n"
	"	#if defined(LINE) && defined(DC)\n"
	"		OUT_PSIZE = 1.0;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 0)\n"
	"		SHADOW_MAP_COORD0_OUT = result.uvsm0;\n"
	"	#if defined(SHADOW_MAP_JITTER) || defined(SHADOW_MAP_SLICE_COUNT)\n"
	"		SHADOW_MAP_JITTER_COORD_OUT = result.screen_position;\n"
	"	#endif\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 1)\n"
	"		SHADOW_MAP_COORD1_OUT = result.uvsm1;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 2)\n"
	"		SHADOW_MAP_COORD2_OUT = result.uvsm2;\n"
	"	#endif\n"
	"	#if (SHADOW_MAP_COUNT > 3)\n"
	"		SHADOW_MAP_COORD3_OUT = result.uvsm3;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 0)\n"
	"		CUTTING_PLANE_COORD0_OUT = result.uvcp0;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 4)\n"
	"		CUTTING_PLANE_COORD1_OUT = result.uvcp1;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 8)\n"
	"		CUTTING_PLANE_COORD2_OUT = result.uvcp2;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 12)\n"
	"		CUTTING_PLANE_COORD3_OUT = result.uvcp3;\n"
	"	#endif\n"
	"	#ifdef ENVIRONMENT_TEXTURE\n"
	"		#if !defined(CUBE_ENVIRONMENT_MAP) || !defined(PER_PIXEL_LIGHTING)\n"
	"			ENVIRONMENT_TEXTURE_OUT.xyz = result.uvenv;\n"
	"		#endif\n"
	"	#endif\n"
	"	#ifdef SPECULAR_TEXTURE\n"
	"		SPECULAR_TEXTURE_OUT.xy = result.uvspec;\n"
	"	#endif\n"
	"	#ifdef BUMP_TEXTURE\n"
	"		BUMP_TEXTURE_OUT.xy = result.uvbump;\n"
	"	#endif \n"
	"	#ifdef TRANSMISSION_TEXTURE\n"
	"		TRANSMISSION_TEXTURE_OUT.xy = result.uvtransmission;\n"
	"	#endif \n"
	"	#ifdef EMISSION_TEXTURE\n"
	"		EMISSION_TEXTURE_OUT.xy = result.uvemission;\n"
	"	#endif \n"
	"	#ifdef MIRROR_TEXTURE\n"
	"		MIRROR_TEXTURE_OUT.xy = result.uvmirror;\n"
	"	#endif \n"
	"	#if defined(DEPTH_PEELING) || defined(DEPTH_WRITING)\n"
	"		DEPTH_PEELING_POSITION_COORD_OUT = result.peel_position;\n"
	"	#endif\n"
	"	#ifdef HAS_FACE_PATTERN\n"
	"		FACE_PATTERN_COORD_OUT = result.uvzwfp;\n"
	"	#endif\n"
	"	#ifdef HAS_LINE_PATTERN\n"
	"		LINE_PATTERN_COORD_OUT = result.uvlp;\n"
	"	#endif\n"
	"	#if defined(HAS_GEOMETRY_SHADER)\n"
	"		#ifdef GS_ELLIPTICAL_ARC\n"
	"			GS_ELLIPTICAL_ARC_COORD_OUT.x = result.arc_param;\n"
	"		#endif\n"
	"		InstanceID = gl_InstanceID;\n"
	"	#endif\n"
	"#else // CREATE_SHADOW_MAP\n"
	"	#if (CUTTING_PLANE_COUNT > 0)\n"
	"		CUTTING_PLANE_COORD0_OUT = result.uvcp0;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 4)\n"
	"		CUTTING_PLANE_COORD1_OUT = result.uvcp1;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 8)\n"
	"		CUTTING_PLANE_COORD2_OUT = result.uvcp2;\n"
	"	#endif\n"
	"	#if (CUTTING_PLANE_COUNT > 12)\n"
	"		CUTTING_PLANE_COORD3_OUT = result.uvcp3;\n"
	"	#endif\n"
	"	OUT_POSITION = result.position;\n"
	"	OUT_TEXCOORD4 = result.shadow_position;\n"
	"#endif // ndef CREATE_SHADOW_MAP\n"
	"}\n"
; 


