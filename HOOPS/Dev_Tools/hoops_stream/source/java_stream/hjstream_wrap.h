/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.40
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_HJSTREAM_WRAP_H_
#define SWIG_HJSTREAM_WRAP_H_

class SwigDirector_BBaseOpcodeHandler : public BBaseOpcodeHandler, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_BBaseOpcodeHandler(JNIEnv *jenv, int op);
    virtual ~SwigDirector_BBaseOpcodeHandler();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using BBaseOpcodeHandler::m_stage;
    using BBaseOpcodeHandler::m_progress;
    using BBaseOpcodeHandler::m_opcode;
    using BBaseOpcodeHandler::m_general_flags;
    using BBaseOpcodeHandler::m_needs_tag;
    using BBaseOpcodeHandler::m_debug_length;
    using BBaseOpcodeHandler::m_debug_allocated;
    using BBaseOpcodeHandler::m_ascii_size;
    using BBaseOpcodeHandler::m_ascii_length;
    using BBaseOpcodeHandler::m_ascii_stage;
    using BBaseOpcodeHandler::m_ascii_progress;
    using BBaseOpcodeHandler::m_byte;
    using BBaseOpcodeHandler::m_unsigned_short;
    using BBaseOpcodeHandler::m_int;
    using BBaseOpcodeHandler::m_char;
    using BBaseOpcodeHandler::GetData;
    using BBaseOpcodeHandler::GetGeneral;
    using BBaseOpcodeHandler::LookatData;
    using BBaseOpcodeHandler::PutData;
    using BBaseOpcodeHandler::PutOpcode;
    using BBaseOpcodeHandler::PutGeneral;
    using BBaseOpcodeHandler::flip;
    using BBaseOpcodeHandler::fix;
    using BBaseOpcodeHandler::fix_in;
    using BBaseOpcodeHandler::fix_out;
    using BBaseOpcodeHandler::log_opcode;
    using BBaseOpcodeHandler::floats_to_bytes;
    using BBaseOpcodeHandler::bytes_to_floats;
    using BBaseOpcodeHandler::add_segment;
    using BBaseOpcodeHandler::remove_segment;
    using BBaseOpcodeHandler::set_last_key;
    using BBaseOpcodeHandler::last_key;
    using BBaseOpcodeHandler::adjust_written;
    using BBaseOpcodeHandler::increase_nesting;
    using BBaseOpcodeHandler::decrease_nesting;
    using BBaseOpcodeHandler::Opcode_Handler;
    using BBaseOpcodeHandler::Record_Instance;
    using BBaseOpcodeHandler::Find_Instance;
    using BBaseOpcodeHandler::Remember_Item;
    using BBaseOpcodeHandler::Find_Item;
    using BBaseOpcodeHandler::validate_count;
    using BBaseOpcodeHandler::SkipNewlineAndTabs;
    using BBaseOpcodeHandler::ReadAsciiLine;
    using BBaseOpcodeHandler::ReadAsciiWord;
    using BBaseOpcodeHandler::ReadEndOpcode;
    using BBaseOpcodeHandler::RemoveAngularBrackets;
    using BBaseOpcodeHandler::RemoveQuotes;
    using BBaseOpcodeHandler::Read_Referenced_Segment;
    using BBaseOpcodeHandler::GetAsciiData;
    using BBaseOpcodeHandler::GetAsciiHex;
    using BBaseOpcodeHandler::GetAsciiImageData;
    using BBaseOpcodeHandler::PutAsciiOpcode;
    using BBaseOpcodeHandler::PutAsciiData;
    using BBaseOpcodeHandler::PutStartXMLTag;
    using BBaseOpcodeHandler::PutEndXMLTag;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Default : public TK_Default, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Default(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Default();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Default::m_buffer_count;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Unavailable : public TK_Unavailable, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Unavailable(JNIEnv *jenv, char opcode);
    virtual ~SwigDirector_TK_Unavailable();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Header : public TK_Header, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Header(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Header();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Header::m_current_object;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_File_Info : public TK_File_Info, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_File_Info(JNIEnv *jenv);
    virtual ~SwigDirector_TK_File_Info();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_File_Info::m_flags;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Comment : public TK_Comment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Comment(JNIEnv *jenv, char const *comment = 0);
    virtual ~SwigDirector_TK_Comment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Comment::m_length;
    using TK_Comment::m_allocated;
    using TK_Comment::set_comment;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Terminator : public TK_Terminator, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Terminator(JNIEnv *jenv, char opcode, bool is_file_terminator = true);
    virtual ~SwigDirector_TK_Terminator();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Terminator::m_terminate_file;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Compression : public TK_Compression, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Compression(JNIEnv *jenv, char opcode);
    virtual ~SwigDirector_TK_Compression();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Open_Segment : public TK_Open_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Open_Segment(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Open_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Open_Segment::m_length;
    using TK_Open_Segment::m_allocated;
    using TK_Open_Segment::set_segment;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Close_Segment : public TK_Close_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Close_Segment(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Close_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Reopen_Segment : public TK_Reopen_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Reopen_Segment(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Reopen_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Reopen_Segment::m_index;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Referenced_Segment : public TK_Referenced_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Referenced_Segment(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Referenced_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Referenced_Segment::m_length;
    using TK_Referenced_Segment::m_allocated;
    using TK_Referenced_Segment::m_cond_length;
    using TK_Referenced_Segment::m_cond_allocated;
    using TK_Referenced_Segment::m_key;
    using TK_Referenced_Segment::m_renumbered_key;
    using TK_Referenced_Segment::m_renumbered_scope;
    using TK_Referenced_Segment::m_referee;
    using TK_Referenced_Segment::m_follow;
    using TK_Referenced_Segment::m_filter;
    using TK_Referenced_Segment::m_referee_has_priority;
    using TK_Referenced_Segment::m_referee_priority;
    using TK_Referenced_Segment::set_segment;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Instance : public TK_Instance, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Instance(JNIEnv *jenv, int from_index = 0, int from_variant = 0, int to_index = 0, int to_variant = 0, int options = 0, float const xform[] = 0);
    virtual ~SwigDirector_TK_Instance();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Instance::m_from_index;
    using TK_Instance::m_from_variant;
    using TK_Instance::m_to_index;
    using TK_Instance::m_to_variant;
    using TK_Instance::m_options;
    using TK_Instance::m_matrix;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Delete_Object : public TK_Delete_Object, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Delete_Object(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Delete_Object();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Delete_Object::m_index;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_LOD : public TK_LOD, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_LOD(JNIEnv *jenv);
    virtual ~SwigDirector_TK_LOD();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_LOD::m_primitives;
    using TK_LOD::m_highest_level;
    using TK_LOD::m_levels_allocated;
    using TK_LOD::m_substage;
    using TK_LOD::m_current_working;
    using TK_LOD::m_current_level;
    using TK_LOD::ReadOneList;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Geometry_Attributes : public TK_Geometry_Attributes, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Geometry_Attributes(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Geometry_Attributes();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Renumber : public TK_Renumber, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Renumber(JNIEnv *jenv, unsigned char opcode, long key = 0);
    virtual ~SwigDirector_TK_Renumber();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Renumber::m_key;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Tag : public TK_Tag, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Tag(JNIEnv *jenv, unsigned char opcode = TKE_Tag);
    virtual ~SwigDirector_TK_Tag();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Dictionary : public TK_Dictionary, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Dictionary(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Dictionary();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Dictionary::m_format;
    using TK_Dictionary::m_placeholder;
    using TK_Dictionary::m_present;
    using TK_Dictionary::m_number_of_items;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Dictionary_Locater : public TK_Dictionary_Locater, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Dictionary_Locater(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Dictionary_Locater();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Dictionary_Locater::m_size;
    using TK_Dictionary_Locater::m_offset;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Color : public TK_Color, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Color(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Color();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Color::m_mask;
    using TK_Color::m_channels;
    using TK_Color::m_gloss;
    using TK_Color::m_index;
    using TK_Color::m_substage;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Color_RGB : public TK_Color_RGB, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Color_RGB(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Color_RGB();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Color_RGB::m_mask;
    using TK_Color_RGB::m_rgb;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Color_By_Value : public TK_Color_By_Value, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Color_By_Value(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Color_By_Value();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Color_By_Value::m_mask;
    using TK_Color_By_Value::m_value;
    using TK_Color_By_Value::m_space;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Color_By_Index : public TK_Color_By_Index, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Color_By_Index(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Color_By_Index();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Color_By_Index::m_mask;
    using TK_Color_By_Index::m_index;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Color_By_FIndex : public TK_Color_By_FIndex, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Color_By_FIndex(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Color_By_FIndex();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Color_By_FIndex::m_mask;
    using TK_Color_By_FIndex::m_index;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Color_Map : public TK_Color_Map, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Color_Map(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Color_Map();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Color_Map::m_length;
    using TK_Color_Map::m_values_length;
    using TK_Color_Map::m_string_length;
    using TK_Color_Map::m_format;
    using TK_Color_Map::set_values;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Callback : public TK_Callback, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Callback(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Callback();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Callback::m_length;
    using TK_Callback::set_callback;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Rendering_Options : public TK_Rendering_Options, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Rendering_Options(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Rendering_Options();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Rendering_Options::m_mask;
    using TK_Rendering_Options::m_value;
    using TK_Rendering_Options::m_hsr;
    using TK_Rendering_Options::m_tq;
    using TK_Rendering_Options::m_debug;
    using TK_Rendering_Options::m_face_displacement;
    using TK_Rendering_Options::m_vertex_displacement;
    using TK_Rendering_Options::m_fog_limits;
    using TK_Rendering_Options::m_lock;
    using TK_Rendering_Options::m_forced;
    using TK_Rendering_Options::m_buffer_options_mask;
    using TK_Rendering_Options::m_buffer_options_value;
    using TK_Rendering_Options::m_buffer_size_limit;
    using TK_Rendering_Options::m_hlr_options;
    using TK_Rendering_Options::m_hlr_dim_factor;
    using TK_Rendering_Options::m_hlr_face_displacement;
    using TK_Rendering_Options::m_hlr_transparency_cutoff;
    using TK_Rendering_Options::m_hlr_line_pattern;
    using TK_Rendering_Options::m_hlr_color;
    using TK_Rendering_Options::m_hlr_weight;
    using TK_Rendering_Options::m_hlr_weight_units;
    using TK_Rendering_Options::m_hlr_hsr_algorithm;
    using TK_Rendering_Options::m_contour_options;
    using TK_Rendering_Options::m_isoline_options;
    using TK_Rendering_Options::m_contour_value_adjustment;
    using TK_Rendering_Options::m_contour_value_scale;
    using TK_Rendering_Options::m_contour_value_translate;
    using TK_Rendering_Options::m_isoline_position_type;
    using TK_Rendering_Options::m_isoline_position_count;
    using TK_Rendering_Options::m_isoline_color_count;
    using TK_Rendering_Options::m_isoline_pattern_count;
    using TK_Rendering_Options::m_isoline_patterns;
    using TK_Rendering_Options::m_isoline_weight_count;
    using TK_Rendering_Options::m_tint_options;
    using TK_Rendering_Options::m_tint_color;
    using TK_Rendering_Options::m_tint_range;
    using TK_Rendering_Options::m_tint_effect;
    using TK_Rendering_Options::m_lod_options_mask;
    using TK_Rendering_Options::m_lod_options_value;
    using TK_Rendering_Options::m_lod_algorithm;
    using TK_Rendering_Options::m_num_ratios;
    using TK_Rendering_Options::m_ratio;
    using TK_Rendering_Options::m_num_thresholds;
    using TK_Rendering_Options::m_threshold;
    using TK_Rendering_Options::m_threshold_type;
    using TK_Rendering_Options::m_min_triangle_count;
    using TK_Rendering_Options::m_clamp;
    using TK_Rendering_Options::m_num_levels;
    using TK_Rendering_Options::m_max_degree;
    using TK_Rendering_Options::m_tolerance;
    using TK_Rendering_Options::m_bounding;
    using TK_Rendering_Options::m_num_cutoffs;
    using TK_Rendering_Options::m_cutoff;
    using TK_Rendering_Options::m_heuristic;
    using TK_Rendering_Options::m_fallback;
    using TK_Rendering_Options::m_nurbs_options_mask;
    using TK_Rendering_Options::m_nurbs_options_value;
    using TK_Rendering_Options::m_curve_budget;
    using TK_Rendering_Options::m_curve_continued_budget;
    using TK_Rendering_Options::m_surface_budget;
    using TK_Rendering_Options::m_surface_trim_budget;
    using TK_Rendering_Options::m_surface_max_trim_curve_deviation;
    using TK_Rendering_Options::m_surface_max_facet_angle;
    using TK_Rendering_Options::m_surface_max_facet_deviation;
    using TK_Rendering_Options::m_surface_max_facet_width;
    using TK_Rendering_Options::m_curve_max_angle;
    using TK_Rendering_Options::m_curve_max_deviation;
    using TK_Rendering_Options::m_curve_max_length;
    using TK_Rendering_Options::m_stereo_separation;
    using TK_Rendering_Options::m_stereo_distance;
    using TK_Rendering_Options::m_tessellations;
    using TK_Rendering_Options::m_num_cylinder;
    using TK_Rendering_Options::m_cylinder;
    using TK_Rendering_Options::m_num_sphere;
    using TK_Rendering_Options::m_sphere;
    using TK_Rendering_Options::m_gooch_color_range;
    using TK_Rendering_Options::m_gooch_diffuse_weight;
    using TK_Rendering_Options::m_gooch_color_map_segment_length;
    using TK_Rendering_Options::m_transparency_options;
    using TK_Rendering_Options::m_cut_geometry;
    using TK_Rendering_Options::m_cut_geometry_level;
    using TK_Rendering_Options::m_cut_geometry_match;
    using TK_Rendering_Options::m_cut_geometry_tolerance;
    using TK_Rendering_Options::m_simple_shadow;
    using TK_Rendering_Options::m_simple_shadow_blur;
    using TK_Rendering_Options::m_simple_shadow_resolution;
    using TK_Rendering_Options::m_simple_shadow_plane;
    using TK_Rendering_Options::m_simple_shadow_light;
    using TK_Rendering_Options::m_simple_shadow_color;
    using TK_Rendering_Options::m_simple_shadow_opacity;
    using TK_Rendering_Options::m_shadow_map;
    using TK_Rendering_Options::m_shadow_map_resolution;
    using TK_Rendering_Options::m_shadow_map_samples;
    using TK_Rendering_Options::m_simple_reflection;
    using TK_Rendering_Options::m_simple_reflection_plane;
    using TK_Rendering_Options::m_simple_reflection_opacity;
    using TK_Rendering_Options::m_simple_reflection_blur;
    using TK_Rendering_Options::m_simple_reflection_hither;
    using TK_Rendering_Options::m_simple_reflection_yon;
    using TK_Rendering_Options::m_simple_reflection_visibility_mask;
    using TK_Rendering_Options::m_simple_reflection_visibility_value;
    using TK_Rendering_Options::m_depth_range;
    using TK_Rendering_Options::m_screen_range;
    using TK_Rendering_Options::m_ambient_up_vector;
    using TK_Rendering_Options::m_image_scale;
    using TK_Rendering_Options::m_mask_transform;
    using TK_Rendering_Options::m_geometry_options;
    using TK_Rendering_Options::m_dihedral;
    using TK_Rendering_Options::m_image_tint_color;
    using TK_Rendering_Options::m_texture_tint_color;
    using TK_Rendering_Options::m_depth_peeling_layers;
    using TK_Rendering_Options::m_depth_peeling_min_area;
    using TK_Rendering_Options::m_depth_peeling_algorithm;
    using TK_Rendering_Options::m_general_displacement;
    using TK_Rendering_Options::m_join_cutoff_angle;
    using TK_Rendering_Options::m_edge_join_cutoff_angle;
    using TK_Rendering_Options::m_vertex_decimation;
    using TK_Rendering_Options::m_display_list_level;
    using TK_Rendering_Options::m_antialias;
    using TK_Rendering_Options::m_extra;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Heuristics : public TK_Heuristics, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Heuristics(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Heuristics();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Heuristics::m_mask;
    using TK_Heuristics::m_value;
    using TK_Heuristics::m_related;
    using TK_Heuristics::m_internal_shell;
    using TK_Heuristics::m_internal_polyline;
    using TK_Heuristics::m_extras;
    using TK_Heuristics::m_culling;
    using TK_Heuristics::m_selection_culling;
    using TK_Heuristics::m_pixel_threshold;
    using TK_Heuristics::m_maximum_extent;
    using TK_Heuristics::m_maximum_extent_mode;
    using TK_Heuristics::m_maximum_extent_level;
    using TK_Heuristics::m_hard_extent;
    using TK_Heuristics::m_force_defer;
    using TK_Heuristics::m_vector;
    using TK_Heuristics::m_vector_tolerance;
    using TK_Heuristics::m_max_distance;
    using TK_Heuristics::m_view_volume;
    using TK_Heuristics::m_ordered_weights_mask;
    using TK_Heuristics::m_ordered_weights;
    using TK_Heuristics::m_selection_level;
    using TK_Heuristics::m_model_type;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Visibility : public TK_Visibility, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Visibility(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Visibility();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Visibility::m_mask;
    using TK_Visibility::m_value;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Selectability : public TK_Selectability, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Selectability(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Selectability();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Selectability::m_mask;
    using TK_Selectability::m_down;
    using TK_Selectability::m_up;
    using TK_Selectability::m_move_down;
    using TK_Selectability::m_move_up;
    using TK_Selectability::m_invisible;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Matrix : public TK_Matrix, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Matrix(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Matrix();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Matrix::m_matrix;
    using TK_Matrix::m_dmatrix;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Enumerated : public TK_Enumerated, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Enumerated(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Enumerated();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Enumerated::m_index;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Size : public TK_Size, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Size(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Size();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Size::m_value;
    using TK_Size::m_units;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Linear_Pattern : public TK_Linear_Pattern, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Linear_Pattern(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Linear_Pattern();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Linear_Pattern::m_pattern;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Named : public TK_Named, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Named(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Named();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Named::m_name_length;
    using TK_Named::m_index;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Streaming : public TK_Streaming, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Streaming(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Streaming();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Streaming::m_flag;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Conditions : public TK_Conditions, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Conditions(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Conditions();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Conditions::m_length;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_User_Options : public TK_User_Options, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_User_Options(JNIEnv *jenv);
    virtual ~SwigDirector_TK_User_Options();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_User_Options::m_length;
    using TK_User_Options::m_indices;
    using TK_User_Options::m_unicode;
    using TK_User_Options::m_index_data;
    using TK_User_Options::set_options;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Unicode_Options : public TK_Unicode_Options, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Unicode_Options(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Unicode_Options();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Unicode_Options::m_length;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_User_Index : public TK_User_Index, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_User_Index(JNIEnv *jenv);
    virtual ~SwigDirector_TK_User_Index();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_User_Index::m_count;
    using TK_User_Index::m_current_value;
    using TK_User_Index::set_indices;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_User_Value : public TK_User_Value, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_User_Value(JNIEnv *jenv);
    virtual ~SwigDirector_TK_User_Value();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_User_Value::m_value;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Camera : public TK_Camera, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Camera(JNIEnv *jenv, unsigned char opcode = TKE_Camera);
    virtual ~SwigDirector_TK_Camera();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Camera::m_settings;
    using TK_Camera::m_dsettings;
    using TK_Camera::m_details;
    using TK_Camera::m_projection;
    using TK_Camera::m_length;
    using TK_Camera::set_name;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Window : public TK_Window, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Window(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Window();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Window::m_window;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Text_Font : public TK_Text_Font, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Text_Font(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Text_Font();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Text_Font::m_mask;
    using TK_Text_Font::m_value;
    using TK_Text_Font::m_names_length;
    using TK_Text_Font::m_size;
    using TK_Text_Font::m_tolerance;
    using TK_Text_Font::m_rotation;
    using TK_Text_Font::m_slant;
    using TK_Text_Font::m_width_scale;
    using TK_Text_Font::m_extra_space;
    using TK_Text_Font::m_line_spacing;
    using TK_Text_Font::m_greeking_limit;
    using TK_Text_Font::m_renderer_cutoff;
    using TK_Text_Font::m_preference_cutoff;
    using TK_Text_Font::m_renderers;
    using TK_Text_Font::m_preferences;
    using TK_Text_Font::m_size_units;
    using TK_Text_Font::m_tolerance_units;
    using TK_Text_Font::m_space_units;
    using TK_Text_Font::m_greeking_units;
    using TK_Text_Font::m_greeking_mode;
    using TK_Text_Font::m_transforms;
    using TK_Text_Font::m_renderer_cutoff_units;
    using TK_Text_Font::m_preference_cutoff_units;
    using TK_Text_Font::m_layout;
    using TK_Text_Font::set_names;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Bounding : public TK_Bounding, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Bounding(JNIEnv *jenv, unsigned char opcode);
    SwigDirector_TK_Bounding(JNIEnv *jenv, unsigned char opcode, float min[], float max[]);
    SwigDirector_TK_Bounding(JNIEnv *jenv, unsigned char opcode, float center[], float radius);
    SwigDirector_TK_Bounding(JNIEnv *jenv, unsigned char opcode, double min[], double max[]);
    SwigDirector_TK_Bounding(JNIEnv *jenv, unsigned char opcode, double center[], double radius);
    virtual ~SwigDirector_TK_Bounding();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Bounding::m_dvalues;
    using TK_Bounding::m_values;
    using TK_Bounding::m_type;
    using TK_Bounding::m_is_valid;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Point : public TK_Point, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Point(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Point();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Point::m_point;
    using TK_Point::m_dpoint;
    using TK_Point::m_options;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Line : public TK_Line, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Line(JNIEnv *jenv, unsigned char opcode = TKE_Line);
    virtual ~SwigDirector_TK_Line();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Line::m_points;
    using TK_Line::m_dpoints;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Polypoint : public TK_Polypoint, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Polypoint(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Polypoint();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Polypoint::m_count;
    using TK_Polypoint::m_allocated;
    using TK_Polypoint::m_dpoints;
    using TK_Polypoint::set_points;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_NURBS_Curve : public TK_NURBS_Curve, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_NURBS_Curve(JNIEnv *jenv);
    virtual ~SwigDirector_TK_NURBS_Curve();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_NURBS_Curve::m_optionals;
    using TK_NURBS_Curve::m_degree;
    using TK_NURBS_Curve::m_control_point_count;
    using TK_NURBS_Curve::m_knot_count_implicit;
    using TK_NURBS_Curve::m_dcontrol_points;
    using TK_NURBS_Curve::m_start;
    using TK_NURBS_Curve::m_end;
    using TK_NURBS_Curve::set_curve;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_NURBS_Surface : public TK_NURBS_Surface, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_NURBS_Surface(JNIEnv *jenv);
    virtual ~SwigDirector_TK_NURBS_Surface();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_NURBS_Surface::m_optionals;
    using TK_NURBS_Surface::m_degree;
    using TK_NURBS_Surface::m_size;
    using TK_NURBS_Surface::m_dcontrol_points;
    using TK_NURBS_Surface::m_trims;
    using TK_NURBS_Surface::m_current_trim;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Area_Light : public TK_Area_Light, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Area_Light(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Area_Light();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Area_Light::m_count;
    using TK_Area_Light::m_dpoints;
    using TK_Area_Light::m_options;
    using TK_Area_Light::set_points;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Spot_Light : public TK_Spot_Light, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Spot_Light(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Spot_Light();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Spot_Light::m_position;
    using TK_Spot_Light::m_target;
    using TK_Spot_Light::m_dposition;
    using TK_Spot_Light::m_dtarget;
    using TK_Spot_Light::m_outer;
    using TK_Spot_Light::m_inner;
    using TK_Spot_Light::m_concentration;
    using TK_Spot_Light::m_options;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Cutting_Plane : public TK_Cutting_Plane, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Cutting_Plane(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Cutting_Plane();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Cutting_Plane::m_dplanes;
    using TK_Cutting_Plane::m_count;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Circle : public TK_Circle, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Circle(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Circle();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Circle::m_points;
    using TK_Circle::m_center;
    using TK_Circle::m_dpoints;
    using TK_Circle::m_dcenter;
    using TK_Circle::m_flags;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Ellipse : public TK_Ellipse, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Ellipse(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Ellipse();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Ellipse::m_points;
    using TK_Ellipse::m_dpoints;
    using TK_Ellipse::m_limits;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Sphere : public TK_Sphere, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Sphere(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Sphere();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Sphere::m_flags;
    using TK_Sphere::m_center;
    using TK_Sphere::m_radius;
    using TK_Sphere::m_axis;
    using TK_Sphere::m_ortho;
    using TK_Sphere::m_dcenter;
    using TK_Sphere::m_dradius;
    using TK_Sphere::m_daxis;
    using TK_Sphere::m_dortho;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Cylinder : public TK_Cylinder, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Cylinder(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Cylinder();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Cylinder::m_axis;
    using TK_Cylinder::m_radius;
    using TK_Cylinder::m_daxis;
    using TK_Cylinder::m_dradius;
    using TK_Cylinder::m_flags;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_PolyCylinder : public TK_PolyCylinder, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_PolyCylinder(JNIEnv *jenv);
    virtual ~SwigDirector_TK_PolyCylinder();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status ReadSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::Read(tk);
    }
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status WriteSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::Write(tk);
    }
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    virtual TK_Status EnumerateEdges();
    virtual TK_Status EnumerateEdgesSwigPublic() {
      return TK_Polyhedron::EnumerateEdges();
    }
    virtual TK_Status LabelFakeEdges();
    virtual TK_Status LabelFakeEdgesSwigPublic() {
      return TK_Polyhedron::LabelFakeEdges();
    }
    virtual bool AllowInstancing(BStreamFileToolkit &tk) const;
    virtual bool AllowInstancingSwigPublic(BStreamFileToolkit &tk) const {
      return TK_Polyhedron::AllowInstancing(tk);
    }
    virtual TK_Status read_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points(tk);
    }
    virtual TK_Status write_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points(tk);
    }
    virtual TK_Status read_collection(BStreamFileToolkit &tk);
    virtual TK_Status read_collectionSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection(tk);
    }
    virtual TK_Status write_collection(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collectionSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection(tk,write_tag,variant);
    }
    virtual TK_Status read_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points_ascii(tk);
    }
    virtual TK_Status write_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points_ascii(tk);
    }
    virtual TK_Status read_collection_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_collection_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection_ascii(tk);
    }
    virtual TK_Status write_vertex_marker_sizes_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_vertex_marker_sizes_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_vertex_marker_sizes_ascii(tk);
    }
    virtual TK_Status write_collection_ascii(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collection_asciiSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection_ascii(tk,write_tag,variant);
    }
    virtual TK_Status mangle_points(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_pointsSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_points(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_point_attributes(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_point_attributesSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_point_attributes(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_face_attributes(BStreamFileToolkit &tk, int facemap_count, int facemap[]);
    virtual TK_Status mangle_face_attributesSwigPublic(BStreamFileToolkit &tk, int facemap_count, int facemap[]) {
      return TK_Polyhedron::mangle_face_attributes(tk,facemap_count,facemap);
    }
    using TK_PolyCylinder::m_count;
    using TK_PolyCylinder::m_dpoints;
    using TK_PolyCylinder::m_radius_count;
    using TK_PolyCylinder::m_dradii;
    using TK_PolyCylinder::m_flags;
    using TK_PolyCylinder::m_normals;
public:
    bool swig_overrides(int n) {
      return (n < 29 ? swig_override[n] : false);
    }
protected:
    bool swig_override[29];
};

class SwigDirector_TK_Grid : public TK_Grid, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Grid(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Grid();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Grid::m_type;
    using TK_Grid::m_points;
    using TK_Grid::m_dpoints;
    using TK_Grid::m_counts;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Text : public TK_Text, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Text(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_Text();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Text::m_position;
    using TK_Text::m_dposition;
    using TK_Text::m_length;
    using TK_Text::m_allocated;
    using TK_Text::m_encoding;
    using TK_Text::m_options;
    using TK_Text::m_region_options;
    using TK_Text::m_region_fit;
    using TK_Text::m_region_count;
    using TK_Text::m_region;
    using TK_Text::m_count;
    using TK_Text::m_character_attributes;
    using TK_Text::m_substage;
    using TK_Text::m_tmp;
    using TK_Text::set_string;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Font : public TK_Font, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Font(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Font();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Font::m_name_length;
    using TK_Font::m_lookup_length;
    using TK_Font::m_length;
    using TK_Font::m_type;
    using TK_Font::m_encoding;
    using TK_Font::set_bytes;
    using TK_Font::set_name;
    using TK_Font::set_lookup;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Image : public TK_Image, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Image(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Image();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Image::m_position;
    using TK_Image::m_dposition;
    using TK_Image::m_size;
    using TK_Image::m_data_size;
    using TK_Image::m_name_length;
    using TK_Image::m_reference_length;
    using TK_Image::m_format;
    using TK_Image::m_options;
    using TK_Image::m_compression;
    using TK_Image::m_bytes_format;
    using TK_Image::m_explicit_size;
    using TK_Image::m_explicit_units;
    using TK_Image::m_work_area;
    using TK_Image::m_compression_quality;
    using TK_Image::m_jpeg_native;
    using TK_Image::set_data;
    using TK_Image::set_name;
    using TK_Image::compress_image;
    using TK_Image::decompress_image;
    using TK_Image::read_jpeg_header;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Texture : public TK_Texture, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Texture(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Texture();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Texture::m_name_length;
    using TK_Texture::m_shader_source_length;
    using TK_Texture::m_image_length;
    using TK_Texture::m_camera_length;
    using TK_Texture::m_flags;
    using TK_Texture::m_substage;
    using TK_Texture::m_param_source;
    using TK_Texture::m_interpolation;
    using TK_Texture::m_decimation;
    using TK_Texture::m_red_mapping;
    using TK_Texture::m_green_mapping;
    using TK_Texture::m_blue_mapping;
    using TK_Texture::m_alpha_mapping;
    using TK_Texture::m_param_function;
    using TK_Texture::m_layout;
    using TK_Texture::m_tiling;
    using TK_Texture::m_value_scale;
    using TK_Texture::m_source_dimensions;
    using TK_Texture::m_apply_mode;
    using TK_Texture::m_param_offset;
    using TK_Texture::set_name;
    using TK_Texture::set_image;
    using TK_Texture::set_transform;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Thumbnail : public TK_Thumbnail, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Thumbnail(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Thumbnail();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Thumbnail::m_allocated;
    using TK_Thumbnail::m_size;
    using TK_Thumbnail::m_format;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Glyph_Definition : public TK_Glyph_Definition, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Glyph_Definition(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Glyph_Definition();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Glyph_Definition::m_name_length;
    using TK_Glyph_Definition::m_size;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Line_Style : public TK_Line_Style, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Line_Style(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Line_Style();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Line_Style::m_name_length;
    using TK_Line_Style::m_definition_length;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Clip_Rectangle : public TK_Clip_Rectangle, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Clip_Rectangle(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Clip_Rectangle();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Clip_Rectangle::m_options;
    using TK_Clip_Rectangle::m_rect;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Clip_Region : public TK_Clip_Region, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Clip_Region(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Clip_Region();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_Clip_Region::m_options;
    using TK_Clip_Region::m_count;
    using TK_Clip_Region::m_dpoints;
    using TK_Clip_Region::m_complex;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_User_Data : public TK_User_Data, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_User_Data(JNIEnv *jenv);
    virtual ~SwigDirector_TK_User_Data();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_User_Data::m_size;
    using TK_User_Data::m_buffer_size;
    using TK_User_Data::set_data;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_XML : public TK_XML, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_XML(JNIEnv *jenv);
    virtual ~SwigDirector_TK_XML();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_XML::m_size;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_URL : public TK_URL, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_URL(JNIEnv *jenv);
    virtual ~SwigDirector_TK_URL();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_URL::m_length;
    using TK_URL::m_allocated;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_External_Reference : public TK_External_Reference, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_External_Reference(JNIEnv *jenv);
    virtual ~SwigDirector_TK_External_Reference();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_External_Reference::m_length;
    using TK_External_Reference::m_allocated;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_TK_Polyhedron : public TK_Polyhedron, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Polyhedron(JNIEnv *jenv, unsigned char op);
    virtual ~SwigDirector_TK_Polyhedron();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status ReadSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::Read(tk);
    }
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status WriteSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::Write(tk);
    }
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual void ResetSwigPublic() {
      TK_Polyhedron::Reset();
    }
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    virtual TK_Status EnumerateEdges();
    virtual TK_Status EnumerateEdgesSwigPublic() {
      return TK_Polyhedron::EnumerateEdges();
    }
    virtual TK_Status LabelFakeEdges();
    virtual TK_Status LabelFakeEdgesSwigPublic() {
      return TK_Polyhedron::LabelFakeEdges();
    }
    virtual bool AllowInstancing(BStreamFileToolkit &tk) const;
    virtual bool AllowInstancingSwigPublic(BStreamFileToolkit &tk) const {
      return TK_Polyhedron::AllowInstancing(tk);
    }
    virtual TK_Status read_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points(tk);
    }
    virtual TK_Status write_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points(tk);
    }
    virtual TK_Status read_collection(BStreamFileToolkit &tk);
    virtual TK_Status read_collectionSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection(tk);
    }
    virtual TK_Status write_collection(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collectionSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection(tk,write_tag,variant);
    }
    virtual TK_Status read_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points_ascii(tk);
    }
    virtual TK_Status write_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points_ascii(tk);
    }
    virtual TK_Status read_collection_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_collection_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection_ascii(tk);
    }
    virtual TK_Status write_vertex_marker_sizes_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_vertex_marker_sizes_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_vertex_marker_sizes_ascii(tk);
    }
    virtual TK_Status write_collection_ascii(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collection_asciiSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection_ascii(tk,write_tag,variant);
    }
    virtual TK_Status mangle_points(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_pointsSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_points(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_point_attributes(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_point_attributesSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_point_attributes(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_face_attributes(BStreamFileToolkit &tk, int facemap_count, int facemap[]);
    virtual TK_Status mangle_face_attributesSwigPublic(BStreamFileToolkit &tk, int facemap_count, int facemap[]) {
      return TK_Polyhedron::mangle_face_attributes(tk,facemap_count,facemap);
    }
    using TK_Polyhedron::mp_priority;
    using TK_Polyhedron::mp_dpoints;
    using TK_Polyhedron::mp_vmsymbolstrings;
    using TK_Polyhedron::mp_epatternstrings;
    using TK_Polyhedron::mp_pointcount;
    using TK_Polyhedron::mp_normalcount;
    using TK_Polyhedron::mp_paramcount;
    using TK_Polyhedron::mp_paramwidth;
    using TK_Polyhedron::mp_vfcolorcount;
    using TK_Polyhedron::mp_vecolorcount;
    using TK_Polyhedron::mp_vmcolorcount;
    using TK_Polyhedron::mp_vmrgbacount;
    using TK_Polyhedron::mp_vfindexcount;
    using TK_Polyhedron::mp_veindexcount;
    using TK_Polyhedron::mp_vmindexcount;
    using TK_Polyhedron::mp_vmvisibilitycount;
    using TK_Polyhedron::mp_vmsizecount;
    using TK_Polyhedron::mp_vmsymbolcount;
    using TK_Polyhedron::mp_facecount;
    using TK_Polyhedron::mp_fcolorcount;
    using TK_Polyhedron::mp_findexcount;
    using TK_Polyhedron::mp_fnormalcount;
    using TK_Polyhedron::mp_fpatterncount;
    using TK_Polyhedron::mp_fvisibilitycount;
    using TK_Polyhedron::mp_edgecount;
    using TK_Polyhedron::mp_ecolorcount;
    using TK_Polyhedron::mp_eindexcount;
    using TK_Polyhedron::mp_enormalcount;
    using TK_Polyhedron::mp_epatterncount;
    using TK_Polyhedron::mp_eweightcount;
    using TK_Polyhedron::mp_evisibilitycount;
    using TK_Polyhedron::mp_stage;
    using TK_Polyhedron::mp_substage;
    using TK_Polyhedron::mp_progress;
    using TK_Polyhedron::mp_subprogress;
    using TK_Polyhedron::mp_optopcode;
    using TK_Polyhedron::mp_present;
    using TK_Polyhedron::mp_face_present;
    using TK_Polyhedron::mp_edge_present;
    using TK_Polyhedron::mp_bits_per_sample;
    using TK_Polyhedron::mp_bbox;
    using TK_Polyhedron::mp_key;
    using TK_Polyhedron::mp_instance;
    using TK_Polyhedron::mp_matrix;
    using TK_Polyhedron::mp_workspace_allocated;
    using TK_Polyhedron::mp_workspace_used;
    using TK_Polyhedron::mp_compression_scheme;
    using TK_Polyhedron::mp_subop;
    using TK_Polyhedron::mp_subop2;
    using TK_Polyhedron::mp_num_collection_parts;
    using TK_Polyhedron::mp_collection_parts;
    using TK_Polyhedron::read_vertex_normals;
    using TK_Polyhedron::read_vertex_normals_compressed;
    using TK_Polyhedron::read_vertex_normals_all;
    using TK_Polyhedron::read_vertex_normals_compressed_all;
    using TK_Polyhedron::read_vertex_parameters;
    using TK_Polyhedron::read_vertex_parameters_all;
    using TK_Polyhedron::read_vertex_colors_all;
    using TK_Polyhedron::read_vertex_colors;
    using TK_Polyhedron::read_vertex_colors_uncompressed_all;
    using TK_Polyhedron::read_vertex_colors_uncompressed;
    using TK_Polyhedron::read_vertex_indices_all;
    using TK_Polyhedron::read_vertex_indices;
    using TK_Polyhedron::read_vertex_indices_uncompressed_all;
    using TK_Polyhedron::read_vertex_indices_uncompressed;
    using TK_Polyhedron::read_vertex_marker_visibilities;
    using TK_Polyhedron::read_vertex_marker_symbols;
    using TK_Polyhedron::read_vertex_marker_sizes;
    using TK_Polyhedron::read_face_colors;
    using TK_Polyhedron::read_face_colors_all;
    using TK_Polyhedron::read_face_colors_uncompressed;
    using TK_Polyhedron::read_face_colors_uncompressed_all;
    using TK_Polyhedron::read_face_indices;
    using TK_Polyhedron::read_face_indices_all;
    using TK_Polyhedron::read_face_indices_uncompressed;
    using TK_Polyhedron::read_face_indices_uncompressed_all;
    using TK_Polyhedron::read_face_regions;
    using TK_Polyhedron::read_face_normals;
    using TK_Polyhedron::read_face_visibilities;
    using TK_Polyhedron::read_face_patterns;
    using TK_Polyhedron::read_edge_colors;
    using TK_Polyhedron::read_edge_indices;
    using TK_Polyhedron::read_edge_normals;
    using TK_Polyhedron::read_edge_visibilities;
    using TK_Polyhedron::read_edge_patterns;
    using TK_Polyhedron::read_edge_weights;
    using TK_Polyhedron::write_vertex_normals;
    using TK_Polyhedron::write_vertex_normals_compressed;
    using TK_Polyhedron::write_vertex_normals_all;
    using TK_Polyhedron::write_vertex_normals_compressed_all;
    using TK_Polyhedron::write_vertex_parameters;
    using TK_Polyhedron::write_vertex_parameters_all;
    using TK_Polyhedron::write_vertex_colors;
    using TK_Polyhedron::write_vertex_colors_all;
    using TK_Polyhedron::write_vertex_colors_uncompressed;
    using TK_Polyhedron::write_vertex_colors_uncompressed_all;
    using TK_Polyhedron::write_vertex_indices;
    using TK_Polyhedron::write_vertex_indices_all;
    using TK_Polyhedron::write_vertex_indices_uncompressed;
    using TK_Polyhedron::write_vertex_indices_uncompressed_all;
    using TK_Polyhedron::write_vertex_marker_visibilities;
    using TK_Polyhedron::write_vertex_marker_symbols;
    using TK_Polyhedron::write_vertex_marker_sizes;
    using TK_Polyhedron::write_face_colors;
    using TK_Polyhedron::write_face_colors_all;
    using TK_Polyhedron::write_face_colors_uncompressed;
    using TK_Polyhedron::write_face_colors_uncompressed_all;
    using TK_Polyhedron::write_face_indices;
    using TK_Polyhedron::write_face_indices_all;
    using TK_Polyhedron::write_face_indices_uncompressed;
    using TK_Polyhedron::write_face_indices_uncompressed_all;
    using TK_Polyhedron::write_face_regions;
    using TK_Polyhedron::write_face_normals;
    using TK_Polyhedron::write_face_visibilities;
    using TK_Polyhedron::write_face_patterns;
    using TK_Polyhedron::write_edge_colors;
    using TK_Polyhedron::write_edge_indices;
    using TK_Polyhedron::write_edge_normals;
    using TK_Polyhedron::write_edge_visibilities;
    using TK_Polyhedron::write_edge_patterns;
    using TK_Polyhedron::write_edge_weights;
    using TK_Polyhedron::normals_cartesian_to_polar;
    using TK_Polyhedron::normals_polar_to_cartesian;
    using TK_Polyhedron::write_vertex_normals_main;
    using TK_Polyhedron::write_vertex_parameters_main;
    using TK_Polyhedron::write_vertex_colors_main;
    using TK_Polyhedron::write_vertex_indices_main;
    using TK_Polyhedron::write_face_colors_main;
    using TK_Polyhedron::write_face_indices_main;
    using TK_Polyhedron::ReadAscii;
    using TK_Polyhedron::WriteAscii;
    using TK_Polyhedron::read_vertex_normals_ascii;
    using TK_Polyhedron::read_vertex_normals_compressed_ascii;
    using TK_Polyhedron::read_vertex_normals_all_ascii;
    using TK_Polyhedron::read_vertex_normals_compressed_all_ascii;
    using TK_Polyhedron::read_vertex_parameters_ascii;
    using TK_Polyhedron::read_vertex_parameters_all_ascii;
    using TK_Polyhedron::read_vertex_colors_all_ascii;
    using TK_Polyhedron::read_vertex_colors_ascii;
    using TK_Polyhedron::read_vertex_indices_all_ascii;
    using TK_Polyhedron::read_vertex_indices_ascii;
    using TK_Polyhedron::read_vertex_marker_visibilities_ascii;
    using TK_Polyhedron::read_vertex_marker_symbols_ascii;
    using TK_Polyhedron::read_vertex_marker_sizes_ascii;
    using TK_Polyhedron::read_face_colors_ascii;
    using TK_Polyhedron::read_face_colors_all_ascii;
    using TK_Polyhedron::read_face_indices_ascii;
    using TK_Polyhedron::read_face_indices_all_ascii;
    using TK_Polyhedron::read_face_regions_ascii;
    using TK_Polyhedron::read_face_normals_ascii;
    using TK_Polyhedron::read_face_visibilities_ascii;
    using TK_Polyhedron::read_face_patterns_ascii;
    using TK_Polyhedron::read_edge_colors_ascii;
    using TK_Polyhedron::read_edge_indices_ascii;
    using TK_Polyhedron::read_edge_normals_ascii;
    using TK_Polyhedron::read_edge_visibilities_ascii;
    using TK_Polyhedron::read_edge_patterns_ascii;
    using TK_Polyhedron::read_edge_weights_ascii;
    using TK_Polyhedron::write_vertex_normals_ascii;
    using TK_Polyhedron::write_vertex_normals_compressed_ascii;
    using TK_Polyhedron::write_vertex_normals_all_ascii;
    using TK_Polyhedron::write_vertex_normals_compressed_all_ascii;
    using TK_Polyhedron::write_vertex_parameters_ascii;
    using TK_Polyhedron::write_vertex_parameters_all_ascii;
    using TK_Polyhedron::write_vertex_colors_ascii;
    using TK_Polyhedron::write_vertex_colors_all_ascii;
    using TK_Polyhedron::write_vertex_indices_ascii;
    using TK_Polyhedron::write_vertex_indices_all_ascii;
    using TK_Polyhedron::write_vertex_marker_visibilities_ascii;
    using TK_Polyhedron::write_vertex_marker_symbols_ascii;
    using TK_Polyhedron::write_face_colors_ascii;
    using TK_Polyhedron::write_face_colors_all_ascii;
    using TK_Polyhedron::write_face_indices_ascii;
    using TK_Polyhedron::write_face_indices_all_ascii;
    using TK_Polyhedron::write_face_regions_ascii;
    using TK_Polyhedron::write_face_normals_ascii;
    using TK_Polyhedron::write_face_visibilities_ascii;
    using TK_Polyhedron::write_face_patterns_ascii;
    using TK_Polyhedron::write_edge_colors_ascii;
    using TK_Polyhedron::write_edge_indices_ascii;
    using TK_Polyhedron::write_edge_normals_ascii;
    using TK_Polyhedron::write_edge_visibilities_ascii;
    using TK_Polyhedron::write_edge_patterns_ascii;
    using TK_Polyhedron::write_edge_weights_ascii;
    using TK_Polyhedron::write_vertex_normals_main_ascii;
    using TK_Polyhedron::write_vertex_parameters_main_ascii;
    using TK_Polyhedron::write_vertex_colors_main_ascii;
    using TK_Polyhedron::write_vertex_indices_main_ascii;
    using TK_Polyhedron::write_face_colors_main_ascii;
    using TK_Polyhedron::write_face_indices_main_ascii;
    using TK_Polyhedron::has_face_attributes;
    using TK_Polyhedron::repulse_compress_normals;
    using TK_Polyhedron::repulse_decompress_normals;
    using TK_Polyhedron::set_points;
    using TK_Polyhedron::set_normals;
    using TK_Polyhedron::set_parameters;
    using TK_Polyhedron::set_vfcolors;
    using TK_Polyhedron::set_vecolors;
    using TK_Polyhedron::set_vmcolors;
    using TK_Polyhedron::set_vfindices;
    using TK_Polyhedron::set_veindices;
    using TK_Polyhedron::set_vmindices;
    using TK_Polyhedron::set_fcolors;
    using TK_Polyhedron::set_findices;
    using TK_Polyhedron::set_exists;
    using TK_Polyhedron::set_face_exists;
public:
    bool swig_overrides(int n) {
      return (n < 29 ? swig_override[n] : false);
    }
protected:
    bool swig_override[29];
};

class SwigDirector_TK_Mesh : public TK_Mesh, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Mesh(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Mesh();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    virtual TK_Status EnumerateEdges();
    virtual TK_Status EnumerateEdgesSwigPublic() {
      return TK_Mesh::EnumerateEdges();
    }
    virtual TK_Status LabelFakeEdges();
    virtual TK_Status LabelFakeEdgesSwigPublic() {
      return TK_Polyhedron::LabelFakeEdges();
    }
    virtual bool AllowInstancing(BStreamFileToolkit &tk) const;
    virtual bool AllowInstancingSwigPublic(BStreamFileToolkit &tk) const {
      return TK_Polyhedron::AllowInstancing(tk);
    }
    virtual TK_Status read_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points(tk);
    }
    virtual TK_Status write_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points(tk);
    }
    virtual TK_Status read_collection(BStreamFileToolkit &tk);
    virtual TK_Status read_collectionSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection(tk);
    }
    virtual TK_Status write_collection(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collectionSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection(tk,write_tag,variant);
    }
    virtual TK_Status read_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points_ascii(tk);
    }
    virtual TK_Status write_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points_ascii(tk);
    }
    virtual TK_Status read_collection_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_collection_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection_ascii(tk);
    }
    virtual TK_Status write_vertex_marker_sizes_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_vertex_marker_sizes_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_vertex_marker_sizes_ascii(tk);
    }
    virtual TK_Status write_collection_ascii(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collection_asciiSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection_ascii(tk,write_tag,variant);
    }
    virtual TK_Status mangle_points(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_pointsSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_points(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_point_attributes(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_point_attributesSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_point_attributes(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_face_attributes(BStreamFileToolkit &tk, int facemap_count, int facemap[]);
    virtual TK_Status mangle_face_attributesSwigPublic(BStreamFileToolkit &tk, int facemap_count, int facemap[]) {
      return TK_Polyhedron::mangle_face_attributes(tk,facemap_count,facemap);
    }
    using TK_Mesh::m_rows;
    using TK_Mesh::m_columns;
public:
    bool swig_overrides(int n) {
      return (n < 29 ? swig_override[n] : false);
    }
protected:
    bool swig_override[29];
};

class SwigDirector_TK_Shell : public TK_Shell, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_Shell(JNIEnv *jenv);
    virtual ~SwigDirector_TK_Shell();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    virtual TK_Status EnumerateEdges();
    virtual TK_Status EnumerateEdgesSwigPublic() {
      return TK_Shell::EnumerateEdges();
    }
    virtual TK_Status LabelFakeEdges();
    virtual TK_Status LabelFakeEdgesSwigPublic() {
      return TK_Polyhedron::LabelFakeEdges();
    }
    virtual bool AllowInstancing(BStreamFileToolkit &tk) const;
    virtual bool AllowInstancingSwigPublic(BStreamFileToolkit &tk) const {
      return TK_Polyhedron::AllowInstancing(tk);
    }
    virtual TK_Status read_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points(tk);
    }
    virtual TK_Status write_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points(tk);
    }
    virtual TK_Status read_collection(BStreamFileToolkit &tk);
    virtual TK_Status read_collectionSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection(tk);
    }
    virtual TK_Status write_collection(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collectionSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection(tk,write_tag,variant);
    }
    virtual TK_Status read_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points_ascii(tk);
    }
    virtual TK_Status write_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points_ascii(tk);
    }
    virtual TK_Status read_collection_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_collection_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection_ascii(tk);
    }
    virtual TK_Status write_vertex_marker_sizes_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_vertex_marker_sizes_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_vertex_marker_sizes_ascii(tk);
    }
    virtual TK_Status write_collection_ascii(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collection_asciiSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection_ascii(tk,write_tag,variant);
    }
    virtual TK_Status mangle_points(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_pointsSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_points(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_point_attributes(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_point_attributesSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_point_attributes(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_face_attributes(BStreamFileToolkit &tk, int facemap_count, int facemap[]);
    virtual TK_Status mangle_face_attributesSwigPublic(BStreamFileToolkit &tk, int facemap_count, int facemap[]) {
      return TK_Polyhedron::mangle_face_attributes(tk,facemap_count,facemap);
    }
    using TK_Shell::m_substage;
    using TK_Shell::m_compression_scheme;
    using TK_Shell::m_flistlen;
    using TK_Shell::m_lodlevel;
    using TK_Shell::SetFaces;
    using TK_Shell::SetLodLevel;
    using TK_Shell::GetFacesLength;
    using TK_Shell::GetLodLevel;
public:
    bool swig_overrides(int n) {
      return (n < 29 ? swig_override[n] : false);
    }
protected:
    bool swig_override[29];
};

class SwigDirector_TK_PolyPolypoint : public TK_PolyPolypoint, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_TK_PolyPolypoint(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_TK_PolyPolypoint();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using TK_PolyPolypoint::m_point_count;
    using TK_PolyPolypoint::m_points_allocated;
    using TK_PolyPolypoint::m_dpoints;
    using TK_PolyPolypoint::m_points_num_floats;
    using TK_PolyPolypoint::m_points_num_dimensions;
    using TK_PolyPolypoint::m_primitive_count;
    using TK_PolyPolypoint::m_lengths_allocated;
    using TK_PolyPolypoint::m_bbox;
    using TK_PolyPolypoint::m_dbbox;
    using TK_PolyPolypoint::m_templen;
    using TK_PolyPolypoint::m_temprange;
    using TK_PolyPolypoint::m_dtemprange;
    using TK_PolyPolypoint::m_subop;
    using TK_PolyPolypoint::m_compression_scheme;
    using TK_PolyPolypoint::m_workspace_used;
    using TK_PolyPolypoint::m_workspace_allocated;
    using TK_PolyPolypoint::m_bits_per_sample;
    using TK_PolyPolypoint::m_substage;
    using TK_PolyPolypoint::m_progress;
    using TK_PolyPolypoint::analyze_dimensionality;
    using TK_PolyPolypoint::figure_num_floats;
    using TK_PolyPolypoint::validate_primitive_count;
    using TK_PolyPolypoint::expand_lengths;
    using TK_PolyPolypoint::mangle;
    using TK_PolyPolypoint::unmangle;
    using TK_PolyPolypoint::compute_trivial_points;
    using TK_PolyPolypoint::process_trivial_points;
    using TK_PolyPolypoint::compute_line_extend_points;
    using TK_PolyPolypoint::process_line_extend_points;
    using TK_PolyPolypoint::write_compressed_points;
    using TK_PolyPolypoint::read_compressed_points;
    using TK_PolyPolypoint::write_trivial_leftovers;
    using TK_PolyPolypoint::read_trivial_leftovers;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Open_Segment : public HTK_Open_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Open_Segment(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Open_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Close_Segment : public HTK_Close_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Close_Segment(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Close_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Reopen_Segment : public HTK_Reopen_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Reopen_Segment(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Reopen_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Referenced_Segment : public HTK_Referenced_Segment, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Referenced_Segment(JNIEnv *jenv, char opcode);
    virtual ~SwigDirector_HTK_Referenced_Segment();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using HTK_Referenced_Segment::mh_stage;
    using HTK_Referenced_Segment::m_root;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Instance : public HTK_Instance, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Instance(JNIEnv *jenv, int from_index = 0, int from_variant = 0, int to_index = 0, int to_variant = 0, int options = 0, float const *xform = 0);
    virtual ~SwigDirector_HTK_Instance();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Delete_Object : public HTK_Delete_Object, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Delete_Object(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Delete_Object();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_LOD : public HTK_LOD, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_LOD(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_LOD();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Renumber : public HTK_Renumber, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Renumber(JNIEnv *jenv, unsigned char opcode, HC_KEY key = 0);
    virtual ~SwigDirector_HTK_Renumber();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Color : public HTK_Color, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Color(JNIEnv *jenv, int mask = 0, int channels = 0);
    virtual ~SwigDirector_HTK_Color();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Color_RGB : public HTK_Color_RGB, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Color_RGB(JNIEnv *jenv, int mask = 0, float const *rgb = 0);
    virtual ~SwigDirector_HTK_Color_RGB();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Color_By_Value : public HTK_Color_By_Value, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Color_By_Value(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Color_By_Value();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Color_By_Index : public HTK_Color_By_Index, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Color_By_Index(JNIEnv *jenv, unsigned char opcode, int mask = 0, int index = 0);
    virtual ~SwigDirector_HTK_Color_By_Index();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Color_By_FIndex : public HTK_Color_By_FIndex, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Color_By_FIndex(JNIEnv *jenv, int mask = 0, float index = 0.0);
    virtual ~SwigDirector_HTK_Color_By_FIndex();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Color_Composite : public HTK_Color_Composite, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Color_Composite(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Color_Composite();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using HTK_Color_Composite::m_parts;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Color_Map : public HTK_Color_Map, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Color_Map(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Color_Map();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Callback : public HTK_Callback, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Callback(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Callback();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Rendering_Options : public HTK_Rendering_Options, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Rendering_Options(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Rendering_Options();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Heuristics : public HTK_Heuristics, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Heuristics(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Heuristics();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Visibility : public HTK_Visibility, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Visibility(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Visibility();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Selectability : public HTK_Selectability, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Selectability(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Selectability();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Matrix : public HTK_Matrix, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Matrix(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Matrix();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Enumerated : public HTK_Enumerated, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Enumerated(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Enumerated();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key = -1, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Size : public HTK_Size, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Size(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Size();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Linear_Pattern : public HTK_Linear_Pattern, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Linear_Pattern(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Linear_Pattern();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key = -1, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Named : public HTK_Named, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Named(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Named();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key = -1, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Streaming : public HTK_Streaming, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Streaming(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Streaming();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Conditions : public HTK_Conditions, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Conditions(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Conditions();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_User_Options : public HTK_User_Options, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_User_Options(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_User_Options();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Unicode_Options : public HTK_Unicode_Options, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Unicode_Options(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Unicode_Options();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_User_Index : public HTK_User_Index, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_User_Index(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_User_Index();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_User_Value : public HTK_User_Value, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_User_Value(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_User_Value();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Camera : public HTK_Camera, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Camera(JNIEnv *jenv, unsigned char opcode = TKE_Camera);
    virtual ~SwigDirector_HTK_Camera();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Window : public HTK_Window, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Window(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Window();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Clip_Region : public HTK_Clip_Region, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Clip_Region(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Clip_Region();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Clip_Rectangle : public HTK_Clip_Rectangle, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Clip_Rectangle(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Clip_Rectangle();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Text_Font : public HTK_Text_Font, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Text_Font(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Text_Font();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Bounding : public HTK_Bounding, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Bounding(JNIEnv *jenv, unsigned char opcode);
    SwigDirector_HTK_Bounding(JNIEnv *jenv, unsigned char opcode, float *min, float *max);
    SwigDirector_HTK_Bounding(JNIEnv *jenv, unsigned char opcode, float *center, float radius);
    virtual ~SwigDirector_HTK_Bounding();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Point : public HTK_Point, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Point(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Point();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Line : public HTK_Line, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Line(JNIEnv *jenv, unsigned char opcode = TKE_Line);
    virtual ~SwigDirector_HTK_Line();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Polypoint : public HTK_Polypoint, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Polypoint(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Polypoint();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_NURBS_Curve : public HTK_NURBS_Curve, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_NURBS_Curve(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_NURBS_Curve();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_NURBS_Surface : public HTK_NURBS_Surface, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_NURBS_Surface(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_NURBS_Surface();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using HTK_NURBS_Surface::interpret_trim;
    using HTK_NURBS_Surface::execute_trim;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Area_Light : public HTK_Area_Light, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Area_Light(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Area_Light();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Spot_Light : public HTK_Spot_Light, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Spot_Light(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Spot_Light();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Cutting_Plane : public HTK_Cutting_Plane, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Cutting_Plane(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Cutting_Plane();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Circle : public HTK_Circle, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Circle(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Circle();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Ellipse : public HTK_Ellipse, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Ellipse(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Ellipse();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Sphere : public HTK_Sphere, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Sphere(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Sphere();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Cylinder : public HTK_Cylinder, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Cylinder(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Cylinder();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_PolyCylinder : public HTK_PolyCylinder, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_PolyCylinder(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_PolyCylinder();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status ReadSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::Read(tk);
    }
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status WriteSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::Write(tk);
    }
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    virtual TK_Status EnumerateEdges();
    virtual TK_Status EnumerateEdgesSwigPublic() {
      return TK_Polyhedron::EnumerateEdges();
    }
    virtual TK_Status LabelFakeEdges();
    virtual TK_Status LabelFakeEdgesSwigPublic() {
      return TK_Polyhedron::LabelFakeEdges();
    }
    virtual bool AllowInstancing(BStreamFileToolkit &tk) const;
    virtual bool AllowInstancingSwigPublic(BStreamFileToolkit &tk) const {
      return TK_Polyhedron::AllowInstancing(tk);
    }
    virtual TK_Status read_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points(tk);
    }
    virtual TK_Status write_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points(tk);
    }
    virtual TK_Status read_collection(BStreamFileToolkit &tk);
    virtual TK_Status read_collectionSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection(tk);
    }
    virtual TK_Status write_collection(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collectionSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection(tk,write_tag,variant);
    }
    virtual TK_Status read_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points_ascii(tk);
    }
    virtual TK_Status write_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points_ascii(tk);
    }
    virtual TK_Status read_collection_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_collection_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection_ascii(tk);
    }
    virtual TK_Status write_vertex_marker_sizes_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_vertex_marker_sizes_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_vertex_marker_sizes_ascii(tk);
    }
    virtual TK_Status write_collection_ascii(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collection_asciiSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection_ascii(tk,write_tag,variant);
    }
    virtual TK_Status mangle_points(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_pointsSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_points(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_point_attributes(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_point_attributesSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_point_attributes(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_face_attributes(BStreamFileToolkit &tk, int facemap_count, int facemap[]);
    virtual TK_Status mangle_face_attributesSwigPublic(BStreamFileToolkit &tk, int facemap_count, int facemap[]) {
      return TK_Polyhedron::mangle_face_attributes(tk,facemap_count,facemap);
    }
public:
    bool swig_overrides(int n) {
      return (n < 29 ? swig_override[n] : false);
    }
protected:
    bool swig_override[29];
};

class SwigDirector_HTK_Grid : public HTK_Grid, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Grid(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Grid();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Text : public HTK_Text, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Text(JNIEnv *jenv, unsigned char opcode);
    virtual ~SwigDirector_HTK_Text();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Font : public HTK_Font, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Font(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Font();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Image : public HTK_Image, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Image(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Image();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Texture : public HTK_Texture, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Texture(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Texture();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using HTK_Texture::mh_stage;
    using HTK_Texture::m_referee;
    using HTK_Texture::m_key;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Texture_Definitions : public HTK_Texture_Definitions, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Texture_Definitions(JNIEnv *jenv, bool shader = false);
    virtual ~SwigDirector_HTK_Texture_Definitions();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using HTK_Texture_Definitions::m_parts;
    using HTK_Texture_Definitions::m_num_parts;
    using HTK_Texture_Definitions::m_is_shader;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Glyph_Definition : public HTK_Glyph_Definition, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Glyph_Definition(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Glyph_Definition();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Glyph_Definitions : public HTK_Glyph_Definitions, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Glyph_Definitions(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Glyph_Definitions();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using HTK_Glyph_Definitions::m_parts;
    using HTK_Glyph_Definitions::m_num_parts;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Line_Style : public HTK_Line_Style, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Line_Style(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Line_Style();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Line_Styles : public HTK_Line_Styles, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Line_Styles(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Line_Styles();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    using HTK_Line_Styles::m_parts;
    using HTK_Line_Styles::m_num_parts;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};

class SwigDirector_HTK_Shell : public HTK_Shell, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Shell(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Shell();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = -1);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    virtual TK_Status EnumerateEdges();
    virtual TK_Status EnumerateEdgesSwigPublic() {
      return TK_Shell::EnumerateEdges();
    }
    virtual TK_Status LabelFakeEdges();
    virtual TK_Status LabelFakeEdgesSwigPublic() {
      return HTK_Shell::LabelFakeEdges();
    }
    virtual bool AllowInstancing(BStreamFileToolkit &tk) const;
    virtual bool AllowInstancingSwigPublic(BStreamFileToolkit &tk) const {
      return TK_Polyhedron::AllowInstancing(tk);
    }
    virtual TK_Status read_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points(tk);
    }
    virtual TK_Status write_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points(tk);
    }
    virtual TK_Status read_collection(BStreamFileToolkit &tk);
    virtual TK_Status read_collectionSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection(tk);
    }
    virtual TK_Status write_collection(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collectionSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection(tk,write_tag,variant);
    }
    virtual TK_Status read_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points_ascii(tk);
    }
    virtual TK_Status write_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points_ascii(tk);
    }
    virtual TK_Status read_collection_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_collection_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection_ascii(tk);
    }
    virtual TK_Status write_vertex_marker_sizes_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_vertex_marker_sizes_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_vertex_marker_sizes_ascii(tk);
    }
    virtual TK_Status write_collection_ascii(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collection_asciiSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection_ascii(tk,write_tag,variant);
    }
    virtual TK_Status mangle_points(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_pointsSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_points(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_point_attributes(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_point_attributesSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_point_attributes(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_face_attributes(BStreamFileToolkit &tk, int facemap_count, int facemap[]);
    virtual TK_Status mangle_face_attributesSwigPublic(BStreamFileToolkit &tk, int facemap_count, int facemap[]) {
      return TK_Polyhedron::mangle_face_attributes(tk,facemap_count,facemap);
    }
    virtual TK_Status Usefulness(BStreamFileToolkit &tk, HC_KEY key, int lod, float &score) const;
    virtual TK_Status UsefulnessSwigPublic(BStreamFileToolkit &tk, HC_KEY key, int lod, float &score) const {
      return HTK_Shell::Usefulness(tk,key,lod,score);
    }
    using HTK_Shell::ProcessRevisits;
public:
    bool swig_overrides(int n) {
      return (n < 30 ? swig_override[n] : false);
    }
protected:
    bool swig_override[30];
};

class SwigDirector_HTK_Mesh : public HTK_Mesh, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_Mesh(JNIEnv *jenv);
    virtual ~SwigDirector_HTK_Mesh();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = 0);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
    virtual TK_Status EnumerateEdges();
    virtual TK_Status EnumerateEdgesSwigPublic() {
      return TK_Mesh::EnumerateEdges();
    }
    virtual TK_Status LabelFakeEdges();
    virtual TK_Status LabelFakeEdgesSwigPublic() {
      return TK_Polyhedron::LabelFakeEdges();
    }
    virtual bool AllowInstancing(BStreamFileToolkit &tk) const;
    virtual bool AllowInstancingSwigPublic(BStreamFileToolkit &tk) const {
      return TK_Polyhedron::AllowInstancing(tk);
    }
    virtual TK_Status read_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points(tk);
    }
    virtual TK_Status write_trivial_points(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_pointsSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points(tk);
    }
    virtual TK_Status read_collection(BStreamFileToolkit &tk);
    virtual TK_Status read_collectionSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection(tk);
    }
    virtual TK_Status write_collection(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collectionSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection(tk,write_tag,variant);
    }
    virtual TK_Status read_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_trivial_points_ascii(tk);
    }
    virtual TK_Status write_trivial_points_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_trivial_points_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_trivial_points_ascii(tk);
    }
    virtual TK_Status read_collection_ascii(BStreamFileToolkit &tk);
    virtual TK_Status read_collection_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::read_collection_ascii(tk);
    }
    virtual TK_Status write_vertex_marker_sizes_ascii(BStreamFileToolkit &tk);
    virtual TK_Status write_vertex_marker_sizes_asciiSwigPublic(BStreamFileToolkit &tk) {
      return TK_Polyhedron::write_vertex_marker_sizes_ascii(tk);
    }
    virtual TK_Status write_collection_ascii(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0);
    virtual TK_Status write_collection_asciiSwigPublic(BStreamFileToolkit &tk, bool write_tag = false, int variant = 0) {
      return TK_Polyhedron::write_collection_ascii(tk,write_tag,variant);
    }
    virtual TK_Status mangle_points(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_pointsSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_points(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_point_attributes(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]);
    virtual TK_Status mangle_point_attributesSwigPublic(BStreamFileToolkit &tk, int pointmap_count, int pointmap[]) {
      return TK_Polyhedron::mangle_point_attributes(tk,pointmap_count,pointmap);
    }
    virtual TK_Status mangle_face_attributes(BStreamFileToolkit &tk, int facemap_count, int facemap[]);
    virtual TK_Status mangle_face_attributesSwigPublic(BStreamFileToolkit &tk, int facemap_count, int facemap[]) {
      return TK_Polyhedron::mangle_face_attributes(tk,facemap_count,facemap);
    }
public:
    bool swig_overrides(int n) {
      return (n < 29 ? swig_override[n] : false);
    }
protected:
    bool swig_override[29];
};

class SwigDirector_HTK_PolyPolypoint : public HTK_PolyPolypoint, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_HTK_PolyPolypoint(JNIEnv *jenv, unsigned char op);
    virtual ~SwigDirector_HTK_PolyPolypoint();
    virtual TK_Status Read(BStreamFileToolkit &tk);
    virtual TK_Status Write(BStreamFileToolkit &tk);
    virtual TK_Status Execute(BStreamFileToolkit &tk);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, int variant = -1);
    virtual TK_Status Interpret(BStreamFileToolkit &tk, long key, char const *special);
    virtual void Reset();
    virtual bool Match_Instance(BStreamFileToolkit const &tk, Recorded_Instance *instance);
    virtual TK_Status Clone(BStreamFileToolkit &tk, BBaseOpcodeHandler **handler) const;
    virtual bool NeedsContext(BStreamFileToolkit &tk) const;
public:
    bool swig_overrides(int n) {
      return (n < 10 ? swig_override[n] : false);
    }
protected:
    bool swig_override[10];
};


#endif
